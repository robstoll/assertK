{"version":3,"file":"atrium-domain-api-js.js","sources":["../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/assertions/composers/AssertionComposer.kt","util/Lazy.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/AnyAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/CharSequenceAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/CollectionAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/ComparableAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/FeatureAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/FloatingPointAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/IterableAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/ListAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/MapAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/MapEntryAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/NewFeatureAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/PairAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/ThrowableAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/any/typetransformation/AnyTypeTransformation.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/any/typetransformation/creators/AnyTypeTransformationAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/any/typetransformation/failurehandlers/FailureHandlerFactory.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/changers/ChangedSubjectPostStep.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/changers/ExtractedFeaturePostStep.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/changers/FeatureExtractor.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/changers/PostFinalStep.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/changers/SubjectChanger.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/charsequence/contains/checkers/CheckerFactory.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/charsequence/contains/creators/CharSequenceContainsAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/charsequence/contains/searchbehaviours/NoOpSearchBehaviour.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/charsequence/contains/searchbehaviours/SearchBehaviourFactory.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/collectors/AssertionCollector.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/collectors/AssertionCollectorForExplanation.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/feature/extract/FeatureExtractor.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/feature/extract/creators/FeatureExtractorCreatorFactory.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/feature/extract/impl/deprecatedImpl.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/iterable/contains/checkers/CheckerFactory.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/iterable/contains/creators/IterableContainsAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/iterable/contains/searchbehaviours/NoOpSearchBehaviour.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/iterable/contains/searchbehaviours/SearchBehaviourFactory.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/throwable/thrown/creators/ThrowableThrownAssertions.kt","../../../../../atrium-domain-api-common/src/main/kotlin/ch/tutteli/atrium/domain/creating/throwable/thrown/providers/AbsentThrowableMessageProviderFactory.kt"],"sourcesContent":["package ch.tutteli.atrium.domain.assertions.composers\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.DescriptiveAssertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * The access point to an implementation of [AssertionComposer].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\n@Deprecated(\"Use ExpectImpl.builder.descriptive.withFailureHint instead; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nval assertionComposer by lazy { loadSingleService(AssertionComposer::class) }\n\n/**\n * Responsible to compose [Assertion]s based on the [AssertionBuilder].\n */\n@Deprecated(\"Use ExpectImpl.builder.descriptive.withFailureHint instead; will be removed with 1.0.0\")\ninterface AssertionComposer {\n    /**\n     * Shall create kind of a [DescriptiveAssertion] if [test] holds or an [AssertionGroup] which includes additionally\n     * a failure hint created by the given [failureHintFactory] in case [showHint] evaluates to `true`.\n     *\n     * Notice, it is up to the implementation if a really a [DescriptiveAssertion] is created if [test] holds or if\n     * another kind of [Assertion] is used. However, the implementation should treat the given [description] and\n     * [representation] as it would be treated if it is part of a [DescriptiveAssertion].\n     *\n     * @param description The [DescriptiveAssertion.description].\n     * @param representation The [DescriptiveAssertion.representation].\n     * @param test The test which should be used for [DescriptiveAssertion.holds].\n     * @param showHint Indicates whether the failure hint shall be shown in case [test] fails.\n     * @param failureHintFactory A factory method used to create the failure hint.\n     */\n    fun createDescriptiveWithFailureHint(\n        description: Translatable,\n        representation: Any,\n        test: () -> Boolean,\n        showHint: () -> Boolean,\n        failureHintFactory: () -> Assertion\n    ): Assertion\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.changers.ChangedSubjectPostStep\nimport kotlin.reflect.KClass\n\n/**\n * The access point to an implementation of [AnyAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval anyAssertions by lazy { loadSingleService(AnyAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [Any] type,\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface AnyAssertions {\n\n    fun <T : Any> toBe(subjectProvider: SubjectProvider<T>, expected: T): Assertion\n    fun <T> notToBe(subjectProvider: SubjectProvider<T>, expected: T): Assertion\n    fun <T> isSame(subjectProvider: SubjectProvider<T>, expected: T): Assertion\n    fun <T> isNotSame(subjectProvider: SubjectProvider<T>, expected: T): Assertion\n\n    fun <T : Any?> toBeNull(subjectProvider: SubjectProvider<T>): Assertion\n\n    fun <T : Any> toBeNullable(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        expectedOrNull: T?\n    ): Assertion\n\n    fun <T : Any> toBeNullIfNullGivenElse(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        assertionCreatorOrNull: (Expect<T>.() -> Unit)?\n    ): Assertion\n\n    /**\n     * Convenience method for nullable-types which delegates to [isA].\n     */\n    fun <T : Any> notToBeNull(assertionContainer: Expect<T?>, subType: KClass<T>) =\n        isA(assertionContainer, subType)\n\n    //TODO restrict TSub with T once type parameter for upper bounds are supported:\n    // https://youtrack.jetbrains.com/issue/KT-33262 is implemented\n    fun <T, TSub : Any> isA(assertionContainer: Expect<T>, subType: KClass<TSub>): ChangedSubjectPostStep<T, TSub>\n\n\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    fun <T : Any> isNullable(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        expectedOrNull: T?\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use notTobeNull; will be removed with 1.0.0\")\n    fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        assertionCreator: AssertionPlant<T>.() -> Unit\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use toBe; will be removed with 1.0.0\")\n    fun <T : Any> isNotNullBut(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        expected: T\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullIfNullGivenElse; will be removed with 1.0.0\")\n    fun <T : Any> isNullIfNullGivenElse(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        assertionCreatorOrNull: (AssertionPlant<T>.() -> Unit)?\n    ): Assertion\n}\n\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NotSearchBehaviour\n\n/**\n * The access point to an implementation of [CharSequenceAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval charSequenceAssertions by lazy { loadSingleService(CharSequenceAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [CharSequence],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface CharSequenceAssertions {\n    fun <T : CharSequence> containsBuilder(subjectProvider: SubjectProvider<T>): CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    fun <T : CharSequence> containsNotBuilder(subjectProvider: SubjectProvider<T>): CharSequenceContains.Builder<T, NotSearchBehaviour>\n\n    fun startsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence): Assertion\n    fun startsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence): Assertion\n    fun endsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence): Assertion\n    fun endsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence): Assertion\n    fun isEmpty(subjectProvider: SubjectProvider<CharSequence>): Assertion\n    fun isNotEmpty(subjectProvider: SubjectProvider<CharSequence>): Assertion\n    fun isNotBlank(subjectProvider: SubjectProvider<CharSequence>): Assertion\n    fun <T : CharSequence> matches(assertionContainer: Expect<T>, expected: Regex): Assertion\n    fun <T : CharSequence> mismatches(assertionContainer: Expect<T>, expected: Regex): Assertion\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\n\n/**\n * The access point to an implementation of [CollectionAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval collectionAssertions by lazy { loadSingleService(CollectionAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [Collection],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface CollectionAssertions {\n    fun isEmpty(subjectProvider: SubjectProvider<Collection<*>>): Assertion\n    fun isNotEmpty(subjectProvider: SubjectProvider<Collection<*>>): Assertion\n\n    fun <T : Collection<*>> size(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, Int>\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun hasSize(plant: AssertionPlant<Collection<*>>, size: Int): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun size(plant: AssertionPlant<Collection<*>>, assertionCreator: Assert<Int>.() -> Unit): Assertion\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\n\n/**\n * The access point to an implementation of [ComparableAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval comparableAssertions by lazy { loadSingleService(ComparableAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [Comparable],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface ComparableAssertions {\n    fun <T1 : Comparable<T2>, T2 : Any?> isLessThan(subjectProvider: SubjectProvider<T1>, expected: T2): Assertion\n    fun <T1 : Comparable<T2>, T2 : Any?> isLessOrEquals(subjectProvider: SubjectProvider<T1>, expected: T2): Assertion\n    fun <T1 : Comparable<T2>, T2 : Any?> isGreaterThan(subjectProvider: SubjectProvider<T1>, expected: T2): Assertion\n    fun <T1 : Comparable<T2>, T2 : Any?> isGreaterOrEquals(\n        subjectProvider: SubjectProvider<T1>, expected: T2\n    ): Assertion\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * The access point to an implementation of [FeatureAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use newFeatureAssertions; will be removed with 1.0.0\")\nval featureAssertions by lazy { loadSingleService(FeatureAssertions::class) }\n\n/**\n * Defines the minimum set of assertion functions -- used to create feature assertions --\n * which an implementation of the domain of Atrium has to provide.\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use then ExpectImpl.feature, NewFeatureAssertionsBuilder respectively; will be removed with 1.0.0\")\ninterface FeatureAssertions {\n\n    fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, subjectProvider: () -> TProperty, name: Translatable): AssertionPlant<TProperty>\n    fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, subjectProvider: () -> TProperty, representationProvider: () -> Any?, name: Translatable): AssertionPlant<TProperty>\n    fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, subjectProvider: () -> TProperty, name: Translatable): AssertionPlantNullable<TProperty>\n    fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, subjectProvider: () -> TProperty, representationProvider: () -> Any?, name: Translatable): AssertionPlantNullable<TProperty>\n\n    //Arg0\n    fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: () -> R, name: String): AssertionPlant<R>\n    fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: () -> R, representationProvider: () -> Any?, name: String): AssertionPlant<R>\n    fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: () -> R, name: String): AssertionPlantNullable<R>\n    fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: () -> R, representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n\n    //Arg1\n    fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: (T1) -> R, arg1: T1, name: String): AssertionPlant<R>\n    fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: (T1) -> R, arg1: T1, representationProvider: () -> Any?, name: String): AssertionPlant<R>\n    fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: (T1) -> R, arg1: T1, name: String): AssertionPlantNullable<R>\n    fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: (T1) -> R, arg1: T1, representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n\n    //Arg2\n    fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlant<R>\n    fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: (T1, T2) -> R, arg1: T1, arg2: T2, representationProvider: () -> Any?, name: String): AssertionPlant<R>\n    fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlantNullable<R>\n    fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: (T1, T2) -> R, arg1: T1, arg2: T2, representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n\n    //Arg3\n    fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlant<R>\n    fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, representationProvider: () -> Any?, name: String): AssertionPlant<R>\n    fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlantNullable<R>\n    fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n\n    //Arg4\n    fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlant<R>\n    fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, representationProvider: () -> Any?, name: String): AssertionPlant<R>\n    fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlantNullable<R>\n    fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n\n    //Arg5\n    fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlant<R>\n    fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, representationProvider: () -> Any?, name: String): AssertionPlant<R>\n    fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlantNullable<R>\n    fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\n\n/**\n * The access point to an implementation of [FloatingPointAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval floatingPointAssertions by lazy { loadSingleService(FloatingPointAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to floating points,\n * which an implementation of the domain of Atrium has to provide.\n *\n * An `actual` or in other words platform specific interface might add further methods.\n */\nexpect interface FloatingPointAssertions : FloatingPointAssertionsCommon\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to floating points ([Float], [Double]),\n * which an implementation of the domain of Atrium has to provide for any platform.\n */\ninterface FloatingPointAssertionsCommon {\n    fun toBeWithErrorTolerance(subjectProvider: SubjectProvider<Float>, expected: Float, tolerance: Float): Assertion\n    fun toBeWithErrorTolerance(subjectProvider: SubjectProvider<Double>, expected: Double, tolerance: Double): Assertion\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NotSearchBehaviour\n\n/**\n * The access point to an implementation of [IterableAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval iterableAssertions by lazy { loadSingleService(IterableAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [Iterable],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface IterableAssertions {\n    fun <E, T : Iterable<E>> containsBuilder(subjectProvider: SubjectProvider<T>): IterableContains.Builder<E, T, NoOpSearchBehaviour>\n    fun <E, T : Iterable<E>> containsNotBuilder(subjectProvider: SubjectProvider<T>): IterableContains.Builder<E, T, NotSearchBehaviour>\n\n    fun <E : Any, T : Iterable<E?>> all(\n        assertionContainer: Expect<T>,\n        assertionCreator: (Expect<E>.() -> Unit)?\n    ): Assertion\n\n    fun <E, T : Iterable<E>> hasNext(expect: Expect<T>): Assertion\n    fun <E, T : Iterable<E>> hasNotNext(expect: Expect<T>): Assertion\n\n    fun <E : Comparable<E>, T : Iterable<E>> min(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, E>\n    fun <E : Comparable<E>, T : Iterable<E>> max(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, E>\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <E : Any> all(plant: AssertionPlant<Iterable<E?>>, assertionCreator: (AssertionPlant<E>.() -> Unit)?): Assertion\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\n\n/**\n * The access point to an implementation of [ListAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval listAssertions by lazy { loadSingleService(ListAssertions::class) }\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [List],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface ListAssertions {\n\n    fun <E, T : List<E>> get(\n        assertionContainer: Expect<T>,\n        index: Int\n    ): ExtractedFeaturePostStep<T, E>\n\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <T : Any> get(plant: AssertionPlant<List<T>>, index: Int): AssertionPlant<T>\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <T : Any> get(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        assertionCreator: AssertionPlant<T>.() -> Unit\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use `get` instead; will be removed with 1.0.0\")\n    fun <T> getNullable(plant: AssertionPlant<List<T>>, index: Int): AssertionPlantNullable<T>\n\n    @Deprecated(\"Switch from Assert to Expect and use `get` instead; will be removed with 1.0.0\")\n    fun <T> getNullable(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        assertionCreator: AssertionPlantNullable<T>.() -> Unit\n    ): Assertion\n}\n\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport kotlin.reflect.KClass\n\n/**\n * The access point to an implementation of [MapAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval mapAssertions by lazy { loadSingleService(MapAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [Map],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface MapAssertions {\n    fun <K, V : Any, T : Map<out K, V?>> contains(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValuePairs: List<Pair<K, V?>>\n    ): Assertion\n\n    fun <K, V : Any, T : Map<out K, V?>> containsKeyWithValueAssertions(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValues: List<Pair<K, (Expect<V>.() -> Unit)?>>\n    ): Assertion\n\n    fun <K> containsKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K): Assertion\n    fun <K> containsNotKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K): Assertion\n\n    fun isEmpty(subjectProvider: SubjectProvider<Map<*, *>>): Assertion\n    fun isNotEmpty(subjectProvider: SubjectProvider<Map<*, *>>): Assertion\n\n    fun <K, V, T : Map<out K, V>> getExisting(assertionContainer: Expect<T>, key: K): ExtractedFeaturePostStep<T, V>\n\n    fun <T : Map<*, *>> size(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, Int>\n\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <K, V> contains(plant: AssertionPlant<Map<out K, V>>, keyValuePairs: List<Pair<K, V>>): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <K, V : Any> containsKeyWithValueAssertions(\n        plant: AssertionPlant<Map<out K, V?>>,\n        keyValues: List<Pair<K, (Assert<V>.() -> Unit)?>>\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <K, V : Any> getExisting(plant: AssertionPlant<Map<out K, V>>, key: K): AssertionPlant<V>\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <K, V : Any> getExisting(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use getExisting instead; will be removed with 1.0.0\")\n    fun <K, V> getExistingNullable(plant: AssertionPlant<Map<out K, V>>, key: K): AssertionPlantNullable<V>\n\n    @Deprecated(\"Switch from Assert to Expect and use getExisting instead; will be removed with 1.0.0\")\n    fun <K, V> getExistingNullable(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun hasSize(plant: AssertionPlant<Map<*, *>>, size: Int): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <K> keys(plant: AssertionPlant<Map<out K, *>>, assertionCreator: AssertionPlant<Set<K>>.() -> Unit): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <V> values(\n        plant: AssertionPlant<Map<*, V>>,\n        assertionCreator: AssertionPlant<Collection<V>>.() -> Unit\n    ): Assertion\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport kotlin.reflect.KClass\n\n/**\n * The access point to an implementation of [MapAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval mapEntryAssertions by lazy { loadSingleService(MapEntryAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [Map],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface MapEntryAssertions {\n    fun <K : Any, V : Any, T : Map.Entry<K, V>> isKeyValue(assertionContainer: Expect<T>, key: K, value: V): Assertion\n    fun <K : Any, V : Any, T : Map.Entry<K?, V?>> isKeyValue(\n        assertionContainer: Expect<T>,\n        key: K?,\n        value: V?,\n        keyType: KClass<K>,\n        valueType: KClass<V>\n    ): Assertion\n\n    fun <K, T : Map.Entry<K, *>> key(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, K>\n    fun <V, T : Map.Entry<*, V>> value(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, V>\n\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <K : Any, V : Any> isKeyValue(plant: AssertionPlant<Map.Entry<K, V>>, key: K, value: V): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <K : Any> key(plant: AssertionPlant<Map.Entry<K, *>>, assertionCreator: AssertionPlant<K>.() -> Unit): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <V : Any> value(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use key; will be removed with 1.0.0\")\n    fun <K> nullableKey(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use value; will be removed with 1.0.0\")\n    fun <V> nullableValue(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.core.None\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.core.Some\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\n\n/**\n * The access point to an implementation of [FeatureAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n *\n * Will be renamed to featureAssertions with 1.0.0\n */\nval newFeatureAssertions by lazy { loadSingleService(NewFeatureAssertions::class) }\n\n/**\n * Defines the minimum set of assertion functions -- used to create feature assertions --\n * which an implementation of the domain of Atrium has to provide.\n *\n * Will be renamed to FeatureAssertions with 1.0.0\n */\ninterface NewFeatureAssertions {\n\n    /**\n     * Extracts a feature from [assertionContainer] based on the given [MetaFeature] and creates a\n     * [ExtractedFeaturePostStep] based on it.\n     *\n     * @return The newly created [ExtractedFeaturePostStep].\n     */\n    fun <T, R> genericFeature(\n        assertionContainer: Expect<T>,\n        metaFeature: MetaFeature<R>\n    ): ExtractedFeaturePostStep<T, R>\n}\n\n/**\n * Represents an extracted feature of type [T] defined by the given [maybeSubject] including a [description]\n * and a [representation]\n *\n * @property description Will be used in reporting to describe the feature extraction - e.g. the name of a property,\n *   a method call etc.\n * @property representation The representation of the feature, in most cases the value behind the feature.\n * @property maybeSubject The feature as such where it is [Some] in case the extraction was successful or [None] if it\n *   was not.\n */\ndata class MetaFeature<T>(val description: Translatable, val representation: Any?, val maybeSubject: Option<T>) {\n    constructor(description: String, representation: Any?, maybeSubject: Option<T>) :\n        this(Untranslatable(description), representation, maybeSubject)\n\n    constructor(description: String, subject: T) : this(description, subject, Some(subject))\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\n\n/**\n * The access point to an implementation of [PairAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval pairAssertions by lazy { loadSingleService(PairAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [Map],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface PairAssertions {\n    fun <K, T : Pair<K, *>> first(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, K>\n    fun <V, T : Pair<*, V>> second(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, V>\n\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <K : Any> first(plant: AssertionPlant<Pair<K, *>>, assertionCreator: AssertionPlant<K>.() -> Unit): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <V : Any> second(plant: AssertionPlant<Pair<*, V>>, assertionCreator: AssertionPlant<V>.() -> Unit): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <K> nullableFirst(\n        plant: AssertionPlant<Pair<K, *>>,\n        assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    fun <V> nullableSecond(\n        plant: AssertionPlant<Pair<*, V>>,\n        assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion\n}\n","package ch.tutteli.atrium.domain.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\n\n/**\n * The access point to an implementation of [ThrowableAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval throwableAssertions by lazy { loadSingleService(ThrowableAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions and builders applicable to [Throwable],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface ThrowableAssertions {\n    /**\n     * Turns the given [assertionVerb] into an [Untranslatable] and delegates to the other overload.\n     */\n    fun thrownBuilder(assertionVerb: String, act: () -> Unit, reporter: Reporter): ThrowableThrown.Builder =\n        thrownBuilder(Untranslatable(assertionVerb), act, reporter)\n\n    fun thrownBuilder(assertionVerb: Translatable, act: () -> Unit, reporter: Reporter): ThrowableThrown.Builder\n}\n\n","@file:Suppress(\"DEPRECATION\" /* TODO remove with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.creating.any.typetransformation\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.BaseAssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * Defines the contract for sophisticated `type transformation` assertion builders.\n *\n * The assertion is created by a [AnyTypeTransformation.Creator] which itself uses a\n * [AnyTypeTransformation.FailureHandler] to report a failing transformation.\n */\n@Deprecated(\"Switch from `Assert` to `Expect` use `SubjectChanger` instead; will be removed with 1.0.0\")\ninterface AnyTypeTransformation {\n\n    /**\n     * Represents the final step of a sophisticated `type transformation` assertion builder which creates the\n     * [Assertion] as such.\n     *\n     * @param S The type of [AssertionPlant.subject][SubjectProvider.subject].\n     * @param T The target type to which [AssertionPlant.subject][SubjectProvider.subject] should have been transformed to.\n     */\n    @Deprecated(\"Switch from `Assert` to `Expect` use `SubjectChanger` instead; will be removed with 1.0.0\")\n    interface Creator<S : Any, T : Any> {\n        /**\n         * Creates the type transformation [Assertion] and ads it to the given [ParameterObject.subjectPlant] and\n         * delegates to the given [failureHandler] if the transformation fails.\n         *\n         * @param parameterObject The [ParameterObject] containing inter alia [ParameterObject.assertionCreator] to\n         *   create subsequent assertions.\n         * @param canBeTransformed Defines whether the subject of the given [ParameterObject.subjectPlant]\n         *   (with type [S]) can be transformed to the target type [T].\n         * @param transform The transformation function as such.\n         * @param failureHandler The failure handler which is called if the transformation cannot be executed\n         */\n        fun create(\n            parameterObject: ParameterObject<S, T>,\n            canBeTransformed: (S) -> Boolean,\n            transform: (S) -> T,\n            failureHandler: FailureHandler<S, T>\n        )\n    }\n\n    /**\n     * A handler which is responsible to create the [Assertion] of a failed type transformation.\n     *\n     * It is also responsible to decide how the lambda -- which could have created subsequent assertions for the\n     * transformed [AssertionPlant.subject][SubjectProvider.subject] if the transformation of the [AssertionPlant.subject][SubjectProvider.subject] to type [T]\n     * did not fail -- should be used in reporting.\n     *\n     * @param S The type of [AssertionPlant.subject][SubjectProvider.subject].\n     * @param T The target type to which [AssertionPlant.subject][SubjectProvider.subject] should have been transformed to.\n     */\n    @Deprecated(\"Switch from `Assert` to `Expect` use `SubjectChanger` instead; will be removed with 1.0.0\")\n    interface FailureHandler<in S : Any, out T : Any> {\n\n        /**\n         * Creates the failing assertion and adds it to the [ParameterObject.subjectPlant].\n         *\n         * Typically it uses [createFailingAssertion] to create the failing assertion and augments it with\n         * collected assertions or such.\n         *\n         * @param parameterObject The [ParameterObject] containing inter alia [ParameterObject.assertionCreator], the\n         *   lambda which could have created subsequent assertions for the transformed [AssertionPlant.subject][SubjectProvider.subject].\n         *\n         * @throws AssertionError Might throw an [AssertionError] depending on the [ParameterObject.subjectPlant].\n         */\n        fun createAndAddAssertionToPlant(parameterObject: ParameterObject<S, T>)\n\n        /**\n         * Creates the failing [Assertion] based on the given [description] and [representation]\n         */\n        fun createFailingAssertion(description: Translatable, representation: Any): Assertion\n    }\n\n    /**\n     * A parameter object which contains all necessary information to report a failure\n     *\n     * @param description Describes what assertion the type transformation represents, e.g. `is a` in case of a down cast.\n     * @param representation The representation of the expected result, e.g. `Int::class` in case of a down cast\n     *   from [Number] to [Int].\n     * @param subjectPlant The plant to which the assertion (including additional assertions created by\n     *   [assertionCreator]) should be added.\n     * @param assertionCreator The lambda which can create subsequent assertions for the transformed\n     *   [AssertionPlant.subject][SubjectProvider.subject] in case the type transformation succeeds\n     * @param warningTransformationFailed Explains why the [subjectPlant]'s [subject][SubjectProvider.subject]\n     *   could not be transformed to the desired type.\n     */\n    @Deprecated(\"Switch from `Assert` to `Expect` use `SubjectChanger` instead; will be removed with 1.0.0\")\n    data class ParameterObject<out S : Any, in T : Any>(\n        val description: Translatable,\n        val representation: Any,\n        val subjectPlant: BaseAssertionPlant<S?, *>,\n        val assertionCreator: AssertionPlant<T>.() -> Unit,\n        val warningTransformationFailed: Translatable\n    )\n}\n","@file:Suppress(\"DEPRECATION\" /* TODO remove with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.creating.any.typetransformation.creators\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.BaseAssertionPlant\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.AnyTypeTransformation\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * The access point to an implementation of [AnyTypeTransformationAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use anyAssertions or subjectChanger instead; will be removed with 1.0.0\")\nval anyTypeTransformationAssertions by lazy { loadSingleService(AnyTypeTransformationAssertions::class) }\n\n\n/**\n * Defines the minimum set of assertion functions representing a type transformation,\n * which an implementation of the domain of Atrium has to provide.\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use AnyAssertions instead; will be removed with 1.0.0\")\ninterface AnyTypeTransformationAssertions {\n\n\n    @Deprecated(\n        \"This function will be removed in v.1.0.0 in favour of AssertImpl.any.isNotNull\", ReplaceWith(\n            \"plant.addAssertion(AssertImpl.any.isNotNull(plant, type, assertionCreator))\",\n            \"ch.tutteli.atrium.domain.builders.AssertImpl\"\n        )\n    )\n    fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        assertionCreator: AssertionPlant<T>.() -> Unit\n    )\n\n    fun <TSub : Any> isA(\n        plant: AssertionPlant<Any>,\n        subType: KClass<TSub>,\n        assertionCreator: AssertionPlant<TSub>.() -> Unit\n    )\n\n    fun <T : Any, TSub : T> downCast(\n        description: Translatable,\n        subType: KClass<TSub>,\n        subjectPlant: BaseAssertionPlant<T?, *>,\n        assertionCreator: AssertionPlant<TSub>.() -> Unit,\n        failureHandler: AnyTypeTransformation.FailureHandler<T, TSub>\n    )\n\n    fun <S : Any, T : Any> transform(\n        parameterObject: AnyTypeTransformation.ParameterObject<S, T>,\n        canBeTransformed: (S) -> Boolean,\n        transform: (S) -> T,\n        failureHandler: AnyTypeTransformation.FailureHandler<S, T>\n    )\n}\n","@file:Suppress(\"DEPRECATION\" /* TODO remove with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.ExplanatoryAssertionGroupType\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.AnyTypeTransformation\n\n/**\n * The access point to an implementation of [FailureHandlerFactory].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use subjectChanger instead; will be removed with 1.0.0\")\nval failureHandlerFactory by lazy { loadSingleService(FailureHandlerFactory::class) }\n\n/**\n * Defines the minimum set of [AnyTypeTransformation.FailureHandler]s an implementation of the domain of Atrium\n * has to provide.\n */\n@Deprecated(\"Use subjectChanger instead; will be removed with 1.0.0\")\ninterface FailureHandlerFactory {\n\n    /**\n     * Creates a [AnyTypeTransformation.FailureHandler] which wraps subsequent assertions into an\n     * [AssertionGroup] with an [ExplanatoryAssertionGroupType] so that the user of Atrium can see in reporting\n     * what one wanted to assert additionally.\n     */\n    fun <S : Any, T : Any> newExplanatory(): AnyTypeTransformation.FailureHandler<S, T>\n\n    /**\n     * Creates a [AnyTypeTransformation.FailureHandler] which wraps subsequent assertions into an\n     * [AssertionGroup] with an [ExplanatoryAssertionGroupType] so that the user of Atrium can see in reporting\n     * what one wanted to assert additionally -- moreover it includes a hint about the subject which shall only be shown\n     * if [showHint] evaluates to `true` in which case the given [failureHintFactory] should be used to create the hint.\n     *\n     * As an example, Atrium uses this failure handler internally to show the message of a thrown [Throwable] in case\n     * it is of a different type than the expected one.\n     *\n     * @param showHint Indicates whether the failure hint shall be included or not\n     * @param failureHintFactory Creates the failure hint.\n     */\n    fun <S : Any, T : Any> newExplanatoryWithHint(\n        showHint: () -> Boolean,\n        failureHintFactory: () -> Assertion\n    ): AnyTypeTransformation.FailureHandler<S, T>\n}\n","package ch.tutteli.atrium.domain.creating.changers\n\nimport ch.tutteli.atrium.creating.Expect\n\n/**\n * Option step which allows to decide what should be done with the transformed subject of type [R].\n *\n * Notice, this class does not add any functionality to [PostFinalStep] and is more like a marker.\n * The purpose of the marker is extensibility, this way you can write a post-final-step which only applies to\n * [ChangedSubjectPostStep] and not to all kind of [PostFinalStep].\n *\n * @param assertionContainer The assertion container which was involved in the building process\n *   and holds assertion for the initial subject.\n * @param transform The subject transformation which creates and returns a new [Expect] of type [R].\n * @param transformAndApply The subject transformation which not only creates and\n *   returns a new [Expect] of type [R] but also applies a given assertionCreator lambda.\n */\nclass ChangedSubjectPostStep<T, R>(\n    assertionContainer: Expect<T>,\n    transform: Expect<T>.() -> Expect<R>,\n    transformAndApply: Expect<T>.(Expect<R>.() -> Unit) -> Expect<R>\n) : PostFinalStep<T, R>(assertionContainer, transform, transformAndApply)\n","package ch.tutteli.atrium.domain.creating.changers\n\nimport ch.tutteli.atrium.creating.Expect\n\n/**\n * Option step which allows to decide what should be done with the extracted feature of type [R].\n *\n * Notice, this class does not add any functionality to [PostFinalStep] and is more like a marker.\n * The purpose of the marker is extensibility, this way you can write a post-final-step which only applies to\n * [ExtractedFeaturePostStep] and not to all kind of [PostFinalStep].\n *\n * @param assertionContainer The assertion container which was involved in the building process\n *   and holds assertion for the initial subject.\n * @param extract The extraction of the feature which creates and returns a new [Expect] of type [R].\n * @param extractAndApply The extraction of the feature which not only creates and\n *   returns a new [Expect] of type [R] but also applies a given assertionCreator lambda.\n */\nclass ExtractedFeaturePostStep<T, R>(\n    assertionContainer: Expect<T>,\n    extract: Expect<T>.() -> Expect<R>,\n    extractAndApply: Expect<T>.(Expect<R>.() -> Unit) -> Expect<R>\n) : PostFinalStep<T, R>(assertionContainer, extract, extractAndApply)\n","@file:Suppress(\"DEPRECATION\")\n\npackage ch.tutteli.atrium.domain.creating.changers\n\nimport ch.tutteli.atrium.core.None\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.core.Some\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.NewFeatureAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * The access point to an implementation of [FeatureExtractor].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval featureExtractor by lazy { loadSingleService(FeatureExtractor::class) }\n\n/**\n * Defines the contract for sophisticated `safe feature extractions` including assertion creation for the feature.\n *\n * It is similar to [NewFeatureAssertions] but differs in the intended usage.\n * [NewFeatureAssertions] are intended to make assertions about a return value of a method call or a property,\n * assuming that the call as such always succeeds (no exception is thrown).\n * The [FeatureExtractor] on the other hand should be used if it is already known,\n * that the call/access fails depending on given arguments.\n * For instance, [List.get] is a good example where it fails if the given index is out of bounds.\n */\ninterface FeatureExtractor {\n\n    /**\n     * Extracts a feature according to the given [featureExtraction], creates an [Expect] for the\n     * new subject and applies [maybeSubAssertions] in case they are specified.\n     *\n     *\n     * @param originalAssertionContainer the assertion container with the current subject (before the change) --\n     *   if you use `ExpectImpl.changeSubject.reported(...)` within an assertion function (an extension function of\n     *   [Expect]) then you usually pass `this` (so the instance of [Expect]) for this parameter.\n     * @param description Describes the feature\n     * @param representationForFailure Representation in case the extraction cannot be carried out.\n     * @param featureExtraction Extracts the feature where it returns the feature wrapped into a [Some] if the\n     *   extraction as such can be carried out, otherwise [None].\n     * @param maybeSubAssertions Optionally, subsequent assertions for the feature (the new subject).\n     *   This is especially useful if the extraction cannot be carried out, because this way we can then already\n     *   show to you (in error reporting) what you wanted to assert about the feature (which gives you more context to\n     *   the error).\n     * @param representationInsteadOfFeature Per default the feature as such is used to represent itself. However,\n     *   if you want a different representation, then use this parameter where passing `null` still means use the\n     *   feature.\n     *\n     * @return The newly created [Expect].\n     */\n    fun <T, R> extract(\n        originalAssertionContainer: Expect<T>,\n        description: Translatable,\n        representationForFailure: Any,\n        featureExtraction: (T) -> Option<R>,\n        maybeSubAssertions: Option<Expect<R>.() -> Unit>,\n        representationInsteadOfFeature: Any? = null\n    ): Expect<R>\n}\n","package ch.tutteli.atrium.domain.creating.changers\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.collectors.assertionCollector\n\n/**\n * Step which kind of holds the state of a previous final step related to a subject change/feature extraction etc.\n * and now allows to decide what should happen with it.\n *\n * @param T The type of the current [Expect], the current subject of the assertion respectively.\n * @param R The type of the new [Expect], the new subject of the assertion respectively.\n *\n * @property assertionContainer The assertion container which was involved in the building process\n *   and holds assertion for the initial subject.\n * @property action An action such as transform, extract etc. which creates and returns a new [Expect] of type [R].\n * @property actionAndApply An action such as transform, extract etc. which not only creates and\n *   returns a new [Expect] of type [R] but also applies a given assertionCreator lambda.\n */\nabstract class PostFinalStep<T, R>(\n    protected val assertionContainer: Expect<T>,\n    protected val action: Expect<T>.() -> Expect<R>,\n    protected val actionAndApply: Expect<T>.(Expect<R>.() -> Unit) -> Expect<R>\n) {\n\n    /**\n     * Returns the newly created [Expect] for the feature.\n     */\n    fun getExpectOfFeature(): Expect<R> = action(assertionContainer)\n\n\n    /**\n     * Collects the assertions the given [assertionCreator] might create for the new [Expect] of the feature\n     * and returns them as a single [Assertion]\n     *\n     * @returns An assertion consisting of all assertions the given [assertionCreator] might create\n     *   for the new [Expect] of the feature.\n     */\n    fun collect(assertionCreator: Expect<R>.() -> Unit): Assertion = assertionCollector.collect(assertionContainer) {\n        actionAndApply(this, assertionCreator)\n    }\n\n\n    /**\n     * Creates a new [Expect] for the feature, adds all assertions the given [assertionCreator] creates for it\n     * and returns the new [Expect].\n     * @returns An assertion consisting of all assertions the given [assertionCreator] might create\n     *   for the new [Expect] of the feature.\n     */\n    fun addToFeature(assertionCreator: Expect<R>.() -> Unit): Expect<R> {\n        return actionAndApply(assertionContainer) {\n            // collect also checks that the user specified at least one assertion in the assertionCreator lambda\n            addAssertion(assertionCollector.collect(this, assertionCreator))\n        }\n    }\n\n    /**\n     * Creates a new [Expect] for the feature, adds all assertions the given [assertionCreator] creates for it\n     * and returns the initial [Expect].\n     *\n     * @returns An assertion consisting of all assertions the given [assertionCreator] might create\n     *   for the new [Expect] of the feature.\n     */\n    fun addToInitial(assertionCreator: Expect<R>.() -> Unit): Expect<T> {\n        // collect also checks that the user specified at least one assertion in the assertionCreator lambda\n        return assertionContainer.addAssertion(collect(assertionCreator))\n    }\n}\n","package ch.tutteli.atrium.domain.creating.changers\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.None\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.core.Some\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * The access point to an implementation of [SubjectChanger].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval subjectChanger by lazy { loadSingleService(SubjectChanger::class) }\n\n/**\n * Defines the contract to change the subject of an assertion container (e.g. the subject of [Expect]) by creating\n * a new [Expect] whereas the new [Expect] delegates assertion checking to a given original assertion container.\n */\ninterface SubjectChanger {\n\n    /**\n     * Changes to a new subject according to the given [transformation] without showing it\n     * in reporting and returns a new [Expect] for the new subject.\n     *\n     * Explained a bit more in depth: it creates a new [Expect] incorporating the given [transformation]\n     * whereas the new [Expect] delegates assertion checking to the given [originalAssertionContainer] -\n     * the change as such will not be reflected in reporting.\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, in case the change to the new subject is not always safe (you assert so but it does not have to be),\n     * then you should use [reported] so that the assertion is reflected in reporting.\n     *\n     * @param originalAssertionContainer the assertion container with the current subject (before the change) --\n     *   if you use `ExpectImpl.changeSubject(...).unreported` within an assertion function (an extension function of\n     *   [Expect]) then you usually pass `this` (so the instance of [Expect]) for this parameter.\n     * @param transformation Provides the subject.\n     *\n     * @return The newly created [Expect].\n     */\n    fun <T, R> unreported(\n        originalAssertionContainer: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R>\n\n\n    /**\n     * Changes to a new subject according to the given [transformation] --\n     * the change as such is reflected in reporting by the given [description] and [representation].\n     *\n     * Explained a bit more in depth: it creates a new [Expect] incorporating the given [transformation]\n     * whereas the new [Expect] delegates assertion checking to the given [originalAssertionContainer].\n     * The [transformation] as such can either return the new subject wrapped in a [Some] or [None] in case\n     * the transformation cannot be carried out.\n     *\n     * This method is useful if you want to change the subject whereas the change as such is assertion like as well, so\n     * that it should be reported as well. For instance, say you want to change the subject of type `Int?` to `Int`.\n     * Since the subject could also be `null` it makes sense to report this assertion instead of failing\n     * with an exception.\n     *\n     * @param originalAssertionContainer the assertion container with the current subject (before the change) --\n     *   if you use `ExpectImpl.changeSubject.reported(...)` within an assertion function (an extension function of\n     *   [Expect]) then you usually pass `this` (so the instance of [Expect]) for this parameter.\n     * @param description Describes the kind of subject change (e.g. in case of a type change `is a`).\n     * @param representation Representation of the change (e.g. in case of a type transformation the KClass).\n     * @param transformation Provides the subject wrapped into a [Some] if the extraction as such can be carried out\n     *   otherwise [None].\n     * @param failureHandler The [FailureHandler] which shall be used in case the subject cannot be transformed.\n     *   A failure has the chance to augment the failing assertion representing the failed transformation with further\n     *   information.\n     * @param maybeSubAssertions Optionally, subsequent assertions for the new subject. This is especially useful if the\n     *   change fails since we can then already show to you (in error reporting) what you wanted to assert about\n     *   the new subject (which gives you more context to the error).\n     *\n     * @return The newly created [Expect].\n     */\n    fun <T, R> reported(\n        originalAssertionContainer: Expect<T>,\n        description: Translatable,\n        representation: Any,\n        transformation: (T) -> Option<R>,\n        failureHandler: FailureHandler<T, R>,\n        maybeSubAssertions: Option<Expect<R>.() -> Unit>\n    ): Expect<R>\n\n    /**\n     * Represents a handler which is responsible to create the assertion resulting from a failed subject change.\n     *\n     * A handler should augment the failing assertion with explanatory assertions in case the user supplied an\n     * assertionCreator lambda. Yet, a failure handler might also add additional information -- e.g. regarding the\n     * current subject.\n     */\n    interface FailureHandler<T, R> {\n        /**\n         * Creates the failing assertion most likely based on the given [descriptiveAssertion] -- which in turn\n         * is based on the previously specified description, representation etc. -- and should incorporate\n         * the assertions [maybeAssertionCreator] would have created for the new subject as explanatory assertions.\n         *\n         * @return A failing assertion.\n         */\n        fun createAssertion(\n            originalAssertionContainer: Expect<T>,\n            descriptiveAssertion: Assertion,\n            maybeAssertionCreator: Option<Expect<R>.() -> Unit>\n        ): Assertion\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n    fun <T, R : Any> unreportedToAssert(\n        originalPlant: SubjectProvider<T>,\n        transformation: (T) -> R\n    ): Assert<R>\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n    fun <T, R> unreportedNullableToAssert(\n        originalPlant: SubjectProvider<T>,\n        transformation: (T) -> R\n    ): AssertionPlantNullable<R>\n}\n","package ch.tutteli.atrium.domain.creating.charsequence.contains.checkers\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * The access point to an implementation of [CheckerFactory].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval checkerFactory by lazy { loadSingleService(CheckerFactory::class) }\n\n\n/**\n * Defines the minimum set of [CharSequenceContains.Checker]s an implementation of the domain of Atrium\n * has to provide.\n */\ninterface CheckerFactory {\n    /**\n     * Creates an [CharSequenceContains.Checker] which verifies that an expected object is contained at least [times]\n     * in the search input.\n     *\n     * @param times The number which the check uses to compare against the actual number of times an expected object is\n     *   found in the input of the search.\n     * @param nameContainsNotFun The function which should be used instead of `atLeastCall` when [times] equals to zero.\n     * @param atLeastCall The function which was used and should not be used if [times] equals to zero.\n     *\n     * @throws IllegalArgumentException In case [times] is smaller than 1.\n     */\n    fun newAtLeastChecker(\n        times: Int,\n        nameContainsNotFun: String,\n        atLeastCall: (Int) -> String\n    ): CharSequenceContains.Checker\n\n    /**\n     * Creates an [CharSequenceContains.Checker] which verifies that an expected object is contained at most [times]\n     * in the search input.\n     *\n     * @param times The number which the check uses to compare against the actual number of times an expected object is\n     *   found in the input of the search.\n     * @param nameContainsNotFun The function which should be used instead of `atMostCall` when [times] equals to zero.\n     * @param atMostCall The function which was used and should not be used if [times] equals to zero.\n     *\n     * @throws IllegalArgumentException In case [times] is smaller than 1.\n     */\n    fun newAtMostChecker(\n        times: Int,\n        nameContainsNotFun: String,\n        atMostCall: (Int) -> String\n    ): CharSequenceContains.Checker\n\n    /**\n     * Creates an [CharSequenceContains.Checker] which verifies that an expected object is contained exactly [times]\n     * in the search input.\n     *\n     * @param times The number which the check uses to compare against the actual number of times an expected object is\n     *   found in the input of the search.\n     * @param nameContainsNotFun The function which should be used instead of `exactlyCall` when [times] equals to zero.\n     * @param exactlyCall The function call which was used and should not be used if [times] equals to zero.\n     *\n     * @throws IllegalArgumentException In case [times] is smaller than 1.\n     */\n    fun newExactlyChecker(\n        times: Int,\n        nameContainsNotFun: String,\n        exactlyCall: (Int) -> String\n    ): CharSequenceContains.Checker\n\n    /**\n     * Creates an [CharSequenceContains.Checker] which verifies that an expected object is not contained\n     * in the search input.\n     */\n    fun newNotChecker(): CharSequenceContains.Checker\n}\n","package ch.tutteli.atrium.domain.creating.charsequence.contains.creators\n\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * The access point to an implementation of [CharSequenceContainsAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval charSequenceContainsAssertions by lazy { loadSingleService(CharSequenceContainsAssertions::class) }\n\n\n/**\n * Defines the minimum set of `contains` assertion functions for [CharSequence],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface CharSequenceContainsAssertions {\n\n    fun <T : CharSequence> values(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Any>\n    ): AssertionGroup\n\n    fun <T : CharSequence> valuesIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Any>\n    ): AssertionGroup\n\n    fun <T : CharSequence> defaultTranslationOf(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Translatable>\n    ): AssertionGroup\n\n    fun <T : CharSequence> defaultTranslationOfIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Translatable>\n    ): AssertionGroup\n\n    fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Regex>\n    ): AssertionGroup\n\n    fun <T : CharSequence> regexIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<String>\n    ): AssertionGroup\n}\n","package ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours\n\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * Represents the default search behaviour or rather does not define a search behaviour at all.\n *\n * It furthermore implements a no operation for [decorateDescription], meaning it passes back the description which\n * is passed in (identity function).\n */\ninterface NoOpSearchBehaviour : CharSequenceContains.SearchBehaviour {\n    /**\n     * Returns the given [description].\n     * @return The given [description].\n     */\n    override fun decorateDescription(description: Translatable) = description\n}\n","package ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * The access point to an implementation of [SearchBehaviourFactory].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval searchBehaviourFactory by lazy { loadSingleService(SearchBehaviourFactory::class) }\n\n\n/**\n * Defines the minimum set of [CharSequenceContains.SearchBehaviour]s an implementation of the domain of Atrium\n * has to provide.\n */\ninterface SearchBehaviourFactory {\n\n    fun <T : CharSequence> ignoringCase(\n        containsBuilder: CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    ): CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>\n}\n","package ch.tutteli.atrium.domain.creating.collectors\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.ExplanatoryAssertionGroupType\nimport ch.tutteli.atrium.assertions.InvisibleAssertionGroupType\nimport ch.tutteli.atrium.core.None\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.core.Some\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.MapAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * The access point to an implementation of [AssertionCollector].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval assertionCollector: AssertionCollector by lazy { loadSingleService(AssertionCollector::class) }\n\n/**\n * Responsible to collect assertions made in an `assertionCreator`-lambda.\n */\ninterface AssertionCollector {\n\n    /**\n     * Uses the [Expect.maybeSubject] and delegates to the other overload.\n     *\n     * See the other overload for more information.\n     */\n    fun <T> collect(\n        assertionContainer: Expect<T>,\n        assertionCreator: Expect<T>.() -> Unit\n    ): Assertion = collect(assertionContainer.maybeSubject, assertionCreator)\n\n    /**\n     * Use this function if you want to make [Assertion]s about a feature or you perform a type transformation or any\n     * other action which results in an assertion container being created and\n     * you do not require this resulting container.\n     *\n     * Or in other words, you do not want to make further assertions about the resulting subject in the resulting sub\n     * assertion container.\n     *\n     * @param maybeSubject Either [Some] wrapping the subject of the current assertion or\n     *   [None] in case a previous subject change was not successful - used as subject for the given [assertionCreator].\n     * @param assertionCreator A lambda which defines the assertions for the feature.\n     *\n     * @return The collected assertions as an [AssertionGroup] with an [InvisibleAssertionGroupType].\n     *\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single\n     *   assertion.\n     */\n    fun <T> collect(maybeSubject: Option<T>, assertionCreator: Expect<T>.() -> Unit): Assertion\n\n\n    /**\n     * Use this function if you want to collect [Assertion]s and use it as part of an [AssertionGroup].\n     *\n     * @param maybeSubject Either [Some] wrapping the subject of the current assertion or\n     *   [None] in case a previous subject change was not successful - used as subject for the given [assertionCreator].\n     * @param assertionCreator A lambda which defines the assertions for the feature.\n     *\n     * @return The collected assertions as an [AssertionGroup] with an [InvisibleAssertionGroupType].\n     *\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single\n     *   assertion.\n     */\n    fun <T> collectForComposition(maybeSubject: Option<T>, assertionCreator: Expect<T>.() -> Unit): List<Assertion>\n\n    /**\n     * Use this function if you want to make [Assertion](s) about a feature or you perform a type transformation or any\n     * other action which results in a sub-[AssertionPlant] being created and you do not require this resulting plant.\n     *\n     * Or in other words, you do not want to make further assertions about the resulting subject in the resulting sub\n     * assertion plant.\n     *\n     * This function can be useful in several cases. For instance:\n     * - You are writing an assertion about a feature often enough so that it deserves an own assertion function\n     *   (see e.g. [MapAssertions.hasSize])\n     * - You want the collected assertion to be part of an [AssertionGroup]\n     *\n     * @param plant The plant from which the [AssertionPlant.subject][SubjectProvider.subject] will be used as subject of the\n     *   [CollectingAssertionPlant].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlant] and adds assertions\n     *   to it. For instance, if you create a feature assertion or a type transformation assertion, you will typically\n     *   end up creating a sub assertion plant which delegates created [Assertion]s to the [CollectingAssertionPlant].\n     *\n     * @return The collected assertions as an [AssertionGroup] with an [InvisibleAssertionGroupType].\n     *\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single\n     *   assertion, did not pass it to the [CollectingAssertionPlant] respectively.\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T : Any> collect(\n        plant: AssertionPlant<T>,\n        assertionCreator: CollectingAssertionPlant<T>.() -> Unit\n    ): AssertionGroup = collect(plant.subjectProvider, assertionCreator)\n\n    /**\n     * Use this function if you want to make [Assertion](s) about a feature or you perform a type transformation or any\n     * other action which results in a sub-[AssertionPlant] being created and you do not require this resulting plant.\n     *\n     * Or in other words, you do not want to make further assertions about the resulting subject in the resulting sub\n     * assertion plant.\n     *\n     * This function can be useful in several cases. For instance:\n     * - You are writing an assertion about a feature often enough so that it deserves an own assertion function\n     *   (see e.g. [MapAssertions.hasSize])\n     * - You want the collected assertion to be part of an [AssertionGroup]\n     *\n     * @param subjectProvider Provides the subject which is used as [CollectingAssertionPlant.subject].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlant] and adds assertions\n     *   to it. For instance, if you create a feature assertion or a type transformation assertion, you will typically\n     *   end up creating a sub assertion plant which delegates created [Assertion]s to the [CollectingAssertionPlant].\n     *\n     * @return The collected assertions as an [AssertionGroup] with an [InvisibleAssertionGroupType].\n     *\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single\n     *   assertion, did not pass it to the [CollectingAssertionPlant] respectively.\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T : Any> collect(\n        subjectProvider: () -> T,\n        assertionCreator: CollectingAssertionPlant<T>.() -> Unit\n    ): AssertionGroup = collect(subjectProvider, coreFactory::newCollectingPlant, assertionCreator)\n\n    /**\n     * Use this function if you want to make [Assertion](s) about a feature or you perform a type transformation or any\n     * other action which results in a sub-[AssertionPlantNullable] being created and you do not require this resulting\n     * plant.\n     *\n     * Or in other words, you do not want to make further assertions about the resulting subject in the resulting sub\n     * assertion plant.\n     *\n     * This function can be useful in several cases. For instance:\n     * - You are writing an assertion about a feature often enough so that it deserves an own assertion function\n     *   (see e.g. [MapAssertions.hasSize])\n     * - You want the collected assertion to be part of an [AssertionGroup]\n     *\n     * @param plant The plant from which the [AssertionPlantNullable.subject][SubjectProvider.subject] will be used as subject of the\n     *   [CollectingAssertionPlantNullable].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlantNullable] and adds\n     *   assertions to it. For instance, if you create a feature assertion or a type transformation assertion, you will\n     *   typically end up creating a sub assertion plant which delegates created [Assertion]s to the\n     *   [CollectingAssertionPlantNullable].\n     *\n     * @return The collected assertions as an [AssertionGroup] with an [InvisibleAssertionGroupType].\n     *\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single\n     *   assertion, did not pass it to the [CollectingAssertionPlantNullable] respectively.\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T> collectNullable(\n        plant: AssertionPlantNullable<T>,\n        assertionCreator: CollectingAssertionPlantNullable<T>.() -> Unit\n    ): AssertionGroup = collectNullable(plant.subjectProvider, assertionCreator)\n\n    /**\n     * Use this function if you want to make [Assertion](s) about a feature or you perform a type transformation or any\n     * other action which results in a sub-[AssertionPlantNullable] being created and you do not require this resulting\n     * plant.\n     *\n     * Or in other words, you do not want to make further assertions about the resulting subject in the resulting sub\n     * assertion plant.\n     *\n     * This function can be useful in several cases. For instance:\n     * - You are writing an assertion about a feature often enough so that it deserves an own assertion function\n     *   (see e.g. [MapAssertions.hasSize])\n     * - You want the collected assertion to be part of an [AssertionGroup]\n     *\n     * @param subjectProvider Provides the subject which is used as [CollectingAssertionPlantNullable.subject].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlantNullable] and adds\n     *   assertions to it. For instance, if you create a feature assertion or a type transformation assertion, you will\n     *   typically end up creating a sub assertion plant which delegates created [Assertion]s to the\n     *   [CollectingAssertionPlantNullable].\n     *\n     * @return The collected assertions as an [AssertionGroup] with an [InvisibleAssertionGroupType].\n     *\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single\n     *   assertion, did not pass it to the [CollectingAssertionPlantNullable] respectively.\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T> collectNullable(\n        subjectProvider: () -> T,\n        assertionCreator: CollectingAssertionPlantNullable<T>.() -> Unit\n    ): AssertionGroup = collect(subjectProvider, coreFactory::newCollectingPlantNullable, assertionCreator)\n\n\n    /**\n     * Use this function if you want to make [Assertion](s) about a feature or you perform a type transformation or any\n     * other action which results in a sub-[BaseAssertionPlant] being created and\n     * you do not require this resulting plant.\n     *\n     * Or in other words, you do not want to make further assertions about the resulting subject in the resulting sub\n     * assertion plant.\n     *\n     * This function can be useful in several cases. For instance:\n     * - You are writing an assertion about a feature often enough so that it deserves an own assertion function\n     *   (see e.g. [MapAssertions.hasSize])\n     * - You want the collected assertion to be part of an [AssertionGroup]\n     *\n     * @param subjectProvider Provides the subject which is used as [CollectingAssertionPlantNullable.subject].\n     * @param collectingPlantFactory The factory method which creates the appropriate collecting plant which is suitable\n     *   for the given [assertionCreator].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlant] and adds assertions\n     *   to it. For instance, if you create a feature assertion or a type transformation assertion, you will typically\n     *   end up creating a sub assertion plant which delegates created [Assertion]s to the [CollectingAssertionPlant].\n     *\n     * @return The collected assertions as an [AssertionGroup] with an [InvisibleAssertionGroupType].\n     *\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single\n     *   assertion, did not pass it to the [BaseCollectingAssertionPlant] respectively.\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T, A : BaseAssertionPlant<T, A>, C : BaseCollectingAssertionPlant<T, A, C>> collect(\n        subjectProvider: () -> T,\n        collectingPlantFactory: (() -> T) -> C,\n        assertionCreator: C.() -> Unit\n    ): AssertionGroup\n\n    /**\n     * Depending on the given [safeToCollect] it either [AssertionCollector.collect]s the assertions the given\n     * [assertionCreator] might create or it uses it to create an [AssertionGroup] with an\n     * [ExplanatoryAssertionGroupType].\n     *\n     * @param safeToCollect Indicates whether it is safe to use the [AssertionPlant.subjectProvider] (means it does\n     *   not throw a [PlantHasNoSubjectException] if called)\n     * @param warningCannotEvaluate The translatable used to explain why the assertions could not be evaluated.\n     * @param plant The plant from which the [AssertionPlant.subject][SubjectProvider.subject] will be used as subject of the\n     *   [CollectingAssertionPlant].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlant] and adds assertions\n     *   to it. For instance, if you create a feature assertion or a type transformation assertion, you will typically\n     *   end up creating a sub assertion plant which delegates created [Assertion]s to the [CollectingAssertionPlant].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T : Any> collectOrExplain(\n        safeToCollect: Boolean,\n        warningCannotEvaluate: Translatable,\n        plant: AssertionPlant<T>,\n        assertionCreator: CollectingAssertionPlant<T>.() -> Unit\n    ): AssertionGroup = collectOrExplain(safeToCollect, warningCannotEvaluate, plant.subjectProvider, assertionCreator)\n\n    /**\n     * Depending on the given [safeToCollect] it either [AssertionCollector.collect]s the assertions the given\n     * [assertionCreator] might create or it uses it to create an [AssertionGroup] with an\n     * [ExplanatoryAssertionGroupType].\n     *\n     * @param safeToCollect Indicates whether it is safe to use the [subjectProvider] (means it does\n     *   not throw a [PlantHasNoSubjectException] if called)\n     * @param warningCannotEvaluate The translatable used to explain why the assertions could not be evaluated.\n     * @param subjectProvider Provides the subject which is used as [CollectingAssertionPlant.subject].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlant] and adds assertions\n     *   to it. For instance, if you create a feature assertion or a type transformation assertion, you will typically\n     *   end up creating a sub assertion plant which delegates created [Assertion]s to the [CollectingAssertionPlant].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T : Any> collectOrExplain(\n        safeToCollect: Boolean,\n        warningCannotEvaluate: Translatable,\n        subjectProvider: () -> T,\n        assertionCreator: CollectingAssertionPlant<T>.() -> Unit\n    ): AssertionGroup = collectOrExplain(\n        safeToCollect, warningCannotEvaluate, subjectProvider, coreFactory::newCollectingPlant, assertionCreator\n    )\n\n    /**\n     * Depending on the given [safeToCollect] it either [AssertionCollector.collect]s the assertions the given\n     * [assertionCreator] might create or it uses it to create an [AssertionGroup] with an\n     * [ExplanatoryAssertionGroupType].\n     *\n     * @param safeToCollect Indicates whether it is safe to use the [AssertionPlantNullable.subjectProvider] (means\n     *   it does not throw a [PlantHasNoSubjectException] if called)\n     * @param warningCannotEvaluate The translatable used to explain why the assertions could not be evaluated.\n     * @param plant The plant from which the [AssertionPlantNullable.subject][SubjectProvider.subject] will be used as subject of the\n     *   [CollectingAssertionPlantNullable].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlant] and adds assertions\n     *   to it. For instance, if you create a feature assertion or a type transformation assertion, you will typically\n     *   end up creating a sub assertion plant which delegates created [Assertion]s to the\n     *   [CollectingAssertionPlantNullable].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T> collectNullableOrExplain(\n        safeToCollect: Boolean,\n        warningCannotEvaluate: Translatable,\n        plant: AssertionPlantNullable<T>,\n        assertionCreator: CollectingAssertionPlantNullable<T>.() -> Unit\n    ): AssertionGroup = collectNullableOrExplain(\n        safeToCollect, warningCannotEvaluate, plant.subjectProvider, assertionCreator\n    )\n\n    /**\n     * Depending on the given [safeToCollect] it either [AssertionCollector.collect]s the assertions the given\n     * [assertionCreator] might create or it uses it to create an [AssertionGroup] with an\n     * [ExplanatoryAssertionGroupType].\n     *\n     * @param safeToCollect Indicates whether it is safe to use the [subjectProvider] (means it does\n     *   not throw a [PlantHasNoSubjectException] if called)\n     * @param warningCannotEvaluate The translatable used to explain why the assertions could not be evaluated.\n     * @param subjectProvider Provides the subject which is used as [CollectingAssertionPlantNullable.subject].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlant] and adds assertions\n     *   to it. For instance, if you create a feature assertion or a type transformation assertion, you will typically\n     *   end up creating a sub assertion plant which delegates created [Assertion]s to the\n     *   [CollectingAssertionPlantNullable].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T> collectNullableOrExplain(\n        safeToCollect: Boolean,\n        warningCannotEvaluate: Translatable,\n        subjectProvider: () -> T,\n        assertionCreator: CollectingAssertionPlantNullable<T>.() -> Unit\n    ): AssertionGroup = collectOrExplain(\n        safeToCollect, warningCannotEvaluate, subjectProvider, coreFactory::newCollectingPlantNullable, assertionCreator\n    )\n\n    /**\n     * Depending on the given [safeToCollect] it either [AssertionCollector.collect]s the assertions the given\n     * [assertionCreator] might create or it uses it to create an [AssertionGroup] with an [ExplanatoryAssertionGroupType].\n     *\n     * @param safeToCollect Indicates whether it is safe to use the [subjectProvider] (means it does\n     *   not throw a [PlantHasNoSubjectException])\n     * @param warningCannotEvaluate The [Translatable] used to explain why the assertions could not be evaluated.\n     * @param subjectProvider Provides the subject which is used as [BaseCollectingAssertionPlant.subject].\n     * @param collectingPlantFactory The factory method which creates the appropriate collecting plant which is suitable\n     *   for the given [assertionCreator].\n     * @param assertionCreator A lambda which typically creates a sub [AssertionPlant] and adds assertions\n     *   to it. For instance, if you create a feature assertion or a type transformation assertion, you will typically\n     *   end up creating a sub assertion plant which delegates created [Assertion]s to the [BaseCollectingAssertionPlant].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T, A : BaseAssertionPlant<T, A>, C : BaseCollectingAssertionPlant<T, A, C>> collectOrExplain(\n        safeToCollect: Boolean,\n        warningCannotEvaluate: Translatable,\n        subjectProvider: () -> T,\n        collectingPlantFactory: (() -> T) -> C,\n        assertionCreator: C.() -> Unit\n    ): AssertionGroup\n}\n","package ch.tutteli.atrium.domain.creating.collectors\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.ExplanatoryAssertionGroupType\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * Responsible to collect assertions made in a sub-[AssertionPlant] and intended for explanation.\n */\n@Deprecated(\"Switch from Assert to Expect and use AssertionCollector.collectForComposition instead; will be removed with 1.0.0\")\ninterface AssertionCollectorForExplanation {\n\n    /**\n     * Collects the [Assertion] created by [assertionCreator] and uses the given [maybeSubject] as\n     * [CollectingAssertionPlant.subject] if it is [MaybeSubject.Present].\n     *\n     * In case [maybeSubject] is [MaybeSubject.Absent] and [assertionCreator] is accessed, then a\n     * [PlantHasNoSubjectException] is thrown and caught in which case a single [AssertionGroup] with an\n     * [ExplanatoryAssertionGroupType] is returned containing the given [warningCannotEvaluate].\n     *\n     * @param warningCannotEvaluate The translatable used to explain why the assertions could not be evaluated.\n     * @param assertionCreator The function which should at least create one assertion.\n     * @param maybeSubject The subject which will be used for the [CollectingAssertionPlant].\n     *\n     * @return A list with the collected assertion or an [AssertionGroup] with an [ExplanatoryAssertionGroupType]\n     *   containing a warning if [maybeSubject] is [MaybeSubject.Absent] and an assertion function tries to access it.\n     * @throws IllegalArgumentException Might throw it in case not a single [Assertion] was collected\n     *   (e.g. ThrowingAssertionCollectorForExplanation does).\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T : Any> collect(\n        warningCannotEvaluate: Translatable,\n        maybeSubject: MaybeSubject<T>,\n        assertionCreator: (CollectingAssertionPlant<T>.() -> Unit)?\n    ): List<Assertion> = collect(warningCannotEvaluate, maybeSubject, coreFactory::newCollectingPlant, assertionCreator)\n\n    /**\n     * Collects the [Assertion] created by [assertionCreator] and uses the given [maybeSubject] as\n     * [CollectingAssertionPlantNullable.subject] if it is [MaybeSubject.Present].\n     *\n     * In case [maybeSubject] is [MaybeSubject.Absent] and [assertionCreator] is accessed, then a\n     * [PlantHasNoSubjectException] is thrown and caught in which case a single [AssertionGroup] with an\n     * [ExplanatoryAssertionGroupType] is returned containing the given [warningCannotEvaluate].\n     *\n     * @param warningCannotEvaluate The translatable used to explain why the assertions could not be evaluated.\n     * @param assertionCreator The function which should at least create one assertion.\n     * @param maybeSubject The subject which will be used for the [CollectingAssertionPlantNullable].\n     *\n     * @return A list with the collected assertion or an [AssertionGroup] with an [ExplanatoryAssertionGroupType]\n     *   containing a warning if [maybeSubject] is `null` and an assertion function tries to access it.\n     * @throws IllegalArgumentException Might throw it in case not a single [Assertion] was collected\n     *   (e.g. ThrowingAssertionCollectorForExplanation does).\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T> collectNullable(\n        warningCannotEvaluate: Translatable,\n        maybeSubject: MaybeSubject<T>,\n        assertionCreator: (CollectingAssertionPlantNullable<T>.() -> Unit)?\n    ): List<Assertion> = collect(\n        warningCannotEvaluate, maybeSubject, coreFactory::newCollectingPlantNullable, assertionCreator\n    )\n\n    /**\n     * Collects the [Assertion] created by [assertionCreator] with the collecting assertion plant created by the given\n     * [collectingPlantFactory] and uses the given [maybeSubject] as [BaseCollectingAssertionPlant.subject] if it is\n     * [MaybeSubject.Present].\n     *\n     * In case [maybeSubject] is [MaybeSubject.Absent] and [assertionCreator] is accessed, then a\n     * [PlantHasNoSubjectException] is thrown and caught in which case a single [AssertionGroup] with an\n     * [ExplanatoryAssertionGroupType] is returned containing the given [warningCannotEvaluate].\n     *\n     * @param warningCannotEvaluate The translatable used to explain why the assertions could not be evaluated.\n     * @param maybeSubject The subject which will be used for the [AssertionPlant].\n     * @param collectingPlantFactory The factory method which creates the appropriate collecting plant which is suitable\n     *   for the given [assertionCreator].\n     * @param assertionCreator The function which should at least create one assertion.\n\n     *\n     * @return A list with the collected assertion or an [AssertionGroup] with an [ExplanatoryAssertionGroupType]\n     *   containing a warning if [maybeSubject] is `null` and an assertion function tries to access it.\n     * @throws IllegalArgumentException Might throw it in case not a single [Assertion] was collected\n     *   (e.g. ThrowingAssertionCollectorForExplanation does).\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    fun <T, A : BaseAssertionPlant<T, A>, C : BaseCollectingAssertionPlant<T, A, C>> collect(\n        warningCannotEvaluate: Translatable,\n        maybeSubject: MaybeSubject<T>,\n        collectingPlantFactory: (() -> T) -> C,\n        assertionCreator: (C.() -> Unit)?\n    ): List<Assertion>\n}\n\n\n/**\n * The access point to an implementation of [NonThrowingAssertionCollectorForExplanation].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\n@Deprecated(\"Switch from Assert to Expect and use AssertionCollector.collectForComposition instead -- adds a failing assertion instead of throwing; this interface will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nval nonThrowingAssertionCollectorForExplanation: NonThrowingAssertionCollectorForExplanation by lazy {\n    loadSingleService(NonThrowingAssertionCollectorForExplanation::class)\n}\n\n/**\n * Represents an assertion collector meant for explanation which does *not* throw in case not a single [Assertion]\n * was collected.\n */\n@Deprecated(\"Switch from Assert to Expect and use AssertionCollector.collectForComposition instead -- adds a failing assertion instead of throwing; this interface will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\ninterface NonThrowingAssertionCollectorForExplanation : AssertionCollectorForExplanation\n\n\n/**\n * The access point to an implementation of [ThrowingAssertionCollectorForExplanation].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\n@Deprecated(\"Switch from Assert to Expect and use AssertionCollector.collectForComposition instead -- adds a failing assertion instead of throwing; this interface will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nval throwingAssertionCollectorForExplanation: ThrowingAssertionCollectorForExplanation by lazy {\n    loadSingleService(ThrowingAssertionCollectorForExplanation::class)\n}\n\n/**\n * Represents an assertion collector meant for explanation which throws in case not a single [Assertion] was collected.\n */\n@Deprecated(\"Switch from Assert to Expect and use AssertionCollector.collectForComposition instead -- adds a failing assertion instead of throwing; this interface will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\ninterface ThrowingAssertionCollectorForExplanation : AssertionCollectorForExplanation\n","@file:Suppress(\"DEPRECATION\" /* TODO remove with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.creating.feature.extract\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.FeatureAssertionGroupType\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.FeatureAssertions\nimport ch.tutteli.atrium.domain.creating.feature.extract.creators.featureExtractorCreatorFactory\nimport ch.tutteli.atrium.domain.creating.feature.extract.impl.DescriptionOptionImpl\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\n\n/**\n * Defines the contract for sophisticated `safe feature extractions` including assertion creation for the feature.\n *\n * It is similar to [FeatureAssertions] but differs in the intended usage. [FeatureAssertions] are intended to make\n * assertions about a return value of a method call or a property, regardless if this call/access fails or not.\n * The [FeatureExtractor] on the other hand should be used if it is already known, that the call/access fails depending\n * on given arguments. For instance, [List.get] is a good example where it fails if the given index is out of bounds.\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use then FeatureExtractor from package ch.tutteli.atrium.domain.creating.changers instead; will be removed with 1.0.0\")\ninterface FeatureExtractor {\n\n    companion object {\n        /**\n         * Entry point to use the feature extractor.\n         */\n        val builder: DescriptionOption = DescriptionOptionImpl()\n    }\n\n    /**\n     * Option step which allows to specify the description which will be used to describe the feature.\n     */\n    @Deprecated(\"Switch from `Assert` to `Expect` and use then FeatureExtractor from package ch.tutteli.atrium.domain.creating.changers instead; will be removed with 1.0.0\")\n    interface DescriptionOption {\n        /**\n         * Uses [coreFactory].[newMethodCallFormatter][CoreFactory.newMethodCallFormatter] to create a description\n         * of a method call with the given [methodName] and the given [arguments].\n         */\n        fun methodCall(methodName: String, vararg arguments: Any?): ParameterObjectOption =\n            feature(coreFactory.newMethodCallFormatter().format(methodName, arguments))\n\n        /**\n         * Uses the given [featureRepresentation] as description.\n         */\n        fun feature(featureRepresentation: () -> String): ParameterObjectOption =\n            withDescription(Untranslatable(featureRepresentation))\n\n        /**\n         * Uses the given [translatable] as description of the feature.\n         */\n        fun withDescription(translatable: Translatable): ParameterObjectOption\n    }\n\n    /**\n     * Option step to define the [ParameterObject].\n     */\n    @Deprecated(\"Switch from `Assert` to `Expect` and use then FeatureExtractor from package ch.tutteli.atrium.domain.creating.changers instead; will be removed with 1.0.0\")\n    interface ParameterObjectOption {\n        /**\n         * The previously chosen feature description.\n         */\n        val featureDescription: Translatable\n\n        /**\n         * Uses the given [parameterObject] where a non-nullable feature is extracted by\n         * [ParameterObject.featureExtraction].\n         */\n        fun <TSubject : Any, T : Any> withParameterObject(\n            parameterObject: ParameterObject<TSubject, T>\n        ): Creator<TSubject, T> = featureExtractorCreatorFactory.create(featureDescription, parameterObject)\n\n        /**\n         * Uses the given [parameterObject] where a nullable feature is extracted by\n         * [ParameterObject.featureExtraction].\n         */\n        fun <TSubject : Any, T : Any?> withParameterObjectNullable(\n            parameterObject: ParameterObject<TSubject, T>\n        ): CreatorNullable<TSubject, T> =\n            featureExtractorCreatorFactory.createNullable(featureDescription, parameterObject)\n    }\n\n    /**\n     * Final step of the sophisticated `safe feature extraction` where one can define [extractAndAssertIt]\n     * for the extracted feature or use [extract] to get the assertion plant.\n     */\n    @Deprecated(\"Switch from `Assert` to `Expect` and use then FeatureExtractor from package ch.tutteli.atrium.domain.creating.changers instead; will be removed with 1.0.0\")\n    interface CreatorLike<TSubject, T, A : BaseAssertionPlant<T, A>, C : BaseCollectingAssertionPlant<T, A, C>> {\n        /**\n         * The previously chosen feature representation.\n         */\n        val featureRepresentation: Translatable\n\n        /**\n         * The previously created [ParameterObject].\n         */\n        val parameterObject: ParameterObject<TSubject, T>\n\n        /**\n         * Extracts a feature with the help of the specified\n         * [parameterObject].[featureExtraction][ParameterObject.featureExtraction] if it\n         * [parameterObject].[canBeExtracted][ParameterObject.canBeExtracted] and returns an assertion plant for it.\n         *\n         * @returns The newly created feature assertion plant.\n         */\n        fun extract(): A\n\n        /**\n         * Extracts a feature with the help of the specified\n         * [parameterObject].[featureExtraction][ParameterObject.featureExtraction] if it\n         * [parameterObject].[canBeExtracted][ParameterObject.canBeExtracted] and uses the given [assertionCreator]\n         * to create feature assertions.\n         *\n         * In detail, it creates an [AssertionGroup] of type [FeatureAssertionGroupType] and either uses the given\n         * [assertionCreator] to create assertions about the feature if\n         * [parameterObject].[canBeExtracted][ParameterObject.canBeExtracted] evaluates to `true` or\n         * [assertionCreator] is used to create explanatory assertions\n         * (in case [parameterObject].[canBeExtracted][ParameterObject.canBeExtracted] evaluates to `false`).\n         *\n         * Notice, if [PlantHasNoSubjectException] is thrown during the evaluation of\n         * [parameterObject].[canBeExtracted][ParameterObject.canBeExtracted],\n         * then it is assumed reporting is taken place and it is already in the process of collecting assertions for\n         * explanation. In such a case [assertionCreator] is used to create assertions (not explanatory\n         * assertions within explanatory assertions).\n         *\n         * @param assertionCreator A lambda which creates the [Assertion]s for the extracted feature.\n         *\n         * @returns The assertion representing the feature extraction.\n         */\n        fun extractAndAssertIt(assertionCreator: C.() -> Unit): Assertion\n    }\n\n    /**\n     * Final step of the sophisticated `safe feature extraction` where one can define [extractAndAssertIt]\n     * for the extracted feature or use [extract] to get a feature [AssertionPlant].\n     */\n    @Deprecated(\"Switch from `Assert` to `Expect` and use then FeatureExtractor from package ch.tutteli.atrium.domain.creating.changers instead; will be removed with 1.0.0\")\n    interface Creator<TSubject, T : Any> :\n        CreatorLike<TSubject, T, AssertionPlant<T>, CollectingAssertionPlant<T>>\n\n    /**\n     * Final step of the sophisticated `safe feature extraction` where one can define [extractAndAssertIt]\n     * for the extracted feature or use [extract] to get a feature [AssertionPlantNullable].\n     */\n    @Deprecated(\"Switch from `Assert` to `Expect` and use then FeatureExtractor from package ch.tutteli.atrium.domain.creating.changers instead; will be removed with 1.0.0\")\n    interface CreatorNullable<TSubject, T> :\n        CreatorLike<TSubject, T, AssertionPlantNullable<T>, CollectingAssertionPlantNullable<T>>\n\n    /**\n     * A parameter object which contains all necessary information to extract a feature -- however, not to create\n     * assertions.\n     *\n     * @param subjectPlant The [AssertionPlant] which contains the subject from which the subject is extracted.\n     * @param extractionNotSuccessful Used as [AssertionGroup.representation] in case [canBeExtracted]\n     *   evaluates to false.\n     * @param warningCannotEvaluate The [Translatable] used to explain why the extraction could not be carried out.\n\n     * @param canBeExtracted Indicates whether it is safe to extract the feature or not (e.g. [Map.containsKey] as\n     *   counter part to [Map.get])\n     * @param featureExtraction The feature extraction as such (e.g. [Map.get], [List.get] etc.)\n     */\n    @Deprecated(\"Switch from `Assert` to `Expect` and use then FeatureExtractor from package ch.tutteli.atrium.domain.creating.changers instead; will be removed with 1.0.0\")\n    data class ParameterObject<TSubject, T>(\n        val subjectPlant: BaseAssertionPlant<TSubject, *>,\n        val extractionNotSuccessful: Translatable,\n        val warningCannotEvaluate: Translatable,\n        val canBeExtracted: (TSubject) -> Boolean,\n        val featureExtraction: (TSubject) -> T\n    )\n}\n","@file:Suppress(\"DEPRECATION\" /* TODO remove with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.creating.feature.extract.creators\n\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.domain.creating.feature.extract.FeatureExtractor\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * The access point to an implementation of [FeatureExtractorCreatorFactory].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use ch.tutteli.atrium.domain.creating.changers.featureExtractor instead; will be removed with 1.0.0\")\nval featureExtractorCreatorFactory by lazy { loadSingleService(FeatureExtractorCreatorFactory::class) }\n\n/**\n * Responsible to create a [FeatureExtractor.Creator].\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use ch.tutteli.atrium.domain.creating.changers.FeatureExtractor instead; will be removed with 1.0.0\")\ninterface FeatureExtractorCreatorFactory {\n\n    /**\n     * Creates a [FeatureExtractor.Creator] based on the given [featureRepresentation] and [parameterObject]\n     *\n     * @param featureRepresentation used as [AssertionGroup.description].\n     * @param parameterObject Parameter object which contains inter alia the\n     *   [FeatureExtractor.ParameterObject.canBeExtracted] and [FeatureExtractor.ParameterObject.featureExtraction]\n     *   functions.\n     *\n     * @return The newly created feature extractor creator.\n     */\n    fun <TSubject : Any, T : Any> create(\n        featureRepresentation: Translatable,\n        parameterObject: FeatureExtractor.ParameterObject<TSubject, T>\n    ): FeatureExtractor.Creator<TSubject, T>\n\n    /**\n     * Creates a [FeatureExtractor.CreatorNullable] based on the given [featureRepresentation] and [parameterObject]\n     *\n     * @param featureRepresentation used as [AssertionGroup.description].\n     * @param parameterObject Parameter object which contains inter alia the\n     *   [FeatureExtractor.ParameterObject.canBeExtracted] and [FeatureExtractor.ParameterObject.featureExtraction]\n     *   functions.\n     *\n     * @return The newly created feature extractor creator.\n     */\n    fun <TSubject : Any, T> createNullable(\n        featureRepresentation: Translatable,\n        parameterObject: FeatureExtractor.ParameterObject<TSubject, T>\n    ): FeatureExtractor.CreatorNullable<TSubject, T>\n}\n","@file:Suppress(\"DEPRECATION\" /* TODO remove with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.creating.feature.extract.impl\n\nimport ch.tutteli.atrium.domain.creating.feature.extract.FeatureExtractor\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n@Deprecated(\"Will be removed with 1.0.0\")\ninternal class DescriptionOptionImpl : FeatureExtractor.DescriptionOption {\n    override fun withDescription(translatable: Translatable): FeatureExtractor.ParameterObjectOption =\n        ParameterObjectOptionImpl(translatable)\n}\n\n@Deprecated(\"Will be removed with 1.0.0\")\ninternal class ParameterObjectOptionImpl(\n    override val featureDescription: Translatable\n) : FeatureExtractor.ParameterObjectOption\n","package ch.tutteli.atrium.domain.creating.iterable.contains.checkers\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\n\n/**\n * The access point to an implementation of [CheckerFactory].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval checkerFactory by lazy { loadSingleService(CheckerFactory::class) }\n\n\n/**\n * Defines the minimum set of [IterableContains.Checker]s an implementation of the domain of Atrium\n * has to provide.\n */\ninterface CheckerFactory {\n    /**\n     * Creates an [IterableContains.Checker] which verifies that an expected entry is contained at least [times]\n     * in the [Iterable].\n     *\n     * @param times The number which the check uses to compare against the actual number of times an expected entry is\n     *   found in the [Iterable].\n     * @param nameContainsNotFun The function which should be used instead of [atLeastCall] when [times] equals to zero.\n     * @param atLeastCall The function which was used and should not be used if [times] equals to zero.\n     *\n     * @throws IllegalArgumentException In case [times] is smaller than 1.\n     */\n    fun newAtLeastChecker(\n        times: Int,\n        nameContainsNotFun: String,\n        atLeastCall: (Int) -> String\n    ): IterableContains.Checker\n\n    /**\n     * Creates an [IterableContains.Checker] which verifies that an expected entry is contained at most [times]\n     * in the [Iterable].\n     *\n     * @param times The number which the check uses to compare against the actual number of times an expected entry is\n     *   found in the [Iterable].\n     * @param nameContainsNotFun The function which should be used instead of `atMostCall` when [times] equals to zero.\n     * @param atMostCall The function which was used and should not be used if [times] equals to zero.\n     *\n     * @throws IllegalArgumentException In case [times] is smaller than 1.\n     */\n    fun newAtMostChecker(\n        times: Int,\n        nameContainsNotFun: String,\n        atMostCall: (Int) -> String\n    ): IterableContains.Checker\n\n    /**\n     * Creates a [IterableContains.Checker] which verifies that an expected entry is contained exactly [times]\n     * in the [Iterable].\n     *\n     * @param times The number which the check uses to compare against the actual number of times an expected entry is\n     *   found in the [Iterable].\n     * @param nameContainsNotFun The function which should be used instead of `exactlyCall` when [times] equals to zero.\n     * @param exactlyCall The function call which was used and should not be used if [times] equals to zero.\n     *\n     * @throws IllegalArgumentException In case [times] is smaller than 1.\n     */\n    fun newExactlyChecker(\n        times: Int,\n        nameContainsNotFun: String,\n        exactlyCall: (Int) -> String\n    ): IterableContains.Checker\n\n    /**\n     * Creates  a [IterableContains.Checker] which verifies that an expected entry is not contained in the [Iterable].\n     */\n    fun newNotChecker(): IterableContains.Checker\n}\n","package ch.tutteli.atrium.domain.creating.iterable.contains.creators\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderOnlySearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlyGroupedSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlySearchBehaviour\n\n/**\n * The access point to an implementation of [IterableContainsAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval iterableContainsAssertions by lazy { loadSingleService(IterableContainsAssertions::class) }\n\n\n/**\n * Defines the minimum set of `contains` assertion functions for [Iterable],\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface IterableContainsAssertions {\n\n    fun <E, T : Iterable<E>> valuesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>,\n        expected: List<E>\n    ): Assertion\n\n    fun <E : Any, T : Iterable<E?>> entriesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ): Assertion\n\n\n    fun <E, T : Iterable<E>> valuesInAnyOrderOnly(\n        builder: IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ): Assertion\n\n    fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnly(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ): Assertion\n\n\n    fun <E, T : Iterable<E>> valuesInOrderOnly(\n        builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ): Assertion\n\n    fun <E : Any, T : Iterable<E?>> entriesInOrderOnly(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ): Assertion\n\n\n    fun <E, T : Iterable<E>> valuesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<E>>\n    ): Assertion\n\n    fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(Expect<E>.() -> Unit)?>>\n    ): Assertion\n\n\n    @Deprecated(\"Switch from Assert to Expect and use entriesInAnyOrderWithAssert; will be removed with 1.0.0\")\n    fun <E : Any, T : Iterable<E?>> entriesInAnyOrderWithAssert(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use entriesInAnyOrderOnlyWithAssert; will be removed with 1.0.0\")\n    fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use entriesInOrderOnlyWithAssert; will be removed with 1.0.0\")\n    fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ): Assertion\n\n    @Deprecated(\"Switch from Assert to Expect and use entriesInOrderOnlyGroupedWithAssert; will be removed with 1.0.0\")\n    fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGroupedWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(AssertionPlant<E>.() -> Unit)?>>\n    ): Assertion\n}\n","package ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours\n\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * Represents the default search behaviour or rather does not define a search behaviour at all.\n *\n * It furthermore implements a no operation for [decorateDescription], meaning it passes back the description which\n * is passed in (identity function).\n */\ninterface NoOpSearchBehaviour : IterableContains.SearchBehaviour {\n    /**\n     * Returns the given [description].\n     * @return The given [description].\n     */\n    override fun decorateDescription(description: Translatable) = description\n}\n","package ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\n\n/**\n * The access point to an implementation of [SearchBehaviourFactory].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval searchBehaviourFactory by lazy { loadSingleService(SearchBehaviourFactory::class) }\n\n\n/**\n * Defines the minimum set of [IterableContains.SearchBehaviour]s an implementation of the domain of Atrium\n * has to provide.\n */\ninterface SearchBehaviourFactory {\n\n    fun <E, T : Iterable<E>> inAnyOrder(\n        builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>\n    ): IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>\n\n    fun <E, T : Iterable<E>> inAnyOrderOnly(\n        builder: IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>\n    ): IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>\n\n    fun <E, T : Iterable<E>> inOrder(\n        builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>\n    ): IterableContains.Builder<E, T, InOrderSearchBehaviour>\n\n    fun <E, T : Iterable<E>> inOrderOnly(\n        builder: IterableContains.Builder<E, T, InOrderSearchBehaviour>\n    ): IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>\n\n    fun <E, T : Iterable<E>> inOrderOnlyGrouped(\n        builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>\n    ): IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>\n\n    fun <E, T : Iterable<E>> inOrderOnlyGroupedWithin(\n        builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>\n    ): IterableContains.Builder<E, T, InOrderOnlyGroupedWithinSearchBehaviour>\n}\n","package ch.tutteli.atrium.domain.creating.throwable.thrown.creators\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.creating.changers.ChangedSubjectPostStep\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\nimport kotlin.reflect.KClass\n\n/**\n * The access point to an implementation of [ThrowableThrownAssertions].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\nval throwableThrownAssertions by lazy { loadSingleService(ThrowableThrownAssertions::class) }\n\n\n/**\n * Defines the minimum set of \"a [Throwable] was `thrown`\"-assertion functions,\n * which an implementation of the domain of Atrium has to provide.\n */\ninterface ThrowableThrownAssertions {\n\n    fun <TExpected : Throwable> isA(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>\n    ): ChangedSubjectPostStep<Throwable?, TExpected>\n\n    fun notThrown(\n        throwableThrownBuilder: ThrowableThrown.Builder\n    ): ChangedSubjectPostStep<Throwable?, Nothing?>\n\n\n    @Deprecated(\"Switch from Assert to Expect and use isA instead; will be removed with 1.0.0\")\n    fun <TExpected : Throwable> toBe(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>,\n        assertionCreator: AssertionPlant<TExpected>.() -> Unit\n    )\n\n    @Deprecated(\"Switch from Assert to Expect and use notThrown instead; will be removed with 1.0.0\")\n    fun nothingThrown(throwableThrownBuilder: ThrowableThrown.Builder)\n}\n","package ch.tutteli.atrium.domain.creating.throwable.thrown.providers\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * The access point to an implementation of [AbsentThrowableMessageProviderFactory].\n *\n * It loads the implementation lazily via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Will be removed with 1.0.0\")\nval absentThrowableMessageProviderFactory by lazy { loadSingleService(AbsentThrowableMessageProviderFactory::class) }\n\n\n/**\n * Defines the minimum set of [ThrowableThrown.AbsentThrowableMessageProvider]s,\n * which an implementation of the domain of Atrium has to provide.\n */\n@Deprecated(\"Will be removed with 1.0.0\")\ninterface AbsentThrowableMessageProviderFactory {\n\n    @Suppress(\"DEPRECATION\")\n    fun translatableBased(translatable: Translatable): ThrowableThrown.AbsentThrowableMessageProvider\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgB8B,oC;IAAE,sD;EAA4C,C;;EAP5E,iC;WCkC4F,uB;G;;;;;;;;EC3BlE,gC;IAAE,kD;EAAwC,C;;EALpE,6B;WDgC4F,mB;G;;;gDCCxF,uC;IAII,wBAAI,kBAAJ,EAAwB,OAAxB,C;G;;;;;;ECjC2B,yC;IAAE,2D;EAAiD,C;;EALtF,sC;WFiC4F,4B;G;;;;;;;;EG5B3D,uC;IAAE,yD;EAA+C,C;;EALlF,oC;WHiC4F,0B;G;;;;;;;;EIhC3D,uC;IAAE,yD;EAA+C,C;;EALlF,oC;WJqC4F,0B;G;;;;;;;;EK7B9D,oC;IAAE,sD;EAA4C,C;;EAP5E,iC;WLoC4F,uB;G;;;;;;;;EMhCxD,0C;IAAE,4D;EAAkD,C;;EALxF,uC;WNqC4F,6B;G;;;;;;;;EO1B7D,qC;IAAE,uD;EAA6C,C;;EAL9E,kC;WP+B4F,wB;G;;;;;;;;EQ7BjE,iC;IAAE,mD;EAAyC,C;;EALtE,8B;WRkC4F,oB;G;;;;;;;;ES9BlE,gC;IAAE,kD;EAAwC,C;;EALpE,6B;WTmC4F,mB;G;;;;;;;;EU5B7D,qC;IAAE,uD;EAA6C,C;;EAL9E,kC;WViC4F,wB;G;;;;;;;;EWzB3D,uC;IAAE,yD;EAA+C,C;;EAPlF,oC;WXgC4F,0B;G;;;;;;;;EWOnE,gE;IAAC,8B;IAA+B,oC;IAA0B,gC;G;;;;;;EAC/E,4E;IAAA,qD;IACI,wBAAK,mBAAe,WAAf,CAAL,EAAkC,cAAlC,EAAkD,YAAlD,C;IADJ,Y;G;EAGA,yD;IAAA,qD;IAA+C,iBAAK,WAAL,EAAkB,OAAlB,EAA2B,SAAK,OAAL,CAA3B,Q;IAA/C,Y;G;qCAdJ,Y;IAU0B,uB;G;qCAV1B,Y;IAUyD,0B;G;qCAVzD,Y;IAUmF,wB;G;uCAVnF,qD;IAAA,uBAU0B,uDAV1B,EAUyD,gEAVzD,EAUmF,0DAVnF,C;G;mCAAA,Y;IAAA,OAU0B,8DAV1B,IAUyD,0DAVzD,KAUmF,sDAVnF,O;G;mCAAA,Y;IAAA,c;IAU0B,4D;IAA+B,+D;IAA0B,6D;IAVnF,a;G;iCAAA,iB;IAAA,4IAU0B,kDAV1B,IAUyD,wDAVzD,IAUmF,oDAVnF,I;G;EC1B2B,iC;IAAE,mD;EAAyC,C;;EALtE,8B;WZkC4F,oB;G;;;;;;;;Ea9B5D,sC;IAAE,wD;EAA8C,C;;EALhF,mC;WbmC4F,yB;G;;;uDatBxF,wC;IAII,kCAAc,mBAAe,aAAf,CAAd,EAA6C,GAA7C,EAAkD,QAAlD,C;G;;;;;;;;;;;;;;;;;;;;;;ECoE+C,yI;IAC/C,8B;IACA,oC;IACA,gC;IACA,wC;IACA,8D;G;;;;;;+DAnBJ,Y;IAeI,uB;G;+DAfJ,Y;IAgBI,0B;G;+DAhBJ,Y;IAiBI,wB;G;+DAjBJ,Y;IAkBI,4B;G;+DAlBJ,Y;IAmBI,uC;G;iEAnBJ,oG;IAAA,iDAeI,uDAfJ,EAgBI,gEAhBJ,EAiBI,0DAjBJ,EAkBI,sEAlBJ,EAmBI,uGAnBJ,C;G;6DAAA,Y;IAAA,OAeI,kEAfJ,IAgBI,0DAhBJ,KAiBI,sDAjBJ,KAkBI,8DAlBJ,KAmBI,oFAnBJ,O;G;6DAAA,Y;IAAA,c;IAeI,4D;IACA,+D;IACA,6D;IACA,iE;IACA,4E;IAnBJ,a;G;2DAAA,iB;IAAA,4IAeI,kDAfJ,IAgBI,wDAhBJ,IAiBI,oDAjBJ,IAkBI,4DAlBJ,IAmBI,kFAnBJ,I;G;;;;;;EC7DwC,kD;IAAE,oE;EAA0D,C;;EANxG,+C;Wf+B4F,qC;G;;;;;;;;EgB1B1D,wC;IAAE,0D;EAAgD,C;;EAPpF,qC;WhBiC4F,2B;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EiB1B1D,kF;IAI9B,yBAAoB,kBAApB,EAAwC,SAAxC,EAAmD,iBAAnD,C;G;;;;;;ECJgC,gF;IAIhC,yBAAoB,kBAApB,EAAwC,OAAxC,EAAiD,eAAjD,C;G;;;;;;ECJyB,mC;IAAE,qD;EAA2C,C;;EAL1E,gC;WnB+B4F,sB;G;;;+CmBZxF,sK;IA4BI,8C;MAAA,iCAAuC,I;WA5B3C,sV;G;;;;;;ECZ8B,mE;IAC9B,4C;IACA,oB;IACA,oC;G;+CAGA,Y;IAGsC,mBAAO,uBAAP,C;G;EAU0E,oF;IAAA,4B;MAC5G,kCAAe,SAAf,EAAqB,wBAArB,C;MACJ,W;IAAA,C;G;4CATA,4B;IAOiE,OAAA,wBAAmB,iBAAQ,uBAAR,EAA4B,oDAA5B,C;G;EAYtC,qE;IAAA,4B;MAEtC,+BAAa,wBAAmB,iBAAQ,SAAR,EAAc,wBAAd,CAAhC,C;MACJ,W;IAAA,C;G;iDAVJ,4B;IAOI,OAAO,oBAAe,uBAAf,EAAmC,mDAAnC,C;EAIX,C;iDAEA,4B;IASI,OAAO,uBAAmB,sBAAa,qBAAQ,gBAAR,CAAb,C;EAC9B,C;;;;;;EChDuB,iC;IAAE,mD;EAAyC,C;;EALtE,8B;WrB8B4F,oB;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EsBjCjE,iC;IAAE,mD;EAAyC,C;;EALtE,8B;WtBsC4F,oB;G;;;;;;;;EuB7BjD,iD;IAAE,mE;EAAyD,C;;EALtG,8C;WvBkC4F,oC;G;;;;;;;;;;;;;;;;;8DwB/BxF,uB;IAI8D,kB;G;;;;;;;;;;;;;ECN/B,yC;IAAE,2D;EAAiD,C;;EALtF,sC;WzBsC4F,4B;G;;;;;;;;E0BvBzC,qC;IAAE,uD;EAA6C,C;;EALlG,kC;W1B4B4F,wB;G;;;iD0BhBxF,gD;IAQe,4BAAQ,kBAAmB,aAA3B,EAAyC,gBAAzC,C;G;iDAoCf,mC;IA4BoB,4BAAQ,KAAM,gBAAd,EAA+B,gBAA/B,C;G;iDAEpB,6C;IA2BoB,4BAAQ,eAAR,uCAAyB,sC;;KAAzB,YAAyB,gBAAzB,IAA0D,gBAA1D,C;G;yDAEpB,mC;IA8BoB,oCAAgB,KAAM,gBAAtB,EAAuC,gBAAvC,C;G;yDAEpB,6C;IA6BoB,4BAAQ,eAAR,+CAAyB,sC;;KAAzB,YAAyB,gBAAzB,IAAkE,gBAAlE,C;G;0DAoCpB,yE;IAqBoB,qCAAiB,aAAjB,EAAgC,qBAAhC,EAAuD,KAAM,gBAA7D,EAA8E,gBAA9E,C;G;0DAEpB,mF;IAoBoB,qCAChB,aADgB,EACD,qBADC,EACsB,eADtB,uCACuC,sC;;KADvC,YACuC,gBADvC,IACwE,gBADxE,C;G;kEAIpB,yE;IAsBoB,6CAChB,aADgB,EACD,qBADC,EACsB,KAAM,gBAD5B,EAC6C,gBAD7C,C;G;kEAIpB,mF;IAqBoB,qCAChB,aADgB,EACD,qBADC,EACsB,eADtB,+CACuC,sC;;KADvC,YACuC,gBADvC,IACgF,gBADhF,C;G;;;;;;;;+DCjTpB,iE;IAuBqB,4BAAQ,qBAAR,EAA+B,YAA/B,uCAA6C,sC;;KAA7C,YAA6C,gBAA7C,IAA8E,gBAA9E,C;G;uEAErB,iE;IAuBqB,4BACjB,qBADiB,EACM,YADN,+CACoB,sC;;KADpB,YACoB,gBADpB,IAC6D,gBAD7D,C;G;;;;;;EA2C4E,8D;IACjG,gF;EACJ,C;;EATA,2D;W3BzD4F,iD;G;;;;;;;;E2BoFG,2D;IAC3F,6E;EACJ,C;;EATA,wD;W3B7E4F,8C;G;;;;;;;;;I4BhBxF,wC;;EAAA,sC;IAAA,0C;IACI,eAGiC,2B;G;;;;;;;EAJrC,kD;IAAA,iD;MAAA,gC;;IAAA,0C;G;;;oEAYI,mC;IAKI,4BAAQ,gBAAY,yBAAyB,gBAAO,UAAP,EAAmB,WAAnB,CAA7C,C;G;iEAEJ,iC;IAII,oCAAgB,oBAAe,qBAAf,CAAhB,C;G;;;;;;;;iFAkBJ,2B;IAM0B,OAAA,oCAA+B,gBAAO,uBAAP,EAA2B,eAA3B,C;G;yFAEzD,2B;IAOI,OAAA,oCAA+B,wBAAe,uBAAf,EAAmC,eAAnC,C;G;;;;;;;;;;;;;;;;;;;;;;;;;;;EAmFA,2I;IACnC,gC;IACA,sD;IACA,kD;IACA,oC;IACA,0C;G;;;;;;0DAnBJ,Y;IAeI,wB;G;0DAfJ,Y;IAgBI,mC;G;0DAhBJ,Y;IAiBI,iC;G;0DAjBJ,Y;IAkBI,0B;G;0DAlBJ,Y;IAmBI,6B;G;4DAnBJ,2G;IAAA,4CAeI,0DAfJ,EAgBI,2FAhBJ,EAiBI,qFAjBJ,EAkBI,gEAlBJ,EAmBI,yEAnBJ,C;G;wDAAA,Y;IAAA,OAeI,oEAfJ,IAgBI,4EAhBJ,KAiBI,wEAjBJ,KAkBI,0DAlBJ,KAmBI,gEAnBJ,O;G;wDAAA,Y;IAAA,c;IAeI,6D;IACA,wE;IACA,sE;IACA,+D;IACA,kE;IAnBJ,a;G;sDAAA,iB;IAAA,4IAeI,oDAfJ,IAgBI,0EAhBJ,IAiBI,sEAjBJ,IAkBI,wDAlBJ,IAmBI,8DAnBJ,I;G;;;;;;ECzIuC,iD;IAAE,mE;EAAyD,C;;EANtG,8C;W7BkC4F,oC;G;;;;;;;;E8BpC5F,iC;G;4DAEI,wB;IACI,qCAA0B,YAA1B,C;G;;;;;;EAIgC,uD;IACpC,sD;G;;SAAA,Y;MAAA,wC;K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECLuB,mC;IAAE,qD;EAAyC,C;;EALtE,gC;W/BsC4F,sB;G;;;;;;;;EgC1BrD,6C;IAAE,+D;EAAqD,C;;EAL9F,0C;WhC+B4F,gC;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gEiC/BxF,uB;IAI8D,kB;G;;;;;;;;;;;;;ECN/B,2C;IAAE,6D;EAAiD,C;;EALtF,wC;WlCsC4F,8B;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EmC9BtD,4C;IAAE,8D;EAAoD,C;;EAL5F,yC;WnCmC4F,+B;G;;;;;;;;EoC9B1C,wD;IAAE,0E;EAAgE,C;;EAPpH,qD;WpCqC4F,2C;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sBD3BnE,KAAK,wBAAL,C;kBEAJ,KAAK,oBAAL,C;2BCDS,KAAK,6BAAL,C;yBCAF,KAAK,2BAAL,C;yBCJA,KAAK,2BAAL,C;sBCGH,KAAK,wBAAL,C;4BCHM,KAAK,8BAAL,C;uBCML,KAAK,yBAAL,C;mBCHJ,KAAK,qBAAL,C;kBCDD,KAAK,oBAAL,C;uBCEK,KAAK,yBAAL,C;yBCGE,KAAK,2BAAL,C;mBCJN,KAAK,qBAAL,C;wBCDK,KAAK,0BAAL,C;oCEKY,KAAK,sCAAL,C;0BCDV,KAAK,4BAAL,C;qBGAL,KAAK,uBAAL,C;mBECF,KAAK,qBAAL,C;mBCRA,KAAK,qBAAL,C;mCCIgB,KAAK,qCAAL,C;2BEJR,KAAK,6BAAL,C;uBCUgB,KAAK,yBAAL,C;gDCuFkD,KAAK,kDAAL,C;6CAoBN,KAAK,+CAAL,C;mCEhHpD,KAAK,qCAAL,C;qBELhB,KAAK,uBAAL,C;+BCOY,KAAK,iCAAL,C;6BEPJ,KAAK,+BAAL,C;8BCGG,KAAK,gCAAL,C;0CCAY,KAAK,4CAAL,C;;;;"}