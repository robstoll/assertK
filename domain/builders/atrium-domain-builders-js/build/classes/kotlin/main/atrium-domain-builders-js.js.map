{"version":3,"file":"atrium-domain-builders-js.js","sources":["../../../../../atrium-core-api-common/src/main/kotlin/ch/tutteli/atrium/core/Option.kt","kotlin/collections.kt","util/Preconditions.kt","collections/Collections.kt","../../../../../kbox-common/src/main/kotlin/ch/tutteli/kbox/varargToList.kt","../../../../src/main/kotlin/ch/tutteli/atrium/core/polyfills/loadServices.kt","util/Standard.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/AssertImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/ExpectImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/CollectionAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ComparableAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/FeatureAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ListAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapEntryAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/NewFeatureAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/PairAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/PleaseUseReplacementException.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/anyAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/basic/contains/CheckOptionExtension.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/changers/FeatureExtractorBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/changers/SubjectChangerBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/changers/impl/featureextractor/defaultImpls.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/changers/impl/subjectchanger/DefaultFailureHandlerImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/changers/impl/subjectchanger/defaultImpls.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charSequenceAssertionsBuilders.kt","generated/_Collections.kt","text/regex/RegexExtensions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charsequence/contains/builders/AtLeastCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charsequence/contains/builders/AtMostCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charsequence/contains/builders/ButAtMostCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charsequence/contains/builders/ExactlyCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charsequence/contains/builders/NotCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charsequence/contains/builders/NotOrAtMostCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/collectors/AssertionCollectorBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/collectors/AssertionOptionExplantoryExtensions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterable/contains/builders/AtLeastCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterable/contains/builders/AtMostCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterable/contains/builders/ButAtMostCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterable/contains/builders/ExactlyCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterable/contains/builders/NotCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterable/contains/builders/NotOrAtMostCheckerOptionBase.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterableAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/throwableAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/migration/assertToExpect.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/AssertionFormatterControllerOption.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/AssertionFormatterFacadeOption.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/AssertionPairFormatterOption.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/AtriumErrorAdjusterOption.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/ExpectBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/LocaleOrderDeciderOption.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/ObjectFormatterOption.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/ReporterBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/ReporterBuilderFinalStep.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/ReporterOption.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/AssertionFormatterControllerOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/AssertionFormatterFacadeOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/AssertionPairFormatterOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/AtriumErrorAdjusterOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/DefaultReporterFactory.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/LocaleOrderDeciderOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/MultipleAdjustersOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/ObjectFormatterOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/ReporterBuilderFinalStepImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/ReporterOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/TextAssertionFormatterOptionImpl.kt","../../../../../kbox-common/src/main/kotlin/ch/tutteli/kbox/forElementAndForEach.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/TranslatorOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/verb/OptionsChooserImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/verb/defaultImpls.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/utils/VarArgHelper.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/utils/containsValidators.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/utils/groupsToList.kt","generated/_Arrays.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/utils/mapArguments.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/utils/nullable.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/utils/subAssert.kt","../../../../src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/FloatingPointAssertionsBuilder.kt","../../../../src/main/kotlin/ch/tutteli/atrium/domain/builders/registerServices.kt","../../../../src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/ReporterBuilder.kt","../../../../src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/TextAssertionFormatterOption.kt","../../../../src/main/kotlin/ch/tutteli/atrium/domain/builders/reporting/impl/ReporterBuilderImpl.kt"],"sourcesContent":["package ch.tutteli.atrium.core\n\n/**\n * Represents an optional value with [map], [flatMap], [fold] and [getOrElse] to transform it.\n */\nsealed class Option<out T> {\n\n    fun isDefined() = this is Some\n\n    inline fun filter(predicate: (T) -> Boolean): Option<T> = flatMap { if (predicate(it)) Some(it) else None }\n\n    inline fun <R> map(f: (T) -> R): Option<R> = flatMap { Some(f(it)) }\n\n    inline fun <R> flatMap(f: (T) -> Option<R>): Option<R> = fold({ None }, f)\n\n    inline fun <R> fold(default: () -> R, f: (T) -> R): R = when (this) {\n        is Some -> f(value)\n        None -> default()\n    }\n\n    companion object {\n        inline fun <T> someIf(predicate: Boolean, provider: () -> T): Option<T> =\n            if (predicate) Some(provider()) else None\n    }\n}\n\ninline fun <T> Option<T>.getOrElse(default: () -> T): T = fold(default) { it }\n\ndata class Some<T>(val value: T) : Option<T>()\nobject None : Option<Nothing>()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/** Returns the array if it's not `null`, or an empty array otherwise. */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package ch.tutteli.kbox\n\n/**\n * Adds the given [arg] and the [otherArgs] into a new [List] and returns it.\n *\n * This function is intended for API functions which expect `x: T, vararg otherX: T` and want to pass the arguments\n * to another function which expects only one argument of `List<T>`.\n *\n * @return a [List] containing [arg] and [otherArgs].\n */\nfun <T> varargToList(arg: T, otherArgs: Array<out T>): List<T> {\n    val list = ArrayList<T>(otherArgs.size + 1)\n    list.add(arg)\n    list.addAll(otherArgs)\n    return list\n}\n\n/**\n * Delegates to [varargToList] -- adds `this` and the [otherArgs] into a new [List] and returns it.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\ninline infix fun <T> T.glue(otherArgs: Array<out T>): List<T> = varargToList(this, otherArgs)\n","package ch.tutteli.atrium.core.polyfills\n\nimport kotlin.reflect.KClass\n\nprivate val serviceRegistry = mutableMapOf<KClass<*>, HashSet<Any>>()\n\nactual fun <T : Any> loadSingleService(kClass: KClass<T>): T =\n    useSingleService(kClass, loadServices(kClass).iterator())\n\n\nactual fun <T : Any> loadServices(kClass: KClass<T>): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\" /* we have a homogeneous map but make sure insertions are type safe, thus OK */)\n    val set = serviceRegistry[kClass] as Set<() -> T>?\n    return set?.asSequence()?.map { it() } ?: emptySequence()\n}\n\n/**\n * Registers the given [service] for the service of type [T].\n */\ninline fun <reified T : Any> registerService(noinline service: () -> T) = registerService(T::class, service)\n\n/**\n * Registers the given [service] for the given [serviceInterface].\n */\nfun <T : Any> registerService(serviceInterface: KClass<T>, service: () -> T) {\n    val services = serviceRegistry.getOrPut(serviceInterface) { hashSetOf() }\n    services.add(service)\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.BaseAssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.subjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give users of Atrium a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\")\nobject AssertImpl : AssertImplCommon {\n\n    override inline val builder get() = assertionBuilder\n\n    override inline val collector get() = AssertionCollectorBuilder\n\n    override inline val coreFactory get() = ch.tutteli.atrium.core.coreFactory\n\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    override inline val any get() = AnyAssertionsBuilder\n\n    override inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    override inline val collection get() = CollectionAssertionsBuilder\n\n    override inline val comparable get() = ComparableAssertionsBuilder\n\n    @Suppress(\"DEPRECATION\")\n    override inline val feature get() = FeatureAssertionsBuilder\n\n    override inline val floatingPoint get() = FloatingPointAssertionsBuilder\n\n    override inline val iterable get() = IterableAssertionsBuilder\n\n    override inline val list get() = ListAssertionsBuilder\n\n    override inline val map get() = MapAssertionsBuilder\n\n    override inline val pair get() = PairAssertionsBuilder\n\n    override inline val throwable get() = ThrowableAssertionsBuilder\n}\n\ninterface AssertImplCommon {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    val builder: AssertionBuilder\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    val collector: AssertionCollectorBuilder\n\n    /**\n     * Returns the implementation of [CoreFactory].\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.core.coreFactory]\n     * which in turn delegates to the implementation via [loadSingleService].\n     */\n    val coreFactory: CoreFactory\n\n    /**\n     * Creates a new [AssertionPlant] based on the given [subjectProvider] whereas the [AssertionPlant] delegates\n     * assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlant] but merely want to make feature assertions so that\n     * you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlant<R> = subjectChanger.unreportedToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = subjectChanger.unreported(originalAssertionCreator, transformation)\n\n    /**\n     * Creates a new [AssertionPlantNullable] based on the given [subjectProvider] whereas the [AssertionPlant]\n     * delegates assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlantNullable] but merely want to make feature\n     * assertions so that you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R> changeToNullableSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlantNullable<R> = subjectChanger.unreportedNullableToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeToNullableSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = changeSubject(originalAssertionCreator, transformation)\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    val any: AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    val charSequence: CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    val collection: CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    val comparable: ComparableAssertionsBuilder\n\n    /**\n     * Returns [FeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    @Suppress(\"DEPRECATION\")\n    val feature: FeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    val floatingPoint: FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    val iterable: IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    val list: ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    val map: MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    val pair: PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    val throwable: ThrowableAssertionsBuilder\n}\n","package ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.changers.SubjectChangerBuilder\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.SubjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give assertion writers (and other consumers of the domain) a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\nobject ExpectImpl {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    inline val builder get() = assertionBuilder\n\n    /**\n     * Returns [SubjectChangerBuilder] - helping you to change the subject of the assertion.\n     * In detail, its an `inline` property which returns [SubjectChangerBuilder]\n     * which inter alia delegates to the implementation of [SubjectChanger].\n     *\n     * In case you want to extract a feature (e.g. get the first element of a `List`) instead of changing the subject\n     * into another representation (e.g. down-cast `Person` to `Student`) then you should use\n     * [feature.extractor][NewFeatureAssertionsBuilder.extractor] instead.\n     */\n    inline fun <T> changeSubject(originalAssertionContainer: Expect<T>) =\n        SubjectChangerBuilder.create(originalAssertionContainer)\n\n    @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    inline fun <T> changeSubject(originalAssertionContainer: SubjectProvider<T>) =\n        SubjectChangerBuilder.create(originalAssertionContainer)\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * In detail, its an `inline` property which returns [AssertionCollectorBuilder]\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    inline val collector get() = AssertionCollectorBuilder\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    inline val any get() = AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    inline val collection get() = CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    inline val comparable get() = ComparableAssertionsBuilder\n\n    /**\n     * Returns [NewFeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    inline val feature get() = NewFeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    inline val floatingPoint get() = FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    inline val iterable get() = IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    val list get() = ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    inline val map get() = MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    inline val pair get() = PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    inline val throwable get() = ThrowableAssertionsBuilder\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CollectionAssertions\nimport ch.tutteli.atrium.domain.creating.collectionAssertions\n\n/**\n * Delegates inter alia to the implementation of [CollectionAssertions].\n * In detail, it implements [CollectionAssertions] by delegating to [collectionAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CollectionAssertionsBuilder : CollectionAssertions {\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Collection<*>> size(assertionContainer: Expect<T>) =\n        collectionAssertions.size(assertionContainer)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Collection<*>>, size: Int) =\n        collectionAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun size(plant: AssertionPlant<Collection<*>>, noinline assertionCreator: Assert<Int>.() -> Unit) =\n        collectionAssertions.size(plant, assertionCreator)\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.ComparableAssertions\nimport ch.tutteli.atrium.domain.creating.comparableAssertions\n\n/**\n * Delegates inter alia to the implementation of [ComparableAssertions].\n * In detail, it implements [ComparableAssertions] by delegating to [comparableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ComparableAssertionsBuilder : ComparableAssertions {\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessOrEquals(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterOrEquals(subjectProvider, expected)\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\", \"DEPRECATION\")\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.creating.FeatureAssertions\nimport ch.tutteli.atrium.domain.creating.feature.extract.FeatureExtractor\nimport ch.tutteli.atrium.domain.creating.featureAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\nimport kotlin.reflect.*\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [FeatureAssertions].\n * In detail, it implements [FeatureAssertions] by delegating to [featureAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use then ExpectImpl.feature, NewFeatureAssertionsBuilder respectively; will be removed with 1.0.0\")\nobject FeatureAssertionsBuilder : FeatureAssertions {\n\n    @Suppress(\"DEPRECATION\")\n    inline val extractor: FeatureExtractor.DescriptionOption get() = FeatureExtractor.builder\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>)\n        = property(plant, { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) }, Untranslatable(property.name))\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>)\n        = property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable): AssertionPlant<TProperty>\n        = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable): AssertionPlant<TProperty>\n        = featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit)\n        = property(plant, { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) },  Untranslatable(property.name), assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit)\n        = property(plant, property,  Untranslatable(property.name), assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit): AssertionPlant<TProperty>\n        = property(plant, subjectProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit): AssertionPlant<TProperty>\n        = property(plant, subjectProvider, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>): AssertionPlantNullable<TProperty> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\")  property.invoke(plant.subject) }\n        return property(plant, l, Untranslatable(property.name))\n    }\n\n    inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>)\n        = property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable): AssertionPlantNullable<TProperty>\n        = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable): AssertionPlantNullable<TProperty>\n        = featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    //Arg0\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>): AssertionPlant<R>\n        = returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>): AssertionPlant<R>\n        = returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\") method(plant.subject) }\n        return returnValueOf0(plant, l, l, method.name)\n    }\n\n    inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>): AssertionPlantNullable<R>\n        = returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    //Arg1\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1): AssertionPlant<R>\n        = returnValueOf1(plant, {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }, arg1, method.name)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }, arg1, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1) -> R = {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }\n        return returnValueOf1(plant, l, arg1, method.name)\n    }\n\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n        = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    //Arg2\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n        = returnValueOf2(plant, {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }, arg1, arg2, method.name)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }, arg1, arg2, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2) -> R = {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }\n        return returnValueOf2(plant, l, arg1, arg2, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    //Arg3\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n        = returnValueOf3(plant, {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }, arg1, arg2, arg3, method.name)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }, arg1, arg2, arg3, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2, T3) -> R = {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }\n        return returnValueOf3(plant, l, arg1, arg2, arg3, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    //Arg4\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n        = returnValueOf4(plant, {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }, arg1, arg2, arg3, arg4, method.name)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }, arg1, arg2, arg3, arg4, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2, T3, T4) -> R = {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }\n        return returnValueOf4(plant, l, arg1, arg2, arg3, arg4, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    //Arg5\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n        = returnValueOf5(plant, {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }, arg1, arg2, arg3, arg4, arg5, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1, T2, T3, T4, T5) -> R = {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }\n        return returnValueOf5(plant, l, arg1, arg2, arg3, arg4, arg5, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.ListAssertions\nimport ch.tutteli.atrium.domain.creating.listAssertions\n\n/**\n * Delegates inter alia to the implementation of [ListAssertions].\n * In detail, it implements [ListAssertions] by delegating to [listAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ListAssertionsBuilder : ListAssertions {\n\n    override inline fun <E, T : List<E>> get(\n        assertionContainer: Expect<T>,\n        index: Int\n    ) = listAssertions.get(assertionContainer, index)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T : Any> get(plant: AssertionPlant<List<T>>, index: Int): AssertionPlant<T> =\n        listAssertions.get(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T : Any> get(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = listAssertions.get(plant, index, assertionCreator)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T> getNullable(plant: AssertionPlant<List<T>>, index: Int): AssertionPlantNullable<T> =\n        listAssertions.getNullable(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T> getNullable(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlantNullable<T>.() -> Unit\n    ) = listAssertions.getNullable(plant, index, assertionCreator)\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.MapAssertions\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.mapAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapAssertions].\n * In detail, it implements [MapAssertions] by delegating to [mapAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject MapAssertionsBuilder : MapAssertions {\n\n    /**\n     * Returns [MapEntryAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapEntryAssertions].\n     */\n    inline val entry get() : MapEntryAssertionsBuilder = MapEntryAssertionsBuilder\n\n    override inline fun <K, V : Any, T : Map<out K, V?>> contains(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValuePairs: List<Pair<K, V?>>\n    ) = mapAssertions.contains(assertionContainer, valueType, keyValuePairs)\n\n    override inline fun <K, V : Any, T : Map<out K, V?>> containsKeyWithValueAssertions(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValues: List<Pair<K, (Expect<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(assertionContainer, valueType, keyValues)\n\n\n    override inline fun <K> containsKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsKey(subjectProvider, key)\n\n    override inline fun <K> containsNotKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsNotKey(subjectProvider, key)\n\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isEmpty(subjectProvider)\n\n    override inline fun <K, V, T : Map<out K, V>> getExisting(\n        assertionContainer: Expect<T>,\n        key: K\n    ): ExtractedFeaturePostStep<T, V> = mapAssertions.getExisting(assertionContainer, key)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Map<*, *>> size(assertionContainer: Expect<T>) = mapAssertions.size(assertionContainer)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> contains(\n        plant: AssertionPlant<Map<out K, V>>,\n        keyValuePairs: List<Pair<K, V>>\n    ) = mapAssertions.contains(plant, keyValuePairs)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> containsKeyWithValueAssertions(\n        plant: AssertionPlant<Map<out K, V?>>,\n        keyValues: List<Pair<K, (Assert<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(plant, keyValues)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExisting(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ) = mapAssertions.getExisting(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExistingNullable(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ) = mapAssertions.getExistingNullable(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Map<*, *>>, size: Int) = mapAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> keys(\n        plant: AssertionPlant<Map<out K, *>>,\n        noinline assertionCreator: AssertionPlant<Set<K>>.() -> Unit\n    ): Assertion = mapAssertions.keys(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> values(\n        plant: AssertionPlant<Map<*, V>>,\n        noinline assertionCreator: AssertionPlant<Collection<V>>.() -> Unit\n    ): Assertion = mapAssertions.values(plant, assertionCreator)\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.mapEntryAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapEntryAssertions].\n * In detail, it implements [MapEntryAssertions] by delegating to [mapEntryAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject MapEntryAssertionsBuilder : MapEntryAssertions {\n    override inline fun <K : Any, V : Any, T : Map.Entry<K, V>> isKeyValue(\n        assertionContainer: Expect<T>,\n        key: K,\n        value: V\n    ) = mapEntryAssertions.isKeyValue(assertionContainer, key, value)\n\n    override inline fun <K : Any, V : Any, T : Map.Entry<K?, V?>> isKeyValue(\n        assertionContainer: Expect<T>,\n        key: K?,\n        value: V?,\n        keyType: KClass<K>,\n        valueType: KClass<V>\n    ) = mapEntryAssertions.isKeyValue(assertionContainer, key, value, keyType, valueType)\n\n    override inline fun <K, T : Map.Entry<K, *>> key(assertionContainer: Expect<T>) =\n        mapEntryAssertions.key(assertionContainer)\n\n    override inline fun <V, T : Map.Entry<*, V>> value(assertionContainer: Expect<T>) =\n        mapEntryAssertions.value(assertionContainer)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any, V : Any> isKeyValue(\n        plant: AssertionPlant<Map.Entry<K, V>>,\n        key: K,\n        value: V\n    ): Assertion = mapEntryAssertions.isKeyValue(plant, key, value)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> key(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.key(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> value(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.value(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableKey(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableKey(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableValue(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableValue(plant, assertionCreator)\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.None\nimport ch.tutteli.atrium.core.Some\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\nimport ch.tutteli.atrium.domain.builders.creating.changers.FeatureExtractorBuilder\nimport ch.tutteli.atrium.domain.creating.MetaFeature\nimport ch.tutteli.atrium.domain.creating.NewFeatureAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.newFeatureAssertions\nimport ch.tutteli.atrium.reporting.MethodCallFormatter\nimport ch.tutteli.atrium.reporting.RawString\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\nimport ch.tutteli.atrium.translations.ErrorMessages\nimport kotlin.reflect.*\n\n\n/**\n * Delegates inter alia to the implementation of [NewFeatureAssertions].\n * In detail, it implements [NewFeatureAssertions] by delegating to [newFeatureAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n *\n * Will be renamed to FeatureAssertionsBuilder with 1.0.0\n */\nobject NewFeatureAssertionsBuilder : NewFeatureAssertions {\n\n    /**\n     *  Start a feature extraction with the help of the [FeatureExtractorBuilder].\n     *\n     * In case you do not want to extract a feature (e.g. get the first element of a `List`)\n     * but merely want to transform the subject into another representation\n     * (e.g. down-cast `Person` to `Student` or transform a `Sequence` into a `List`) then you should use\n     * [ExpectImpl.changeSubject] instead.\n     *\n     * Also, if the extraction of the feature is always safe, then you can just use one of the fN functions\n     * (e.g. [f1] for a function expecting 1 argument) or [property].\n     */\n    inline fun <T> extractor(originalAssertionContainer: Expect<T>) =\n        FeatureExtractorBuilder.create(originalAssertionContainer)\n\n\n    //@formatter:off\n   fun <T, TProperty> property(assertionContainer: Expect<T>, property: KProperty1<in T, TProperty>): ExtractedFeaturePostStep<T, TProperty> =\n        extractFeature(assertionContainer, property.name, property::get)\n\n    fun <T, R> f0(assertionContainer: Expect<T>, f: KFunction1<T, R>): ExtractedFeaturePostStep<T, R> =\n        extractFeature(assertionContainer, coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf()), f::invoke)\n\n    fun <T, A1, R> f1(assertionContainer: Expect<T>, f: KFunction2<T, A1, R>, a1: A1): ExtractedFeaturePostStep<T, R> =\n        extractFeature(assertionContainer, coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf<Any?>(a1))) { f(it, a1) }\n\n    fun <T, A1, A2, R> f2(assertionContainer: Expect<T>, f: KFunction3<T, A1, A2, R>, a1: A1, a2: A2): ExtractedFeaturePostStep<T, R> =\n        extractFeature(assertionContainer ,coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf(a1, a2))) { f(it, a1, a2) }\n\n    fun <T, A1, A2, A3, R> f3(assertionContainer: Expect<T>, f: KFunction4<T, A1, A2, A3, R>, a1: A1, a2: A2, a3: A3): ExtractedFeaturePostStep<T, R> =\n        extractFeature(assertionContainer, coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf(a1, a2, a3))) { f(it, a1, a2, a3) }\n\n    fun <T, A1, A2, A3, A4, R> f4(assertionContainer: Expect<T>, f: KFunction5<T, A1, A2, A3, A4, R>, a1: A1, a2: A2, a3: A3, a4: A4): ExtractedFeaturePostStep<T, R> =\n        extractFeature(assertionContainer, coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf(a1, a2, a3, a4))) { f(it, a1, a2, a3, a4) }\n\n    fun <T, A1, A2, A3, A4, A5, R> f5(assertionContainer: Expect<T>, f: KFunction6<T, A1, A2, A3, A4, A5, R>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): ExtractedFeaturePostStep<T, R> =\n        extractFeature(assertionContainer, coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf(a1, a2, a3, a4, a5))) { f(it, a1, a2, a3, a4, a5) }\n    //@formatter:on\n\n    fun <T, R> manualFeature(\n        assertionContainer: Expect<T>,\n        name: String,\n        provider: T.() -> R\n    ): ExtractedFeaturePostStep<T, R> = extractFeature(assertionContainer, name, provider)\n\n    fun <T, R> manualFeature(\n        assertionContainer: Expect<T>,\n        name: Translatable,\n        provider: T.() -> R\n    ): ExtractedFeaturePostStep<T, R> =\n        genericFeature(assertionContainer, createMetaFeature(assertionContainer, name, provider))\n\n    fun <T, R> genericSubjectBasedFeature(\n        assertionContainer: Expect<T>,\n        provider: (T) -> MetaFeature<R>\n    ): ExtractedFeaturePostStep<T, R> = ExpectImpl.feature.genericFeature(\n        assertionContainer,\n        assertionContainer.maybeSubject.fold(this::createFeatureSubjectNotDefined) { provider(it) }\n    )\n\n    private fun <R> createFeatureSubjectNotDefined(): MetaFeature<R> =\n        MetaFeature(\n            ErrorMessages.DEDSCRIPTION_BASED_ON_SUBJECT,\n            RawString.create(ErrorMessages.REPRESENTATION_BASED_ON_SUBJECT_NOT_DEFINED),\n            None\n        )\n\n    override inline fun <T, R> genericFeature(\n        assertionContainer: Expect<T>,\n        metaFeature: MetaFeature<R>\n    ): ExtractedFeaturePostStep<T, R> = newFeatureAssertions.genericFeature(assertionContainer, metaFeature)\n\n    private fun <T, R> extractFeature(\n        assertionContainer: Expect<T>,\n        name: String,\n        provider: (T) -> R\n    ): ExtractedFeaturePostStep<T, R> =\n        genericFeature(assertionContainer, createMetaFeature(assertionContainer, name, provider))\n\n    private fun <T, R> createMetaFeature(\n        assertionContainer: Expect<T>,\n        name: String,\n        provider: (T) -> R\n    ): MetaFeature<R> = createMetaFeature(assertionContainer, Untranslatable(name), provider)\n\n    private fun <T, R> createMetaFeature(\n        assertionContainer: Expect<T>,\n        name: Translatable,\n        provider: (T) -> R\n    ): MetaFeature<R> {\n        return assertionContainer.maybeSubject.fold({\n            MetaFeature(\n                name,\n                RawString.create(ErrorMessages.REPRESENTATION_BASED_ON_SUBJECT_NOT_DEFINED),\n                None\n            )\n        }) {\n            val prop = provider(it)\n            MetaFeature(name, prop, Some(prop))\n        }\n    }\n\n    /**\n     * Returns [MetaFeatureBuilder] which helps to create a [MetaFeature].\n     */\n    inline val meta get() = MetaFeatureBuilder\n}\n\n/**\n * Helper class to circumvent overload bugs and KFunction bugs incorporated in Kotlin -- use [f] and in case you run\n * into an overload ambiguity, then either [p] (for property) or one of the `fN` functions (e.g. [f2] for\n * a function which expects 2 arguments).\n */\nclass MetaFeatureOption<T>(private val expect: Expect<T>) {\n\n    /**\n     * Creates a [MetaFeature] for the given [property] => use [p] in case of ambiguity issues.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(List<Int>::size)`).\n     * This way we are always able to report the property, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <R> f(property: KProperty0<R>): MetaFeature<R> = p(property)\n\n    //@formatter:off\n    /**\n     * Creates a [MetaFeature] for the given function [f] without arguments => use [f0] in case of ambiguity issues.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <R> f(f: KFunction0<R>): MetaFeature<R> =\n        f0(f)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 1 argument => use [f1] in case of ambiguity issues.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, R> f(f: KFunction1<A1, R>, a1: A1): MetaFeature<R> =\n        f1(f, a1)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 2 arguments => use [f2] in case of ambiguity issues.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, A2, R> f(f: KFunction2<A1, A2, R>, a1: A1, a2: A2): MetaFeature<R> =\n        f2(f, a1, a2)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 3 arguments => use [f3] in case of ambiguity issues.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, A2, A3, R> f(f: KFunction3<A1, A2, A3, R>, a1: A1, a2: A2, a3: A3): MetaFeature<R> =\n        f3(f, a1, a2, a3)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 4 arguments => use [f4] in case of ambiguity issues.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, A2, A3, A4, R> f(f: KFunction4<A1, A2, A3, A4, R>, a1: A1, a2: A2, a3: A3, a4: A4): MetaFeature<R> =\n        f4(f, a1, a2, a3, a4)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 5 arguments => use [f5] in case of ambiguity issues.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, A2, A3, A4, A5, R> f(f: KFunction5<A1, A2, A3, A4, A5, R>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): MetaFeature<R> =\n        f5(f, a1, a2, a3, a4, a5)\n\n    //used to distinguish property/functions\n\n    /**\n     * Creates a [MetaFeature] for the given property [property].\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(List<Int>::size)`).\n     * This way we are always able to report the property, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <R> p(property: KProperty0<R>): MetaFeature<R> =\n        ExpectImpl.feature.meta.property(property)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] without arguments.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <R> f0(f: KFunction0<R>): MetaFeature<R> =\n        ExpectImpl.feature.meta.f0(expect, f)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 1 argument.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, R> f1(f: KFunction1<A1, R>, a1: A1): MetaFeature<R> =\n        ExpectImpl.feature.meta.f1(expect, f, a1)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 2 arguments.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, A2, R> f2(f: KFunction2<A1, A2, R>, a1: A1, a2: A2): MetaFeature<R> =\n        ExpectImpl.feature.meta.f2(expect, f, a1, a2)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 3 arguments.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, A2, A3, R> f3(f: KFunction3<A1, A2, A3, R>, a1: A1, a2: A2, a3: A3): MetaFeature<R> =\n        ExpectImpl.feature.meta.f3(expect, f, a1, a2, a3)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 4 arguments.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, A2, A3, A4, R> f4(f: KFunction4<A1, A2, A3, A4, R>, a1: A1, a2: A2, a3: A3, a4: A4): MetaFeature<R> =\n        ExpectImpl.feature.meta.f4(expect, f, a1, a2, a3, a4)\n\n    /**\n     * Creates a [MetaFeature] for the given function [f] which expects 5 arguments.\n     *\n     * Notice for assertion function writers: you should use [ExpectImpl].[feature][ExpectImpl.feature] and pass a\n     * class reference instead of using this convenience function (e.g. `ExpectImpl.feature(MyClass::fun, ...)`).\n     * This way we are always able to report the function name, even if the subject is not defined which occurs if a\n     * previous transformation of the subject could not be carried out.\n     */\n    fun <A1, A2, A3, A4, A5, R> f5(f: KFunction5<A1, A2, A3, A4, A5, R>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): MetaFeature<R> =\n        ExpectImpl.feature.meta.f5(expect, f, a1, a2, a3, a4, a5)\n\n    //@formatter:on\n}\n\n/**\n * Builder which helps to create [MetaFeature] inter alia by using the [MethodCallFormatter] defined initially by the\n * [Reporter]\n */\n@Suppress(\"UNUSED_PARAMETER\" /* we will need it as soon as methodCallFormatter is taken from the specified Reporter */)\nobject MetaFeatureBuilder {\n\n    fun <TProperty> property(property: KProperty0<TProperty>) = MetaFeature(property.name, property.invoke())\n\n    //@formatter:off\n    fun <R> f0(assertionContainer: Expect<*>, f: KFunction0<R>) =\n        MetaFeature(coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf()), f.invoke())\n\n    fun <A1, R> f1(assertionContainer: Expect<*>, f: KFunction1<A1, R>, a1: A1) =\n        MetaFeature(coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf<Any?>(a1)), f.invoke(a1))\n\n    fun <A1, A2, R> f2(assertionContainer: Expect<*>, f: KFunction2<A1, A2, R>, a1: A1, a2: A2) =\n        MetaFeature(coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf(a1, a2)), f.invoke(a1, a2))\n\n    fun <A1, A2, A3, R> f3(assertionContainer: Expect<*>, f: KFunction3<A1, A2, A3, R>, a1: A1, a2: A2, a3: A3) =\n        MetaFeature(coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf(a1, a2, a3)), f.invoke(a1, a2, a3))\n\n    fun <A1, A2, A3, A4, R> f4(assertionContainer: Expect<*>, f: KFunction4<A1, A2, A3, A4, R>, a1: A1, a2: A2, a3: A3, a4: A4) =\n        MetaFeature(coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf(a1, a2, a3, a4)), f.invoke(a1, a2, a3, a4))\n\n    fun <A1, A2, A3, A4, A5, R> f5(assertionContainer: Expect<*>, f: KFunction5<A1, A2, A3, A4, A5, R>, a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) =\n        MetaFeature(coreFactory.newMethodCallFormatter().formatCall(f.name, arrayOf(a1, a2, a3, a4, a5)), f.invoke(a1, a2, a3, a4, a5))\n    //@formatter:on\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.PairAssertions\nimport ch.tutteli.atrium.domain.creating.pairAssertions\n\n/**\n * Delegates inter alia to the implementation of [PairAssertions].\n * In detail, it implements [PairAssertions] by delegating to [pairAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject PairAssertionsBuilder : PairAssertions {\n\n    override inline fun <K, T : Pair<K, *>> first(assertionContainer: Expect<T>) =\n        pairAssertions.first(assertionContainer)\n\n    override inline fun <V, T : Pair<*, V>> second(assertionContainer: Expect<T>) =\n        pairAssertions.second(assertionContainer)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> first(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = pairAssertions.first(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> second(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = pairAssertions.second(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableFirst(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = pairAssertions.nullableFirst(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableSecond(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = pairAssertions.nullableSecond(plant, assertionCreator)\n}\n","package ch.tutteli.atrium.domain.builders.creating\n\n/**\n * Indicates a problem which was indicated by a `@Deprecated` annotation but was ignored by you ;-)\n */\nclass PleaseUseReplacementException(reason: String) : Exception(reason)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\", \"DEPRECATION\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.AnyAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.AnyTypeTransformation\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.AnyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.anyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.FailureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.failureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.anyAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [AnyAssertions].\n * In detail, it implements [AnyAssertions] by delegating to [anyAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject AnyAssertionsBuilder : AnyAssertions {\n\n    override inline fun <T : Any> toBe(subjectProvider: SubjectProvider<T>, expected: T): Assertion =\n        anyAssertions.toBe(subjectProvider, expected)\n\n    override inline fun <T> notToBe(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.notToBe(subjectProvider, expected)\n\n    override inline fun <T> isSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isSame(subjectProvider, expected)\n\n    override inline fun <T> isNotSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isNotSame(subjectProvider, expected)\n\n    override inline fun <T> toBeNull(subjectProvider: SubjectProvider<T>) =\n        anyAssertions.toBeNull(subjectProvider)\n\n    override inline fun <T : Any> toBeNullable(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        expectedOrNull: T?\n    ) = anyAssertions.toBeNullable(assertionContainer, type, expectedOrNull)\n\n    override inline fun <T : Any> toBeNullIfNullGivenElse(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (Expect<T>.() -> Unit)?\n    ) = anyAssertions.toBeNullIfNullGivenElse(assertionContainer, type, assertionCreatorOrNull)\n\n    override inline fun <T, TSub : Any> isA(assertionContainer: Expect<T>, subType: KClass<TSub>) =\n        anyAssertions.isA(assertionContainer, subType)\n\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullable(plant: AssertionPlantNullable<T?>, type: KClass<T>, expectedOrNull: T?) =\n        anyAssertions.isNullable(plant, type, expectedOrNull)\n\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyAssertions.isNotNull(plant, type, assertionCreator)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNullBut(plant: AssertionPlantNullable<T?>, type: KClass<T>, expected: T) =\n        anyAssertions.isNotNullBut(plant, type, expected)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullIfNullGivenElse(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (AssertionPlant<T>.() -> Unit)?\n    ) = anyAssertions.isNullIfNullGivenElse(plant, type, assertionCreatorOrNull)\n\n\n    /**\n     * Returns [AnyTypeTransformationAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyTypeTransformationAssertions].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from `Assert` to `Expect` use `ExpectImpl.changeSubject` or `ExpectImpl.feature.extract` instead; will be removed with 1.0.0\")\n    inline val typeTransformation\n        get() = AnyTypeTransformationAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [AnyTypeTransformationAssertions].\n * In detail, it implements [AnyTypeTransformationAssertions] by delegating to [anyTypeTransformationAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationAssertionsBuilder : AnyTypeTransformationAssertions {\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\n        \"This function will be removed in v.1.0.0 in favour of AssertImpl.any.isNotNull\", ReplaceWith(\n            \"plant.addAssertion(AssertImpl.any.isNotNull(plant, type, assertionCreator))\",\n            \"ch.tutteli.atrium.domain.builders.AssertImpl\"\n        )\n    )\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyTypeTransformationAssertions.isNotNull(plant, type, assertionCreator)\n\n    override inline fun <TSub : Any> isA(\n        plant: AssertionPlant<Any>,\n        subType: KClass<TSub>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit\n    ) = anyTypeTransformationAssertions.isA(plant, subType, assertionCreator)\n\n    override inline fun <T : Any, TSub : T> downCast(\n        description: Translatable,\n        subType: KClass<TSub>,\n        subjectPlant: BaseAssertionPlant<T?, *>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit,\n        failureHandler: AnyTypeTransformation.FailureHandler<T, TSub>\n    ) = anyTypeTransformationAssertions.downCast(description, subType, subjectPlant, assertionCreator, failureHandler)\n\n    override inline fun <S : Any, T : Any> transform(\n        parameterObject: AnyTypeTransformation.ParameterObject<S, T>,\n        noinline canBeTransformed: (S) -> Boolean,\n        noinline transform: (S) -> T,\n        failureHandler: AnyTypeTransformation.FailureHandler<S, T>\n    ) = anyTypeTransformationAssertions.transform(parameterObject, canBeTransformed, transform, failureHandler)\n\n    /**\n     * Returns [AnyTypeTransformationFailureHandlerFactoryBuilder]\n     * which inter alia delegates to the implementation of [FailureHandlerFactory].\n     */\n    inline val failureHandlers get() = AnyTypeTransformationFailureHandlerFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [FailureHandlerFactory].\n * In detail, it implements [FailureHandlerFactory] by delegating to [failureHandlerFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationFailureHandlerFactoryBuilder : FailureHandlerFactory {\n\n    override inline fun <S : Any, T : Any> newExplanatory() = failureHandlerFactory.newExplanatory<S, T>()\n\n    override inline fun <S : Any, T : Any> newExplanatoryWithHint(\n        noinline showHint: () -> Boolean,\n        noinline failureHintFactory: () -> Assertion\n    ) = failureHandlerFactory.newExplanatoryWithHint<S, T>(showHint, failureHintFactory)\n}\n","package ch.tutteli.atrium.domain.builders.creating.basic.contains\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.migration.asAssert\nimport ch.tutteli.atrium.domain.builders.migration.asExpect\nimport ch.tutteli.atrium.domain.creating.basic.contains.Contains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\n\n\n/**\n * Helper method which simplifies adding assertions to the assertion container which itself is stored in\n * [Contains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nfun <T : Any, B : Contains.Builder<T, *>> Contains.CheckerOption<T, *, *, B>.addAssertion(\n    assertion: Assertion\n): Expect<T> = addAssertion(containsBuilder.subjectProvider, assertion)\n\n\n/**\n * Helper method which simplifies adding assertions to the assertion container which itself is stored in\n * [Contains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nfun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.Builder<E, T, S>.addAssertion(\n    assertion: Assertion\n): Expect<T> = addAssertion(subjectProvider, assertion)\n\n@Suppress(\"DEPRECATION\")\nprivate fun <T : Any> addAssertion(\n    subjectProvider: SubjectProvider<T>,\n    assertion: Assertion\n): Expect<T> =\n    //TODO simplify with 1.0.0\n    when (subjectProvider) {\n        is Expect<T> -> subjectProvider.addAssertion(assertion)\n        is Assert<T> -> subjectProvider.asExpect().addAssertion(assertion)\n        else -> throw IllegalStateException(\"neither Expect nor Assert\")\n    }\n\n\n/**\n * Helper method which simplifies adding assertions to the assertion container which itself is stored in\n * [Contains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nfun <T : Any, B : Contains.Builder<T, *>> Contains.CheckerOption<T, *, *, B>.addAssertionForAssert(\n    assertion: Assertion\n): Assert<T> = addAssertionForAssert(containsBuilder.subjectProvider, assertion)\n\n\n/**\n * Helper method which simplifies adding assertions to the assertion container which itself is stored in\n * [Contains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nfun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.Builder<E, T, S>.addAssertionForAssert(\n    assertion: Assertion\n): Assert<T> = addAssertionForAssert(subjectProvider, assertion)\n\n@Suppress(\"DEPRECATION\")\nprivate fun <T : Any> addAssertionForAssert(\n    subjectProvider: SubjectProvider<T>,\n    assertion: Assertion\n): Assert<T> =\n    //TODO simplify with 1.0.0\n    when (subjectProvider) {\n        is Expect<T> -> subjectProvider.asAssert().addAssertion(assertion)\n        is Assert<T> -> subjectProvider.addAssertion(assertion)\n        else -> throw IllegalStateException(\"neither Expect nor Assert\")\n    }\n","package ch.tutteli.atrium.domain.builders.creating.changers\n\nimport ch.tutteli.atrium.core.*\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.creating.changers.impl.featureextractor.*\nimport ch.tutteli.atrium.domain.creating.NewFeatureAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.reporting.LazyRepresentation\nimport ch.tutteli.atrium.reporting.RawString\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\n\n/**\n * Defines the contract for sophisticated `safe feature extractions` including assertion creation for the feature.\n *\n * It is similar to [NewFeatureAssertions] but differs in the intended usage.\n * [NewFeatureAssertions] are intended to make assertions about a return value of a method call or a property,\n * assuming that the call as such always succeeds (no exception is thrown).\n * The [FeatureExtractorBuilder] on the other hand should be used if it is already known,\n * that the call/access fails depending on given arguments.\n * For instance, [List.get] is a good example where it fails if the given index is out of bounds.\n */\ninterface FeatureExtractorBuilder {\n\n    companion object {\n        /**\n         * Entry point to use the [FeatureExtractorBuilder].\n         */\n        fun <T> create(originalAssertionContainer: Expect<T>): DescriptionStep<T> =\n            DescriptionStep.create(originalAssertionContainer)\n    }\n\n    /**\n     * Step which allows to specify the description which will be used to describe the feature.\n     *\n     * @param T the type of the current subject.\n     */\n    interface DescriptionStep<T> {\n        /**\n         * The previously specified assertion container from which we are going to extract the feature.\n         */\n        val originalAssertionContainer: Expect<T>\n\n        /**\n         * Uses [coreFactory].[newMethodCallFormatter][CoreFactory.newMethodCallFormatter] to create a description\n         * of a method call with the given [methodName] and the given [arguments].\n         *\n         * Use [withDescription] in case the feature extraction is not based on a method call.\n         */\n        fun methodCall(methodName: String, vararg arguments: Any?): RepresentationInCaseOfFailureStep<T> =\n            withDescription(coreFactory.newMethodCallFormatter().formatCall(methodName, arguments))\n\n        /**\n         * Uses the given [description], wraps it into an [Untranslatable] and uses it as description of the feature.\n         */\n        fun withDescription(description: String): RepresentationInCaseOfFailureStep<T> =\n            withDescription(Untranslatable(description))\n\n        /**\n         * Uses the given [translatable] as description of the feature.\n         */\n        fun withDescription(translatable: Translatable): RepresentationInCaseOfFailureStep<T>\n\n        companion object {\n            /**\n             * Creates a [DescriptionStep] in the context of the [FeatureExtractorBuilder].\n             */\n            fun <T> create(\n                originalAssertionContainer: Expect<T>\n            ): DescriptionStep<T> = DescriptionStepImpl(originalAssertionContainer)\n        }\n    }\n\n    /**\n     * Step which allows to to define the representation which shall be used\n     * in case the extraction cannot be performed.\n     *\n     * @param T the type of the current subject.\n     */\n    interface RepresentationInCaseOfFailureStep<T> {\n        /**\n         * The previously specified assertion container from which we are going to extract the feature.\n         */\n        val originalAssertionContainer: Expect<T>\n\n        /**\n         * The previously specified description which describes the kind of feature extraction.\n         */\n        val description: Translatable\n\n        /**\n         * Uses [translatable] as representation which will be used in case the extraction cannot be performed.\n         */\n        fun withRepresentationForFailure(translatable: Translatable): FeatureExtractionStep<T> =\n            withRepresentationForFailure(RawString.create(translatable))\n\n        /**\n         * Uses the given [representationProvider], by turning it into a [LazyRepresentation],\n         * to get the representation which will be used in case the extraction cannot be performed.\n         */\n        fun withRepresentationForFailure(representationProvider: () -> Any?): FeatureExtractionStep<T> =\n            withRepresentationForFailure(LazyRepresentation(representationProvider))\n\n        /**\n         * Uses the given [representation] in case the extraction cannot be performed.\n         *\n         * Notice, if you want to use text (e.g. a [String]), then wrap it into a [RawString] via [RawString.create]\n         * and pass the [RawString] instead.\n         */\n        fun withRepresentationForFailure(representation: Any): FeatureExtractionStep<T>\n\n        companion object {\n            /**\n             * Creates a [RepresentationInCaseOfFailureStep] in the context of the [FeatureExtractorBuilder].\n             */\n            fun <T> create(\n                originalAssertionContainer: Expect<T>,\n                description: Translatable\n            ): RepresentationInCaseOfFailureStep<T> =\n                RepresentationInCaseOfFailureStepImpl(originalAssertionContainer, description)\n        }\n    }\n\n    /**\n     * Step to define the feature extraction as such where a one can include a check by returning [None] in case the\n     * extraction should not be carried out\n     *  to see whether the feature extraction is feasible or not.\n     *\n     * @param T the type of the current subject.\n     */\n    interface FeatureExtractionStep<T> {\n        /**\n         * The previously specified assertion container from which we are going to extract the feature.\n         */\n        val originalAssertionContainer: Expect<T>\n\n        /**\n         * The previously specified description which describes the kind of feature extraction.\n         */\n\n        val description: Translatable\n\n        /**\n         * The previously specified representation which will be used in case the feature cannot be extracted.\n         */\n        val representationForFailure: Any\n\n        /**\n         * Defines the feature extraction as such which is most likely based on the current subject\n         * (but does not need to be).\n         *\n         * @param extraction A function returning either [Some] with the corresponding feature or [None] in case the\n         *   extraction cannot be carried out.\n         */\n        fun <R> withFeatureExtraction(extraction: (subject: T) -> Option<R>): OptionalRepresentationStep<T, R>\n\n        companion object {\n            /**\n             * Creates a [FeatureExtractionStep] in the context of the [FeatureExtractorBuilder].\n             */\n            fun <T> create(\n                originalAssertionContainer: Expect<T>,\n                description: Translatable,\n                representationForFailure: Any\n            ): FeatureExtractionStep<T> = FeatureExtractionStepImpl(\n                originalAssertionContainer, description, representationForFailure\n            )\n        }\n    }\n\n    /**\n     * Optional step which allows to specify a custom representation instead of the feature as such.\n     *\n     * @param T the type of the current subject.\n     * @param R the type of the feature, aka the new subject.\n     */\n    interface OptionalRepresentationStep<T, R> {\n        /**\n         * The so far chosen options up to the [FeatureExtractionStep] step.\n         */\n        val featureExtractionStep: FeatureExtractionStep<T>\n\n        /**\n         * The previously specified feature extraction lambda.\n         */\n        val featureExtraction: (T) -> Option<R>\n\n        /**\n         * Uses the given [representation] to represent the feature instead of using the feature itself.\n         *\n         * Use [build] if you do **not** want to provide a custom representation.\n         */\n        fun withRepresentationInsteadOfFeature(representation: Any): FinalStep<T, R>\n\n        /**\n         * Skips the option of defining a custom representation (uses the feature as such) and\n         * finishes the `feature extraction`-process by building a new [Expect] taking the previously chosen\n         * options into account.\n         *\n         * @return The newly created [Expect].\n         */\n        fun build(): ExtractedFeaturePostStep<T, R>\n\n        companion object {\n            /**\n             * Creates a [OptionalRepresentationStep] in the context of the [FeatureExtractorBuilder].\n             */\n            fun <T, R> create(\n                featureExtractionStep: FeatureExtractionStep<T>,\n                featureExtraction: (T) -> Option<R>\n            ): OptionalRepresentationStep<T, R> = OptionalRepresentationStepImpl(\n                featureExtractionStep, featureExtraction\n            )\n        }\n    }\n\n    /**\n     * Final step in the extract-feature-process, creates a [ExtractedFeaturePostStep]\n     * based on the previously specified options.\n     *\n     * @param T the type of the current subject.\n     * @param R the type of the feature, aka the new subject.\n     */\n    interface FinalStep<T, R> {\n        /**\n         * The so far chosen options up to the [FeatureExtractionStep] step.\n         */\n        val featureExtractionStep: FeatureExtractionStep<T>\n\n        /**\n         * The previously specified feature extraction lambda.\n         */\n        val featureExtraction: (T) -> Option<R>\n\n        /**\n         * The previously specified representation which shall be used instead of the future as such -- `null` means\n         * use the feature as such.\n         */\n        val representationInsteadOfFeature: Any?\n\n        /**\n         * Finishes the `feature extraction`-process by building a new [Expect] taking the previously chosen\n         * options into account.\n         *\n         * @return An [ExtractedFeaturePostStep] which allows to define what should happen with the new [Expect].\n         */\n        fun build(): ExtractedFeaturePostStep<T, R>\n\n        companion object {\n            /**\n             * Creates the [FinalStep] in the context of the [FeatureExtractorBuilder].\n             */\n            fun <T, R> create(\n                featureExtractionStep: FeatureExtractionStep<T>,\n                featureExtraction: (T) -> Option<R>,\n                representationInsteadOfFeature: Any?\n            ): FinalStep<T, R> = FinalStepImpl(\n                featureExtractionStep, featureExtraction, representationInsteadOfFeature\n            )\n        }\n    }\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating.changers\n\nimport ch.tutteli.atrium.assertions.DescriptiveAssertion\nimport ch.tutteli.atrium.core.polyfills.cast\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.creating.changers.impl.subjectchanger.*\nimport ch.tutteli.atrium.domain.creating.changers.ChangedSubjectPostStep\nimport ch.tutteli.atrium.domain.creating.changers.SubjectChanger\nimport ch.tutteli.atrium.domain.creating.changers.subjectChanger\nimport ch.tutteli.atrium.reporting.RawString\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\nimport ch.tutteli.atrium.translations.DescriptionAnyAssertion\nimport kotlin.reflect.KClass\nimport ch.tutteli.atrium.core.Some\nimport ch.tutteli.atrium.core.None\nimport ch.tutteli.atrium.core.Option\n\n/**\n * Defines the contract for sophisticated `change subject` processes.\n */\ninterface SubjectChangerBuilder {\n\n    companion object {\n        /**\n         * Entry point to use the [SubjectChangerBuilder].\n         */\n        fun <T> create(originalAssertionContainer: Expect<T>): KindStep<T> = KindStepImpl(originalAssertionContainer)\n\n        @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n        @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n        fun <T> create(\n            originalPlant: SubjectProvider<T>\n        ): DeprecatedKindStep<T> = DeprecatedKindStepImpl(originalPlant)\n    }\n\n    /**\n     * Step where one has to decide the kind of subject change.\n     *\n     * @param T the type of the current subject.\n     */\n    @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n    interface DeprecatedKindStep<T> {\n        /**\n         * The previously specified assertion plant to which the new [Assert] will delegate assertion checking.\n         */\n        @Suppress(\"DEPRECATION\")\n        val originalPlant: SubjectProvider<T>\n\n        @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n        @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n        fun <R : Any> unreported(\n            transformation: (T) -> R\n        ): Assert<R> = subjectChanger.unreportedToAssert(originalPlant, transformation)\n\n        @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n        @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n        fun <R> unreportedNullable(\n            transformation: (T) -> R\n        ): AssertionPlantNullable<R> = subjectChanger.unreportedNullableToAssert(originalPlant, transformation)\n    }\n\n    /**\n     * Step where one has to decide the kind of subject change.\n     *\n     * @param T the type of the current subject.\n     */\n    interface KindStep<T> {\n        /**\n         * The previously specified assertion container to which the new [Expect] will delegate assertion checking.\n         */\n        val originalAssertionContainer: Expect<T>\n\n\n        /**\n         * First and final step in the change-subject-process -- changes the subject without showing the change as\n         * such in reporting.\n         *\n         * @return The newly created [Expect] for the new subject.\n         */\n        fun <R> unreported(transformation: (T) -> R): Expect<R> =\n            subjectChanger.unreported(originalAssertionContainer, transformation)\n\n        /**\n         * Entry point of the building process to not only change the subject but also report the change in reporting.\n         *\n         * Typically the change is documented by adding a [DescriptiveAssertion] to the new resulting [Expect].\n         *\n         * This is basically a guide towards [SubjectChanger.reported],\n         * hence in a more verbose manner but also more readable in many cases.\n         */\n        fun reportBuilder(): DescriptionRepresentationStep<T>\n    }\n\n    /**\n     * Step which allows to specify the description and representation of the change.\n     *\n     * @param T the type of the current subject.\n     */\n    interface DescriptionRepresentationStep<T> {\n        /**\n         * The previously specified assertion container to which the new [Expect] will delegate assertion checking.\n         */\n        val originalAssertionContainer: Expect<T>\n\n        /**\n         * Uses [DescriptionAnyAssertion.IS_A] as description of the change,\n         * the given [subType] as representation and tries to perform a down-cast of [originalAssertionContainer]'s\n         * [Expect.maybeSubject] to the given type [TSub]\n         */\n        //TODO once kotlin supports to have type parameters as upper bounds of another type parameter next to `: Any` we should restrict TSub : T & Any\n        fun <TSub : Any> downCastTo(subType: KClass<TSub>): FailureHandlerOption<T, TSub> =\n            withDescriptionAndRepresentation(DescriptionAnyAssertion.IS_A, subType)\n                .withTransformation {\n                    Option.someIf( subType.isInstance(it) ){  subType.cast(it) }\n               }\n\n        /**\n         * Uses the given [description] and [representation] to represent the change by delegating to the other overload\n         * which expects a [Translatable] instead of a [String].\n         *\n         * See the other overload for further information.\n         */\n        fun withDescriptionAndRepresentation(description: String, representation: Any?): TransformationStep<T> =\n            withDescriptionAndRepresentation(Untranslatable(description), representation)\n\n        /**\n         * Uses the given [description] and [representation] to represent the change.\n         * Moreover, subsequent options in the building step allow to define rules when the change cannot be applied, in\n         * such a case an alternative description and representation might be used (depending on the implementation and\n         * chosen options).\n         *\n         * Notice, if you want to use text (e.g. a [String]) as [representation],\n         * then wrap it into a [RawString] via [RawString.create] and pass the [RawString] instead.\n         */\n        fun withDescriptionAndRepresentation(description: Translatable, representation: Any?): TransformationStep<T>\n\n        companion object {\n            /**\n             * Creates a [DescriptionRepresentationStep] in the context of the [SubjectChangerBuilder].\n             */\n            fun <T> create(\n                originalAssertionContainer: Expect<T>\n            ): DescriptionRepresentationStep<T> = DescriptionRepresentationStepImpl(originalAssertionContainer)\n        }\n    }\n\n    /**\n     * Step to define the transformation which yields the new subject wrapped into a [Some] if the transformation\n     * as such can be carried out or [None].\n     *\n     * @param T the type of the current subject.\n     */\n    interface TransformationStep<T> {\n        /**\n         * The previously specified assertion container to which the new [Expect] will delegate assertion checking.\n         */\n        val originalAssertionContainer: Expect<T>\n\n        /**\n         * The previously specified description which describes the kind of subject change.\n         */\n        val description: Translatable\n\n        /**\n         * The previously specified representation of the change.\n         */\n        val representation: Any\n\n        /**\n         * Defines the new subject, most likely based on the current subject (but does not need to be).\n         */\n        fun <R> withTransformation(transformation: (T) -> Option<R>): FailureHandlerOption<T, R>\n\n        companion object {\n            /**\n             * Creates a [TransformationStep] in the context of the [SubjectChangerBuilder].\n             */\n            fun <T> create(\n                originalAssertionContainer: Expect<T>,\n                description: Translatable,\n                representation: Any\n            ): TransformationStep<T> = TransformationStepImpl(originalAssertionContainer, description, representation)\n        }\n    }\n\n    /**\n     * Optional step which allows to specify a custom [SubjectChanger.FailureHandler].\n     *\n     * @param T the type of the current subject.\n     * @param R the type of the new subject.\n     */\n    interface FailureHandlerOption<T, R> {\n        /**\n         * The so far chosen options up to the [TransformationStep] step.\n         */\n        val transformationStep: TransformationStep<T>\n\n        /**\n         * The previously specified new subject.\n         */\n        val transformation: (T) -> Option<R>\n\n        /**\n         * Uses the given [failureHandler] as [SubjectChanger.FailureHandler]\n         * to create the failing assertion in case the subject change fails.\n         */\n        fun withFailureHandler(failureHandler: SubjectChanger.FailureHandler<T, R>): FinalStep<T, R>\n\n        /**\n         * Uses the default [SubjectChanger.FailureHandler] which builds the failing assertion based on the specified\n         * [TransformationStep.description] and [TransformationStep.representation] and includes the assertions\n         * a given assertionCreator lambda would create.\n         */\n        fun withDefaultFailureHandler(): FinalStep<T, R>\n\n        /**\n         * Skips this step by using [withDefaultFailureHandler] and calls [FinalStep.build].\n         * @return\n         */\n        fun build(): ChangedSubjectPostStep<T, R> = withDefaultFailureHandler().build()\n\n        companion object {\n            /**\n             * Creates a [FailureHandlerOption] in the context of the [SubjectChangerBuilder].\n             */\n            fun <T, R> create(\n                transformationStep: TransformationStep<T>,\n                transformation: (T) -> Option<R>\n            ): FailureHandlerOption<T, R> = FailureHandlerOptionImpl(transformationStep, transformation)\n        }\n    }\n\n    /**\n     * Final step in the change-subject-process, creates a [ChangedSubjectPostStep]\n     * ased on the previously specified options.\n     *\n     * @param T the type of the current subject.\n     * @param R the type of the new subject.\n     */\n    interface FinalStep<T, R> {\n        /**\n         * The so far chosen options up to the [TransformationStep] step.\n         */\n        val transformationStep: TransformationStep<T>\n\n        /**\n         * The previously specified new subject.\n         */\n        val transformation: (T) -> Option<R>\n\n        /**\n         * The previously specified [SubjectChanger.FailureHandler].\n         */\n        val failureHandler: SubjectChanger.FailureHandler<T, R>\n\n        /**\n         * Finishes the `reported subject change`-process by building a new [Expect] taking the previously chosen\n         * options into account.\n         *\n         * @return A [ChangedSubjectPostStep] which allows to define what should happen with the new [Expect].\n         */\n        fun build(): ChangedSubjectPostStep<T, R>\n\n        companion object {\n            /**\n             * Creates the [FinalStep] in the context of the [SubjectChangerBuilder].\n             */\n            fun <T, R> create(\n                transformationStep: TransformationStep<T>,\n                transformation: (T) -> Option<R>,\n                failureHandler: SubjectChanger.FailureHandler<T, R>\n            ): FinalStep<T, R> = FinalStepImpl(transformationStep, transformation, failureHandler)\n        }\n    }\n}\n","package ch.tutteli.atrium.domain.builders.creating.changers.impl.featureextractor\n\nimport ch.tutteli.atrium.core.None\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.core.Some\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.creating.changers.FeatureExtractorBuilder\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.changers.featureExtractor\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\nclass DescriptionStepImpl<T>(\n    override val originalAssertionContainer: Expect<T>\n) : FeatureExtractorBuilder.DescriptionStep<T> {\n\n    override fun withDescription(\n        translatable: Translatable\n    ): FeatureExtractorBuilder.RepresentationInCaseOfFailureStep<T> =\n        FeatureExtractorBuilder.RepresentationInCaseOfFailureStep.create(originalAssertionContainer, translatable)\n}\n\ninternal class RepresentationInCaseOfFailureStepImpl<T>(\n    override val originalAssertionContainer: Expect<T>,\n    override val description: Translatable\n) : FeatureExtractorBuilder.RepresentationInCaseOfFailureStep<T> {\n    override fun withRepresentationForFailure(representation: Any): FeatureExtractorBuilder.FeatureExtractionStep<T> =\n        FeatureExtractorBuilder.FeatureExtractionStep.create(originalAssertionContainer, description, representation)\n}\n\nclass FeatureExtractionStepImpl<T>(\n    override val originalAssertionContainer: Expect<T>,\n    override val description: Translatable,\n    override val representationForFailure: Any\n) : FeatureExtractorBuilder.FeatureExtractionStep<T> {\n\n    override fun <R> withFeatureExtraction(extraction: (T) -> Option<R>): FeatureExtractorBuilder.OptionalRepresentationStep<T, R> =\n        FeatureExtractorBuilder.OptionalRepresentationStep.create(this, extraction)\n}\n\nclass OptionalRepresentationStepImpl<T, R>(\n    override val featureExtractionStep: FeatureExtractorBuilder.FeatureExtractionStep<T>,\n    override val featureExtraction: (T) -> Option<R>\n) : FeatureExtractorBuilder.OptionalRepresentationStep<T, R> {\n\n    override fun withRepresentationInsteadOfFeature(representation: Any): FeatureExtractorBuilder.FinalStep<T, R> =\n        createFinalStep(representation)\n\n    override fun build(): ExtractedFeaturePostStep<T, R> = createFinalStep(null).build()\n\n    private fun createFinalStep(representation: Any?) =\n        FeatureExtractorBuilder.FinalStep.create(\n            featureExtractionStep,\n            featureExtraction,\n            representation\n        )\n}\n\nclass FinalStepImpl<T, R>(\n    override val featureExtractionStep: FeatureExtractorBuilder.FeatureExtractionStep<T>,\n    override val featureExtraction: (T) -> Option<R>,\n    override val representationInsteadOfFeature: Any?\n) : FeatureExtractorBuilder.FinalStep<T, R> {\n\n    override fun build(): ExtractedFeaturePostStep<T, R> =\n        ExtractedFeaturePostStep(featureExtractionStep.originalAssertionContainer,\n            extract = { extractIt(this, None) },\n            extractAndApply = { assertionCreator -> extractIt(this, Some(assertionCreator)) }\n        )\n\n    private fun extractIt(expect: Expect<T>, subAssertions: Option<Expect<R>.() -> Unit>) =\n        featureExtractor.extract(\n            expect,\n            featureExtractionStep.description,\n            featureExtractionStep.representationForFailure,\n            featureExtraction,\n            subAssertions,\n            representationInsteadOfFeature\n        )\n}\n\n","package ch.tutteli.atrium.domain.builders.creating.changers.impl.subjectchanger\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.invisibleGroup\nimport ch.tutteli.atrium.core.None\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.collectors.collectAssertions\nimport ch.tutteli.atrium.domain.creating.changers.SubjectChanger\n\nclass DefaultFailureHandlerImpl<T, R> : SubjectChanger.FailureHandler<T, R> {\n\n    override fun createAssertion(\n        originalAssertionContainer: Expect<T>,\n        descriptiveAssertion: Assertion,\n        maybeAssertionCreator: Option<Expect<R>.() -> Unit>\n    ): Assertion = maybeAssertionCreator.fold({\n        descriptiveAssertion\n    }) { assertionCreator ->\n        AssertImpl.builder.invisibleGroup\n            .withAssertions(\n                descriptiveAssertion,\n                AssertImpl.builder.explanatoryGroup\n                    .withDefaultType\n                    .collectAssertions(None, assertionCreator)\n                    .build()\n            )\n            .build()\n    }\n}\n","package ch.tutteli.atrium.domain.builders.creating.changers.impl.subjectchanger\n\nimport ch.tutteli.atrium.core.None\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.core.Some\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.creating.changers.SubjectChangerBuilder\nimport ch.tutteli.atrium.domain.creating.changers.ChangedSubjectPostStep\nimport ch.tutteli.atrium.domain.creating.changers.SubjectChanger\nimport ch.tutteli.atrium.domain.creating.changers.subjectChanger\nimport ch.tutteli.atrium.reporting.RawString\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\nclass KindStepImpl<T>(\n    override val originalAssertionContainer: Expect<T>\n) : SubjectChangerBuilder.KindStep<T> {\n\n    override fun reportBuilder(): SubjectChangerBuilder.DescriptionRepresentationStep<T> =\n        SubjectChangerBuilder.DescriptionRepresentationStep.create(originalAssertionContainer)\n}\n\n@Suppress(\"DEPRECATION\")\nclass DeprecatedKindStepImpl<T>(\n    override val originalPlant: SubjectProvider<T>\n) : SubjectChangerBuilder.DeprecatedKindStep<T>\n\nclass DescriptionRepresentationStepImpl<T>(\n    override val originalAssertionContainer: Expect<T>\n) : SubjectChangerBuilder.DescriptionRepresentationStep<T> {\n\n    override fun withDescriptionAndRepresentation(\n        description: Translatable,\n        representation: Any?\n    ): SubjectChangerBuilder.TransformationStep<T> = SubjectChangerBuilder.TransformationStep.create(\n        originalAssertionContainer,\n        description,\n        representation ?: RawString.NULL\n    )\n}\n\nclass TransformationStepImpl<T>(\n    override val originalAssertionContainer: Expect<T>,\n    override val description: Translatable,\n    override val representation: Any\n) : SubjectChangerBuilder.TransformationStep<T> {\n\n    override fun <R> withTransformation(\n        transformation: (T) -> Option<R>\n    ): SubjectChangerBuilder.FailureHandlerOption<T, R> =\n        SubjectChangerBuilder.FailureHandlerOption.create(this, transformation)\n}\n\nclass FailureHandlerOptionImpl<T, R>(\n    override val transformationStep: SubjectChangerBuilder.TransformationStep<T>,\n    override val transformation: (T) -> Option<R>\n) : SubjectChangerBuilder.FailureHandlerOption<T, R> {\n\n    override fun withFailureHandler(\n        failureHandler: SubjectChanger.FailureHandler<T, R>\n    ): SubjectChangerBuilder.FinalStep<T, R> =\n        SubjectChangerBuilder.FinalStep.create(transformationStep, transformation, failureHandler)\n\n    override fun withDefaultFailureHandler(): SubjectChangerBuilder.FinalStep<T, R> =\n        withFailureHandler(DefaultFailureHandlerImpl())\n}\n\nclass FinalStepImpl<T, R>(\n    override val transformationStep: SubjectChangerBuilder.TransformationStep<T>,\n    override val transformation: (T) -> Option<R>,\n    override val failureHandler: SubjectChanger.FailureHandler<T, R>\n) : SubjectChangerBuilder.FinalStep<T, R> {\n\n    override fun build(): ChangedSubjectPostStep<T, R> =\n        ChangedSubjectPostStep(transformationStep.originalAssertionContainer,\n            transform = { transformIt(this, None) },\n            transformAndApply = { assertionCreator -> transformIt(this, Some(assertionCreator)) }\n        )\n\n    private fun transformIt(expect: Expect<T>, subAssertions: Option<Expect<R>.() -> Unit>) =\n        subjectChanger.reported(\n            expect,\n            transformationStep.description,\n            transformationStep.representation,\n            transformation,\n            failureHandler,\n            subAssertions\n        )\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CharSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.CharSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.charSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.SearchBehaviourFactory\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.searchBehaviourFactory\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceAssertions].\n * In detail, it implements [CharSequenceAssertions] by delegating to [charSequenceAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceAssertionsBuilder : CharSequenceAssertions {\n\n    override inline fun <T : CharSequence> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <T : CharSequence> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun startsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsWith(subjectProvider, expected)\n\n    override inline fun startsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsNotWith(subjectProvider, expected)\n\n    override inline fun endsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsWith(subjectProvider, expected)\n\n    override inline fun endsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsNotWith(subjectProvider, expected)\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun isNotBlank(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotBlank(subjectProvider)\n\n    override inline fun <T : CharSequence> matches(assertionContainer: Expect<T>, expected: Regex) =\n        charSequenceAssertions.matches(assertionContainer, expected)\n\n    override inline fun <T : CharSequence> mismatches(assertionContainer: Expect<T>, expected: Regex) =\n        charSequenceAssertions.mismatches(assertionContainer, expected)\n\n    /**\n     * Returns [CharSequenceContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceContainsAssertions].\n     */\n    inline val contains get() = CharSequenceContainsAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceContainsAssertions].\n * In detail, it implements [CharSequenceContainsAssertions] by delegating to [charSequenceContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceContainsAssertionsBuilder : CharSequenceContainsAssertions {\n\n    override inline fun <T : CharSequence> values(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Any>\n    ) = charSequenceContainsAssertions.values(checkerOption, expected)\n\n    override inline fun <T : CharSequence> valuesIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Any>\n    ) = charSequenceContainsAssertions.valuesIgnoringCase(checkerOption, expected)\n\n    override inline fun <T : CharSequence> defaultTranslationOf(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOf(checkerOption, expected)\n\n    override inline fun <T : CharSequence> defaultTranslationOfIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOfIgnoringCase(checkerOption, expected)\n\n    @JvmName(\"stringRegex\")\n    inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<String>\n    ) = regex(checkerOption, expected.map { it.toRegex() })\n\n    override inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Regex>\n    ) = charSequenceContainsAssertions.regex(checkerOption, expected)\n\n    override inline fun <T : CharSequence> regexIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<String>\n    ) = charSequenceContainsAssertions.regexIgnoringCase(checkerOption, expected)\n\n    /**\n     * Returns [CharSequenceContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = CharSequenceContainsSearchBehaviourFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <T : CharSequence> ignoringCase(\n        containsBuilder: CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    ): CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour> =\n        searchBehaviourFactory.ignoringCase(containsBuilder)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Converts the string into a regular expression [Regex] with the default options.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(): Regex = Regex(this)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified single [option].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(option: RegexOption): Regex = Regex(this, option)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified set of [options].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(options: Set<RegexOption>): Regex = Regex(this, options)\n","package ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders\n\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.Checker\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains at least` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @property times The number which the check will compare against the actual number of times an expected object\n *   is found in the input of the search.\n *\n * @constructor The base class for builders which create a `contains at least` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `CharSequence contains not` assertion.\n * @param atLeastCall The name of the function which was called and created this builder.\n */\nabstract class AtLeastCheckerOptionBase<out T : CharSequence, out S : SearchBehaviour>(\n    final override val times: Int,\n    final override val containsBuilder: CharSequenceContains.Builder<T, S>,\n    nameContainsNotFun: String,\n    atLeastCall: (Int) -> String\n) : WithTimesCheckerOption<T, S> {\n\n    override val checkers: List<Checker> = listOf(\n        checkerFactory.newAtLeastChecker(times, nameContainsNotFun, atLeastCall)\n    )\n}\n","package ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders\n\nimport ch.tutteli.atrium.domain.builders.utils.validateAtMost\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.Checker\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @property times The number which the check will compare against the actual number of times an expected object\n *   is found in the input of the search.\n *\n * @constructor The base class for builders which create a `contains at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `CharSequence contains not` assertion.\n * @param atMostCall The name of the function which was called and created this builder.\n * @param atLeastCall The name of the function which represents a `CharSequence contains at least` assertion.\n * @param exactlyCall The name of the function which represents a `CharSequence contains exactly` assertion.\n */\nabstract class AtMostCheckerOptionBase<out T : CharSequence, out S : SearchBehaviour>(\n    final override val times: Int,\n    final override val containsBuilder: CharSequenceContains.Builder<T, S>,\n    nameContainsNotFun: String,\n    atMostCall: (Int) -> String,\n    atLeastCall: (Int) -> String,\n    exactlyCall: (Int) -> String\n) : WithTimesCheckerOption<T, S> {\n\n    init {\n        validateAtMost(\n            times,\n            atMostCall,\n            atLeastCall,\n            exactlyCall\n        )\n    }\n\n    override val checkers: List<Checker> = listOf(\n        checkerFactory.newAtLeastChecker(1, nameContainsNotFun, atLeastCall),\n        checkerFactory.newAtMostChecker(times, nameContainsNotFun, atMostCall)\n    )\n}\n","package ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders\n\nimport ch.tutteli.atrium.domain.builders.utils.validateButAtMost\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.Checker\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied to the input of the search.\n *\n * @property times The number which the check will compare against the actual number of times an expected object\n *   is found in the input of the search.\n *\n * @constructor The base class for builders which create the second step of a `contains at least but at most` check\n *   within the fluent API of a sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `CharSequence contains not` assertion.\n * @param atMostCall The name of the function which represents a `CharSequence contains at most` assertion.\n * @param atLeastCall The name of the function which represents a `CharSequence contains at least` assertion.\n * @param butAtMostCall The name of the function which was called and created this builder.\n * @param exactlyCall The name of the function which represents a `CharSequence contains exactly` assertion.\n */\nabstract class ButAtMostCheckerOptionBase<out T : CharSequence, out S : SearchBehaviour>(\n    final override val times: Int,\n    atLeastBuilder: WithTimesCheckerOption<T, S>,\n    final override val containsBuilder: CharSequenceContains.Builder<T, S>,\n    nameContainsNotFun: String,\n    atLeastButAtMostCall: (Int, Int) -> String,\n    atMostCall: (Int) -> String,\n    atLeastCall: (Int) -> String,\n    butAtMostCall: (Int) -> String,\n    exactlyCall: (Int) -> String\n) : WithTimesCheckerOption<T, S> {\n\n    init {\n        validateButAtMost(\n            atLeastBuilder.times,\n            times,\n            atLeastButAtMostCall,\n            atLeastCall,\n            butAtMostCall,\n            exactlyCall\n        )\n    }\n\n    override val checkers: List<Checker> = listOf(\n        *atLeastBuilder.checkers.toTypedArray(),\n        checkerFactory.newAtMostChecker(times, nameContainsNotFun, atMostCall)\n    )\n}\n","package ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders\n\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.Checker\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @property times The number which the check will compare against the actual number of times an expected object\n *   is found in the input of the search.\n *\n * @constructor The base class for builders which create a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `CharSequence contains not` assertion.\n * @param exactlyCall The function call which should not be used if [times] equals to zero.\n */\nabstract class ExactlyCheckerOptionBase<out T : CharSequence, out S : SearchBehaviour>(\n    final override val times: Int,\n    final override val containsBuilder: CharSequenceContains.Builder<T, S>,\n    nameContainsNotFun: String,\n    exactlyCall: (Int) -> String\n) : WithTimesCheckerOption<T, S> {\n\n    override val checkers: List<Checker> = listOf(\n        checkerFactory.newExactlyChecker(times, nameContainsNotFun, exactlyCall)\n    )\n}\n","package ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders\n\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains not` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor The base class for builders which create a `contains at least` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n */\nabstract class NotCheckerOptionBase<out T : CharSequence, out S : SearchBehaviour>(\n    override val containsBuilder: CharSequenceContains.Builder<T, S>\n) : CharSequenceContains.CheckerOption<T, S> {\n\n    override val checkers = listOf(\n        checkerFactory.newNotChecker()\n    )\n}\n\n","package ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders\n\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.Checker\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @property times The number which the check will compare against the actual number of times an expected object\n *   is found in the input of the search.\n *\n * @constructor The base class for builders which create a `contains not or at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `CharSequence contains not` assertion.\n * @param notOrAtMostCall The name of the function which was called and created this builder.\n */\nabstract class NotOrAtMostCheckerOptionBase<out T : CharSequence, out S : SearchBehaviour>(\n    final override val times: Int,\n    final override val containsBuilder: CharSequenceContains.Builder<T, S>,\n    nameContainsNotFun: String,\n    notOrAtMostCall: (Int) -> String\n) : WithTimesCheckerOption<T, S> {\n\n    override val checkers: List<Checker> = listOf(\n        checkerFactory.newAtMostChecker(times, nameContainsNotFun, notOrAtMostCall)\n    )\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating.collectors\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.collectors.*\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\n/**\n * Delegates inter alia to the implementation of [AssertionCollector].\n * In detail, it implements [AssertionCollector] by delegating to [assertionCollector]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject AssertionCollectorBuilder : AssertionCollector {\n\n    override inline fun <T> collect(\n        maybeSubject: Option<T>,\n        noinline assertionCreator: Expect<T>.() -> Unit\n    ): Assertion = assertionCollector.collect(maybeSubject, assertionCreator)\n\n    override inline fun <T> collectForComposition(\n        maybeSubject: Option<T>,\n        noinline assertionCreator: Expect<T>.() -> Unit\n    ) = assertionCollector.collectForComposition(maybeSubject, assertionCreator)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    override inline fun <T, A : ch.tutteli.atrium.creating.BaseAssertionPlant<T, A>, C : ch.tutteli.atrium.creating.BaseCollectingAssertionPlant<T, A, C>> collect(\n        noinline subjectProvider: () -> T,\n        noinline collectingPlantFactory: (() -> T) -> C,\n        noinline assertionCreator: C.() -> Unit\n    ): AssertionGroup = assertionCollector.collect(subjectProvider, collectingPlantFactory, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use the other overload; will be removed with 1.0.0\")\n    override inline fun <T, A : ch.tutteli.atrium.creating.BaseAssertionPlant<T, A>, C : ch.tutteli.atrium.creating.BaseCollectingAssertionPlant<T, A, C>> collectOrExplain(\n        safeToCollect: Boolean,\n        warningCannotEvaluate: Translatable,\n        noinline subjectProvider: () -> T,\n        noinline collectingPlantFactory: (() -> T) -> C,\n        noinline assertionCreator: C.() -> Unit\n    ): AssertionGroup = assertionCollector.collectOrExplain(\n        safeToCollect, warningCannotEvaluate, subjectProvider, collectingPlantFactory, assertionCreator\n    )\n\n    /**\n     * Returns [ExplainingAssertionCollectorOption] providing options to create an assertion collector which collects\n     * assertions in the context of explaining assertions.\n     * It inter alia delegates to the implementation of [ThrowingAssertionCollectorForExplanation] and\n     * [NonThrowingAssertionCollectorForExplanation].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Switch from Assert to Expect and use ExpectImpl.collector.collectForComposition; will be removed with 1.0.0\")\n    inline val forExplanation\n        get() = ExplainingAssertionCollectorOption\n}\n\n/**\n * Delegates inter alia to the implementation of [ThrowingAssertionCollectorForExplanation] and\n * [NonThrowingAssertionCollectorForExplanation].\n */\n@Deprecated(\"Switch from Assert to Expect and use ExpectImpl.collector.collectForComposition; will be removed with 1.0.0\")\nobject ExplainingAssertionCollectorOption {\n\n    /**\n     * Choosing this option causes the [AssertionCollector] to throw an [IllegalArgumentException] in case not a single\n     * [Assertion] was collected.\n     *\n     * Use [doNotThrowIfNoAssertionIsCollected] if such use cases should be ignored (no exception should be thrown).\n     */\n    @Suppress(\"DEPRECATION\")\n    inline val throwIfNoAssertionIsCollected\n        get() = throwingAssertionCollectorForExplanation\n\n    /**\n     * Choosing this option will ignore use cases where not a single [Assertion] was collected.\n     *\n     * Use [throwIfNoAssertionIsCollected] if you want that [AssertionCollector] throws an\n     * [IllegalArgumentException] in such cases.\n     */\n    @Suppress(\"DEPRECATION\")\n    inline val doNotThrowIfNoAssertionIsCollected\n        get() = nonThrowingAssertionCollectorForExplanation\n}\n","package ch.tutteli.atrium.domain.builders.creating.collectors\n\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.ExplanatoryAssertionGroupType\nimport ch.tutteli.atrium.assertions.builders.AssertionsOption\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\n\n/**\n * Collects the assertions [assertionCreator] creates and uses them as [AssertionGroup.assertions].\n */\nfun <T, G : ExplanatoryAssertionGroupType, R> AssertionsOption<G, R>.collectAssertions(\n    assertionContainer: Expect<T>,\n    assertionCreator: Expect<T>.() -> Unit\n) = collectAssertions(assertionContainer.maybeSubject, assertionCreator)\n\n/**\n * Collects the assertions [assertionCreator] creates and uses them as [AssertionGroup.assertions].\n */\nfun <T, G : ExplanatoryAssertionGroupType, R> AssertionsOption<G, R>.collectAssertions(\n    maybeSubject: Option<T>,\n    assertionCreator: Expect<T>.() -> Unit\n) = withAssertions(ExpectImpl.collector.collectForComposition(maybeSubject, assertionCreator))\n","package ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders\n\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.Checker\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains at least` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @property times The number which the check will compare against the actual number of times an expected object\n *   is found in the input of the search.\n *\n * @constructor The base class for builders which create a `contains at least` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `CharSequence contains not` assertion.\n * @param atLeastCall The name of the function which was called and created this builder.\n */\nabstract class AtLeastCheckerOptionBase<out E, out T : Iterable<E>, out S : SearchBehaviour>(\n    final override val times: Int,\n    final override val containsBuilder: IterableContains.Builder<E, T, S>,\n    nameContainsNotFun: String,\n    atLeastCall: (Int) -> String\n) : WithTimesCheckerOption<E, T, S> {\n\n    override val checkers: List<Checker> = listOf(\n        checkerFactory.newAtLeastChecker(times, nameContainsNotFun, atLeastCall)\n    )\n}\n","package ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders\n\nimport ch.tutteli.atrium.domain.builders.utils.validateAtMost\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.Checker\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @property times The number which the check will compare against the actual number of times an expected object\n *   is found in the input of the search.\n *\n * @constructor The base class for builders which create a `contains at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `CharSequence contains not` assertion.\n * @param atMostCall The name of the function which was called and created this builder.\n * @param atLeastCall The name of the function which represents a `CharSequence contains at least` assertion.\n * @param exactlyCall The name of the function which represents a `CharSequence contains exactly` assertion.\n */\nabstract class AtMostCheckerOptionBase<out E, out T : Iterable<E>, out S : SearchBehaviour>(\n    final override val times: Int,\n    final override val containsBuilder: IterableContains.Builder<E, T, S>,\n    nameContainsNotFun: String,\n    atMostCall: (Int) -> String,\n    atLeastCall: (Int) -> String,\n    exactlyCall: (Int) -> String\n) : WithTimesCheckerOption<E, T, S> {\n\n    init {\n        validateAtMost(\n            times,\n            atMostCall,\n            atLeastCall,\n            exactlyCall\n        )\n    }\n\n    override val checkers: List<Checker> = listOf(\n        checkerFactory.newAtLeastChecker(1, nameContainsNotFun, atLeastCall),\n        checkerFactory.newAtMostChecker(times, nameContainsNotFun, atMostCall)\n    )\n}\n","package ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders\n\nimport ch.tutteli.atrium.domain.builders.utils.validateButAtMost\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.Checker\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied to the input of the search.\n *\n * @property times The number which the check will compare against the actual number of times an expected object\n *   is found in the input of the search.\n *\n * @constructor The base class for builders which create the second step of a `contains at least but at most` check\n *   within the fluent API of a sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `Iterable contains not` assertion.\n * @param atMostCall The name of the function which represents a `Iterable contains at most` assertion.\n * @param atLeastCall The name of the function which represents a `Iterable contains at least` assertion.\n * @param atMostCall The name of the function which was called and created this builder.\n * @param exactlyCall The name of the function which represents a `Iterable contains exactly` assertion.\n */\nabstract class ButAtMostCheckerOptionBase<out E, out T : Iterable<E>, out S : SearchBehaviour>(\n    final override val times: Int,\n    atLeastBuilder: WithTimesCheckerOption<E, T, S>,\n    final override val containsBuilder: IterableContains.Builder<E, T, S>,\n    nameContainsNotFun: String,\n    atLeastButAtMostCall: (Int, Int) -> String,\n    atMostCall: (Int) -> String,\n    atLeastCall: (Int) -> String,\n    butAtMostCall: (Int) -> String,\n    exactlyCall: (Int) -> String\n) : WithTimesCheckerOption<E, T, S> {\n\n    init {\n        validateButAtMost(\n            atLeastBuilder.times,\n            times,\n            atLeastButAtMostCall,\n            atLeastCall,\n            butAtMostCall,\n            exactlyCall\n        )\n    }\n\n    override val checkers: List<Checker> = listOf(\n        *atLeastBuilder.checkers.toTypedArray(),\n        checkerFactory.newAtMostChecker(times, nameContainsNotFun, atMostCall)\n    )\n}\n","package ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders\n\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.Checker\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @property times The number which the check will compare against the actual number of times an expected object\n *   is found in the input of the search.\n *\n * @constructor The base class for builders which create a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `Iterable contains not` assertion.\n * @param exactlyCall The name of the function which was called and created this builder.\n */\nabstract class ExactlyCheckerOptionBase<out E, out T : Iterable<E>, out S : SearchBehaviour>(\n    final override val times: Int,\n    final override val containsBuilder: IterableContains.Builder<E, T, S>,\n    nameContainsNotFun: String,\n    exactlyCall: (Int) -> String\n) : WithTimesCheckerOption<E, T, S> {\n\n    override val checkers: List<Checker> = listOf(\n        checkerFactory.newExactlyChecker(times, nameContainsNotFun, exactlyCall)\n    )\n}\n","package ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders\n\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains not` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor The base class for builders which create a `contains at least` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n */\nabstract class NotCheckerOptionBase<out E, out T : Iterable<E>, out S : SearchBehaviour>(\n    override val containsBuilder: IterableContains.Builder<E, T, S>\n) : IterableContains.CheckerOption<E, T, S> {\n\n    override val checkers = listOf(\n        checkerFactory.newNotChecker()\n    )\n}\n\n","package ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders\n\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.Checker\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains.SearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.checkers.checkerFactory\n\n/**\n * The base class for builders which create a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor The base class for builders which create a `contains at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n * @param nameContainsNotFun The name of the function which represents a `CharSequence contains not` assertion.\n * @param notOrAtMostCall The name of the function which was called and created this builder.\n */\nabstract class NotOrAtMostCheckerOptionBase<out E, out T : Iterable<E>, out S : SearchBehaviour>(\n    final override val times: Int,\n    final override val containsBuilder: IterableContains.Builder<E, T, S>,\n    nameContainsNotFun: String,\n    notOrAtMostCall: (Int) -> String\n) : WithTimesCheckerOption<E, T, S> {\n\n    override val checkers: List<Checker> = listOf(\n        checkerFactory.newAtMostChecker(times, nameContainsNotFun, notOrAtMostCall)\n    )\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.IterableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.IterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.iterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.*\nimport ch.tutteli.atrium.domain.creating.iterableAssertions\n\n/**\n * Delegates inter alia to the implementation of [IterableAssertions].\n * In detail, it implements [IterableAssertions] by delegating to [iterableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableAssertionsBuilder : IterableAssertions {\n\n    override inline fun <E, T : Iterable<E>> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <E, T : Iterable<E>> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun <E : Any, T : Iterable<E?>> all(\n        assertionContainer: Expect<T>,\n        noinline assertionCreator: (Expect<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(assertionContainer, assertionCreator)\n\n\n    override inline fun <E, T : Iterable<E>> hasNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNext(expect)\n\n    override inline fun <E, T : Iterable<E>> hasNotNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNotNext(expect)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> min(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, E> =\n        iterableAssertions.min(assertionContainer)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> max(assertionContainer: Expect<T>) =\n        iterableAssertions.max(assertionContainer)\n\n    /**\n     * Returns [IterableContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [IterableContainsAssertions].\n     */\n    inline val contains get() = IterableContainsAssertionsBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any> all(\n        plant: AssertionPlant<Iterable<E?>>,\n        noinline assertionCreator: (AssertionPlant<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(plant, assertionCreator)\n}\n\n/**\n * Delegates inter alia to the implementation of [IterableContainsAssertions].\n * In detail, it implements [IterableContainsAssertions] by delegating to [iterableContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableContainsAssertionsBuilder : IterableContainsAssertions {\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrder(checkerOption, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrder(checkerOption, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrderOnly(\n        builder: IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnly(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnly(\n        builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnly(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<E>>\n    ): Assertion = iterableContainsAssertions.valuesInOrderOnlyGrouped(builder, groups)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(Expect<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGrouped(builder, groups)\n\n\n    /**\n     * Returns [IterableContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = IterableContainsSearchBehaviourFactoryBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderWithAssert(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderWithAssert(checkerOption, assertionCreators)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGroupedWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(AssertionPlant<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGroupedWithAssert(builder, groups)\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <E, T : Iterable<E>> inAnyOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inAnyOrderOnly(builder: IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnly(builder: IterableContains.Builder<E, T, InOrderSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGrouped(builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGrouped(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGroupedWithin(builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGroupedWithin(builder)\n\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.creating.ThrowableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ChangedSubjectPostStep\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.ThrowableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.throwableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.providers.absentThrowableMessageProviderFactory\nimport ch.tutteli.atrium.domain.creating.throwableAssertions\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [ThrowableAssertions].\n * In detail, it implements [ThrowableAssertions] by delegating to [throwableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ThrowableAssertionsBuilder : ThrowableAssertions {\n\n    override inline fun thrownBuilder(\n        assertionVerb: Translatable,\n        noinline act: () -> Unit,\n        reporter: Reporter\n    ): ThrowableThrown.Builder = throwableAssertions.thrownBuilder(assertionVerb, act, reporter)\n\n    /**\n     * Returns [ThrowableThrownAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableThrownAssertions].\n     */\n    inline val thrown get() = ThrowableThrownAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ThrowableThrownAssertions].\n * In detail, it implements [ThrowableThrownAssertions] by delegating to [throwableThrownAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ThrowableThrownAssertionsBuilder : ThrowableThrownAssertions {\n\n    override inline fun <TExpected : Throwable> isA(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>\n    ) = throwableThrownAssertions.isA(throwableThrownBuilder, expectedType)\n\n    override inline fun notThrown(\n        throwableThrownBuilder: ThrowableThrown.Builder\n    ): ChangedSubjectPostStep<Throwable?, Nothing?> = throwableThrownAssertions.notThrown(throwableThrownBuilder)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <TExpected : Throwable> toBe(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>,\n        noinline assertionCreator: AssertionPlant<TExpected>.() -> Unit\n    ) = throwableThrownAssertions.toBe(throwableThrownBuilder, expectedType, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun nothingThrown(throwableThrownBuilder: ThrowableThrown.Builder) =\n        throwableThrownAssertions.nothingThrown(throwableThrownBuilder)\n\n    /**\n     * Returns [AbsentThrowableMessageProviderFactoryBuilder]\n     * which inter alia delegates to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Will be removed with 1.0.0\")\n    inline val providers\n        get() = AbsentThrowableMessageProviderFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n * In detail, it implements [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory] by delegating to [absentThrowableMessageProviderFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Will be removed with 1.0.0\")\nobject AbsentThrowableMessageProviderFactoryBuilder :\n    ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory {\n\n    override inline fun translatableBased(translatable: Translatable): ThrowableThrown.AbsentThrowableMessageProvider =\n        absentThrowableMessageProviderFactory.translatableBased(translatable)\n}\n","package ch.tutteli.atrium.domain.builders.migration\n\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.core.getOrElse\nimport ch.tutteli.atrium.core.newReportingPlantNullable\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.reporting.SHOULD_NOT_BE_SHOWN_TO_THE_USER_BUG_TRANSLATABLE\nimport kotlin.js.JsName\n\n/**\n * Turns this [Expect] into an [Assert] so that you can use functions which have not yet been migrated to [Expect].\n *\n * Will be removed with 1.0.0\n */\n@Deprecated(\n    \"Switch from Assert to Expect, most likely you only need to add `import ch.tutteli.atrium.api.fluent.en_GB.*` and then you can remove this call. \" +\n        \"This function was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\"\n)\n@Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n@JsName(\"asAssert\")\nfun <T : Any> Expect<T>.asAssert(): Assert<T> =\n    coreFactory.newReportingPlant(\n        SHOULD_NOT_BE_SHOWN_TO_THE_USER_BUG_TRANSLATABLE,\n        { this.maybeSubject.getOrElse { throw PlantHasNoSubjectException() } },\n        coreFactory.newDelegatingAssertionChecker(this)\n    )\n\n/**\n * Turns this [Expect] into an [Assert] so that you can use functions which have not yet been migrated to [Expect].\n *\n * Will be removed with 1.0.0\n */\n@Deprecated(\n    \"Switch from Assert to Expect, most likely you only need to add `import ch.tutteli.atrium.api.fluent.en_GB.*` and then you can remove this call. \" +\n        \"This function was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\"\n)\n@Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\nfun <T : Any> Expect<T>.asAssert(assertionCreator: Assert<T>.() -> Unit): Assert<T> =\n    asAssert().addAssertionsCreatedBy(assertionCreator)\n\n/**\n * Turns this [Expect] into an [AssertionPlantNullable] so that you can use functions\n * which have not yet been migrated to [Expect].\n *\n * Will be removed with 1.0.0\n */\n@Deprecated(\n    \"Switch from Assert to Expect, most likely you only need to add `import ch.tutteli.atrium.api.fluent.en_GB.*` and then you can remove this call. \" +\n        \"This function was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\"\n)\n@Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\nfun <T : Any> Expect<T?>.asAssert(): AssertionPlantNullable<T?> =\n    coreFactory.newReportingPlantNullable(\n        SHOULD_NOT_BE_SHOWN_TO_THE_USER_BUG_TRANSLATABLE,\n        { this.maybeSubject.getOrElse { throw PlantHasNoSubjectException() } },\n        coreFactory.newDelegatingAssertionChecker(this)\n    )\n\n\n@Deprecated(\n    \"Switch from Assert to Expect, migrate all inner functions first and then remove this call -- this function was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\"assertionCreatorOrNull\")\n)\n@Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\nfun <T : Any> asSubExpect(\n    assertionCreatorOrNull: (Assert<T>.() -> Unit)?\n): (Expect<T>.() -> Unit)? = { assertionCreatorOrNull?.let { asAssert(it) } }\n\n/**\n * Turns [Assert] or [AssertionPlantNullable] into an [Expect] so that you can use new functionality\n * which is not available on [Assert]/[AssertionPlantNullable].\n *\n * Try to switch entirely to [Expect] as [Assert] along with this function will be removed with 1.0.0\n */\n//TODO deprecate with 0.10.0\n//@Deprecated(\"Switch from Assert to Expect, this function was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\nfun <T : Any?, A : BaseAssertionPlant<T, *>> A.asExpect(): Expect<T> =\n    coreFactory.newDelegatingReportingAssertionContainer(this, this.maybeSubject)\n\n/**\n * Turns [Assert] or [AssertionPlantNullable] into an [Expect] so that you can use new functionality\n * which is not available on [Assert]/[AssertionPlantNullable].\n *\n * Try to switch entirely to [Expect] as [Assert] along with this function will be removed with 1.0.0\n *\n * @returns The deprecated plant.\n */\n//TODO deprecate with 0.10.0\n//@Deprecated(\"Switch from Assert to Expect, this function was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\nfun <T : Any, A : BaseAssertionPlant<T, *>> A.asExpect(assertionCreator: Expect<T>.() -> Unit): A {\n    asExpect().addAssertionsCreatedBy(assertionCreator)\n    return this\n}\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.impl.AssertionFormatterControllerOptionImpl\nimport ch.tutteli.atrium.reporting.AssertionFormatterController\nimport ch.tutteli.atrium.reporting.ObjectFormatter\nimport ch.tutteli.atrium.reporting.translating.Translator\n\n/**\n * Provides options to create an [AssertionFormatterController].\n */\ninterface AssertionFormatterControllerOption {\n\n    /**\n     * The previously chosen [ObjectFormatter].\n     */\n    val objectFormatter: ObjectFormatter\n\n    /**\n     * The previously chosen [Translator].\n     */\n    val translator: Translator\n\n    /**\n     * Uses [CoreFactory.newAssertionFormatterController] as [AssertionFormatterController].\n     */\n    fun withDefaultAssertionFormatterController(): AssertionFormatterFacadeOption\n\n    /**\n     * Uses the given [assertionFormatterController] as custom [AssertionFormatterController].\n     */\n    fun withAssertionFormatterController(assertionFormatterController: AssertionFormatterController): AssertionFormatterFacadeOption\n\n    companion object {\n        fun create(objectFormatter: ObjectFormatter, translator: Translator): AssertionFormatterControllerOption =\n            AssertionFormatterControllerOptionImpl(objectFormatter, translator)\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.impl.AssertionFormatterFacadeOptionImpl\nimport ch.tutteli.atrium.reporting.AssertionFormatterController\nimport ch.tutteli.atrium.reporting.AssertionFormatterFacade\nimport ch.tutteli.atrium.reporting.ObjectFormatter\nimport ch.tutteli.atrium.reporting.translating.Translator\n\n/**\n * Provides options to create an [AssertionFormatterFacade].\n */\ninterface AssertionFormatterFacadeOption {\n\n    /**\n     * The previously chosen [AssertionFormatterController]\n     */\n    val assertionFormatterController: AssertionFormatterController\n\n    /**\n     * The previously chosen [ObjectFormatter]\n     */\n    val objectFormatter: ObjectFormatter\n\n    /**\n     * The previously chosen [Translator]\n     */\n    val translator: Translator\n\n    /**\n     * Uses [CoreFactory.newAssertionFormatterFacade] as [AssertionFormatterFacade].\n     */\n    fun withDefaultAssertionFormatterFacade(): AssertionPairFormatterOption\n\n    /**\n     * Uses the given [factory] to build a custom [AssertionFormatterFacade].\n     */\n    fun withAssertionFormatterFacade(factory: (AssertionFormatterController) -> AssertionFormatterFacade): AssertionPairFormatterOption\n\n    companion object {\n        fun create(\n            assertionFormatterController: AssertionFormatterController,\n            objectFormatter: ObjectFormatter,\n            translator: Translator\n        ): AssertionFormatterFacadeOption =\n            AssertionFormatterFacadeOptionImpl(assertionFormatterController, objectFormatter, translator)\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.impl.AssertionPairFormatterOptionImpl\nimport ch.tutteli.atrium.reporting.AssertionFormatter\nimport ch.tutteli.atrium.reporting.AssertionFormatterFacade\nimport ch.tutteli.atrium.reporting.AssertionPairFormatter\nimport ch.tutteli.atrium.reporting.ObjectFormatter\nimport ch.tutteli.atrium.reporting.translating.Translator\n\n/**\n * Provides options to create an [AssertionPairFormatter].\n */\ninterface AssertionPairFormatterOption {\n\n    /**\n     * The so far chosen options which are relevant to create [AssertionFormatter]s.\n     */\n    val options: AssertionFormatterChosenOptions\n\n    /**\n     * Uses [CoreFactory.newTextSameLineAssertionPairFormatter] as [AssertionPairFormatter].\n     */\n    fun withTextSameLineAssertionPairFormatter(): TextAssertionFormatterOption =\n        withTextAssertionPairFormatter(coreFactory::newTextSameLineAssertionPairFormatter)\n\n    /**\n     * Uses [CoreFactory.newTextNextLineAssertionPairFormatter] as [AssertionPairFormatter].\n     */\n    fun withTextNextLineAssertionPairFormatter(): TextAssertionFormatterOption =\n        withTextAssertionPairFormatter(coreFactory::newTextNextLineAssertionPairFormatter)\n\n    /**\n     * Uses the given [factory] to build a custom [AssertionPairFormatter].\n     */\n    fun withTextAssertionPairFormatter(factory: (ObjectFormatter, Translator) -> AssertionPairFormatter): TextAssertionFormatterOption\n\n    companion object {\n        fun create(\n            assertionFormatterFacade: AssertionFormatterFacade,\n            objectFormatter: ObjectFormatter,\n            translator: Translator\n        ): AssertionPairFormatterOption = create(\n            AssertionFormatterChosenOptions(assertionFormatterFacade, objectFormatter, translator)\n        )\n\n        fun create(options: AssertionFormatterChosenOptions): AssertionPairFormatterOption =\n            AssertionPairFormatterOptionImpl(options)\n    }\n}\n\n/**\n * Represents the so far chosen options which are relevant to create [AssertionFormatter]s.\n *\n * @param assertionFormatterFacade The previously chosen [AssertionFormatterFacade]\n * @param objectFormatter The previously chosen [ObjectFormatter]\n * @param translator The previously chosen [Translator]\n */\ndata class AssertionFormatterChosenOptions(\n    val assertionFormatterFacade: AssertionFormatterFacade,\n    val objectFormatter: ObjectFormatter,\n    val translator: Translator\n)\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.domain.builders.reporting.impl.AtriumErrorAdjusterOptionImpl\nimport ch.tutteli.atrium.domain.builders.reporting.impl.MultipleAdjustersOptionImpl\nimport ch.tutteli.atrium.reporting.AssertionFormatterFacade\nimport ch.tutteli.atrium.reporting.AtriumError\nimport ch.tutteli.atrium.reporting.AtriumErrorAdjuster\nimport ch.tutteli.atrium.reporting.Reporter\n\n/**\n * Provides options to create an [AtriumErrorAdjusterOption].\n */\ninterface AtriumErrorAdjusterOption : AtriumErrorAdjusterCommonOption<ReporterOption> {\n\n    /**\n     * The previously chosen [AssertionFormatterFacade].\n     */\n    val assertionFormatterFacade: AssertionFormatterFacade\n\n    /**\n     * Uses [withMultipleAdjusters] and applies [withRemoveRunnerAtriumErrorAdjuster]\n     * and [withRemoveAtriumFromAtriumErrorAdjuster] -- the default configuration might change in the future.\n     */\n    fun withDefaultAtriumErrorAdjusters(): ReporterOption =\n        withMultipleAdjusters {\n            withRemoveAtriumFromAtriumErrorAdjuster()\n            withRemoveRunnerAtriumErrorAdjuster()\n        }\n\n    /**\n     * Uses an [AtriumErrorAdjuster] which does not adjust a given [AtriumError] but functions as an identity function.\n     */\n    fun withNoOpAtriumErrorAdjuster(): ReporterOption\n\n\n    /**\n     * Uses the [AtriumErrorAdjuster] which are defined via the [configure] lambda.\n     *\n     * @throws IllegalArgumentException in case less than two [AtriumErrorAdjuster] are defined.\n     */\n    fun withMultipleAdjusters(configure: MultipleAdjustersOption.() -> Unit): ReporterOption\n\n    @Deprecated(\n        \"Define an AtriumErrorAdjuster or use withDefaultAtriumErrorAdjusters; will be removed with 1.0.0\",\n        ReplaceWith(\"this.withDefaultAtriumErrorAdjusters().withOnlyFailureReporter()\")\n    )\n    fun withOnlyFailureReporter(): ReporterBuilderFinalStep\n\n    @Deprecated(\n        \"Define an AtriumErrorAdjuster or use withDefaultAtriumErrorAdjusters; will be removed with 1.0.0\",\n        ReplaceWith(\"this.withDefaultAtriumErrorAdjusters().withCustomReporter(factory)\")\n    )\n    fun withCustomReporter(factory: (AssertionFormatterFacade) -> Reporter): ReporterBuilderFinalStep\n\n\n    companion object {\n        fun create(assertionFormatterFacade: AssertionFormatterFacade): AtriumErrorAdjusterOption =\n            AtriumErrorAdjusterOptionImpl(assertionFormatterFacade)\n    }\n}\n\n/**\n * DSL Marker for [MultipleAdjustersOption]\n */\n@DslMarker\nannotation class MultipleAdjustersOptionMarker\n\n/**\n * Provides options to combine multiple [AtriumErrorAdjuster]s.\n */\n@MultipleAdjustersOptionMarker\ninterface MultipleAdjustersOption : AtriumErrorAdjusterCommonOption<Unit> {\n\n    /**\n     * Uses an [AtriumErrorAdjuster] which removes stack frames of test runners from a given [AtriumError].\n     */\n    @MultipleAdjustersOptionMarker\n    override fun withRemoveRunnerAtriumErrorAdjuster()\n\n    /**\n     * Uses an [AtriumErrorAdjuster] which removes stack frames of Atrium from a given [AtriumError].\n     */\n    @MultipleAdjustersOptionMarker\n    override fun withRemoveAtriumFromAtriumErrorAdjuster()\n\n    /**\n     * Uses the given [AtriumErrorAdjuster] as custom [AtriumErrorAdjuster].\n     */\n    @MultipleAdjustersOptionMarker\n    override fun withAtriumErrorAdjuster(adjuster: AtriumErrorAdjuster): Unit\n\n    val adjusters: List<AtriumErrorAdjuster>\n\n    companion object {\n        fun create(): MultipleAdjustersOption = MultipleAdjustersOptionImpl()\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.core.Some\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.reporting.impl.verb.AssertionVerbStepImpl\nimport ch.tutteli.atrium.domain.builders.reporting.impl.verb.FinalStepImpl\nimport ch.tutteli.atrium.domain.builders.reporting.impl.verb.OptionsChooserImpl\nimport ch.tutteli.atrium.domain.builders.reporting.impl.verb.OptionsStepImpl\nimport ch.tutteli.atrium.reporting.RawString\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\n\n/**\n * Defines the contract to create custom assertion verbs, `Expect<T>` respectively.\n */\ninterface ExpectBuilder {\n    companion object {\n\n        /**\n         * Entry point to use the [ExpectBuilder] which helps in creating\n         * an assertion verb for the given [subject] or in other words an [Expect] for the given [subject].\n         */\n        fun <T> forSubject(subject: T): AssertionVerbStep<T> = AssertionVerbStepImpl(Some(subject))\n    }\n\n    /**\n     * Step which allows to specify the assertion verb which shall be used.\n     *\n     * @param T the type of the subject.\n     */\n    interface AssertionVerbStep<T> {\n        /**\n         * The previously specified subject of the assertion.\n         */\n        val maybeSubject: Option<T>\n\n        /**\n         * Wraps the given [verb] into an [Untranslatable] and uses it as assertion verb.\n         */\n        fun withVerb(verb: String): OptionsStep<T> = withVerb(Untranslatable(verb))\n\n        /**\n         * Uses the given [verb] as assertion verb.\n         */\n        fun withVerb(verb: Translatable): OptionsStep<T>\n    }\n\n    /**\n     * Step which allows to override previously defined properties -- such as use a different assertion verb -- but\n     * also allows to define options where usually a default value is used, such as use a customer [Reporter].\n     *\n     * @param T the type of the subject.\n     */\n    interface OptionsStep<T> {\n        /**\n         * The previously specified subject of the assertion.\n         */\n        val maybeSubject: Option<T>\n\n        /**\n         * The previously defined assertion verb.\n         */\n        val assertionVerb: Translatable\n\n\n        /**\n         * Allows to define the [ExpectOptions] via an [OptionsChooser]-lambda which provides convenience functions.\n         *\n         * The function usually start with `with...` and are sometimes overloaded to ease the configuration.\n         */\n        fun withOptions(configuration: OptionsChooser.() -> Unit): FinalStep<T> =\n            withOptions(ExpectOptions(configuration))\n\n        /**\n         * Uses the given [expectOptions].\n         */\n        fun withOptions(expectOptions: ExpectOptions): FinalStep<T>\n\n        /**\n         * States explicitly that no optional [ExpectOptions] are defined, which means, `build` will create\n         * a new [Expect] based on the previously defined mandatory options but without any optional options or\n         * in other words, the default values are used for the optional options.\n         *\n         * Use [withOptions] if you want to define optional [ExpectOptions] such as, override the\n         * verb, define an own representation or use an own [Reporter].\n         */\n        fun withoutOptions(): FinalStep<T>\n\n        companion object {\n            fun <T> create(\n                maybeSubject: Option<T>,\n                assertionVerb: Translatable\n            ): OptionsStep<T> = OptionsStepImpl(maybeSubject, assertionVerb)\n        }\n    }\n\n    /**\n     * Helper lambda to specify [ExpectOptions] via convenience methods.\n     *\n     * Calling multiple times the same method overrides the previously defined value.\n     */\n    interface OptionsChooser {\n\n        /**\n         * Wraps the given [verb] into an [Untranslatable] and passes it to the overload\n         * which expects a [Translatable] -- this is then used as custom assertion verb\n         * instead of the previously defined verb.\n         *\n         */\n        fun withVerb(verb: String) {\n            withVerb(Untranslatable(verb))\n        }\n\n        /**\n         * Uses the given [verb] as assertion verb instead of the previously defined verb.\n         */\n        fun withVerb(verb: Translatable)\n\n        /**\n         * Uses the given [representation] as representation of the subject instead of using the subject as such to\n         * represent itself.\n         *\n         * Notice, if you want to use text (e.g. a [String]) as representation,\n         * then wrap it into a [RawString] via [RawString.create] and pass the [RawString] instead.\n         */\n        fun withRepresentation(representation: Any)\n\n        /**\n         * Use the given [representation] as custom representation for `null`.\n         *\n         * Notice, if you want to use text (e.g. a [String]) as representation,\n         * then wrap it into a [RawString] via [RawString.create] and pass the [RawString] instead.\n         */\n        fun withNullRepresentation(representation: Any)\n\n        /**\n         * Uses the given [reporter] instead of the default reporter.\n         */\n        fun withReporter(reporter: Reporter)\n\n        companion object {\n            fun createAndBuild(configuration: OptionsChooser.() -> Unit): ExpectOptions =\n                OptionsChooserImpl().apply(configuration).build()\n        }\n    }\n\n    /**\n     * Final step in the assertion verb building process, creates a new [Expect] based on the so far specified options.\n     *\n     * @param T the type of the subject.\n     */\n    interface FinalStep<T> {\n        /**\n         * The previously specified subject of the assertion.\n         */\n        val maybeSubject: Option<T>\n\n        /**\n         * The previously defined assertion verb.\n         */\n        val assertionVerb: Translatable\n\n        /**\n         * Either the previously specified [ExpectOptions] or `null`.\n         */\n        val options: ExpectOptions?\n\n        /**\n         * Creates a new [Expect] based on the previously defined maybeOptions.\n         */\n        fun build(): Expect<T>\n\n        companion object {\n            fun <T> create(\n                maybeSubject: Option<T>,\n                assertionVerb: Translatable,\n                options: ExpectOptions?\n            ): FinalStep<T> = FinalStepImpl(maybeSubject, assertionVerb, options)\n        }\n    }\n}\n\n/**\n * Additional (non-mandatory) options for the [ExpectBuilder] to create an [Expect].\n *\n * @property assertionVerb Defines a custom assertion verb if not null.\n * @property representation Defines a custom representation for the subject if not null.\n * @property nullRepresentation Defines a custom representation for `null` if not null.\n * @property reporter Defines a custom reporter if not null.\n */\ndata class ExpectOptions(\n    val assertionVerb: Translatable? = null,\n    val representation: Any? = null,\n    val nullRepresentation: Any? = null,\n    val reporter: Reporter? = null\n) {\n    /**\n     * Merges the given [options] with this object creating a new [ExpectOptions]\n     * where defined properties in [options] will have precedence over properties defined in this instance.\n     *\n     * For instance, this object has defined [representation] (meaning it is [Some]) and the given [options] as well,\n     * then the resulting [ExpectOptions] will have the [representation] of [options].\n     */\n    fun merge(options: ExpectOptions): ExpectOptions =\n        ExpectOptions(\n            options.assertionVerb ?: assertionVerb,\n            options.representation ?: representation,\n            options.nullRepresentation ?: nullRepresentation,\n            options.reporter ?: reporter\n        )\n}\n\n@Suppress(\"FunctionName\")\nfun ExpectOptions(configuration: ExpectBuilder.OptionsChooser.() -> Unit): ExpectOptions =\n    ExpectBuilder.OptionsChooser.createAndBuild(configuration)\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.impl.LocaleOrderDeciderOptionImpl\nimport ch.tutteli.atrium.reporting.translating.LocaleOrderDecider\nimport ch.tutteli.atrium.reporting.translating.TranslationSupplier\n\n/**\n * Provides options to create a [LocaleOrderDecider].\n */\ninterface LocaleOrderDeciderOption {\n\n    /**\n     * The previously chosen [TranslationSupplier].\n     */\n    val translationSupplier: TranslationSupplier\n\n    /**\n     * Uses [CoreFactory.newLocaleOrderDecider] as [LocaleOrderDecider].\n     */\n    fun withDefaultLocaleOrderDecider(): TranslatorOption\n\n    /**\n     * Uses [localeOrderDecider] as [LocaleOrderDecider].\n     */\n    fun withLocaleOrderDecider(localeOrderDecider: LocaleOrderDecider): TranslatorOption\n\n    companion object {\n        fun create(translationSupplier: TranslationSupplier): LocaleOrderDeciderOption =\n            LocaleOrderDeciderOptionImpl(translationSupplier)\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.impl.ObjectFormatterOptionImpl\nimport ch.tutteli.atrium.reporting.ObjectFormatter\nimport ch.tutteli.atrium.reporting.translating.Translator\n\n/**\n * Provides options to create an [ObjectFormatter].\n */\ninterface ObjectFormatterOption {\n\n    /**\n     * The previously chosen [Translator].\n     */\n    val translator: Translator\n\n    /**\n     * Uses [CoreFactory.newDetailedObjectFormatter] as [ObjectFormatter].\n     */\n    fun withDetailedObjectFormatter(): AssertionFormatterControllerOption\n\n    /**\n     * Uses the given [factory] to build a custom [ObjectFormatter].\n     */\n    fun withObjectFormatter(factory: (Translator) -> ObjectFormatter): AssertionFormatterControllerOption\n\n    companion object {\n        fun create(translator: Translator): ObjectFormatterOption = ObjectFormatterOptionImpl(translator)\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.domain.builders.reporting.impl.ReporterBuilderImpl\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.*\n\n/**\n * Entry point to build a [Reporter]\n * -- the first step provides options to create a [Translator] or a [TranslationSupplier].\n */\n@Deprecated(\n    \"Use ReporterBuilder.create() instead; will be removed with 1.0.0\",\n    ReplaceWith(\"ch.tutteli.atrium.domain.builders.reporting.ReporterBuilder.create()\")\n)\nval reporterBuilder: ReporterBuilder = ReporterBuilderImpl\n\n\n/**\n * Provides options to create a [Translator] or [TranslationSupplier] -- the platform specific\n * interface might provide further options.\n */\nexpect interface ReporterBuilder : ReporterBuilderCommon {\n    companion object {\n        fun create(): ReporterBuilder\n    }\n}\n\n/**\n * Provides options to create a [Translator] or [TranslationSupplier] -- those options\n * have to be provided on all platforms.\n */\ninterface ReporterBuilderCommon {\n\n    /**\n     * Uses [UsingDefaultTranslator] as [Translator] where [getDefaultLocale] is used to format arguments\n     * of [TranslatableWithArgs].\n     *\n     * [UsingDefaultTranslator] does not require a [TranslationSupplier] nor a [LocaleOrderDecider] and thus\n     * the options to specify implementations of them are skipped.\n     *\n     * Notice that [UsingDefaultTranslator] does not translate but uses what [Translatable.getDefault] returns.\n     */\n    fun withoutTranslationsUseDefaultLocale(): ObjectFormatterOption = withoutTranslations(getDefaultLocale())\n\n    /**\n     * Uses [UsingDefaultTranslator] as [Translator] where the given [primaryLocale] is used to format arguments\n     * of [TranslatableWithArgs].\n     *\n     * [UsingDefaultTranslator] does not require a [TranslationSupplier] nor a [LocaleOrderDecider] and thus\n     * the options to specify implementations of them are skipped.\n     *\n     * Notice that [UsingDefaultTranslator] does not translate but uses what [Translatable.getDefault] returns.\n     *\n     * @param primaryLocale The [Locale] used to format arguments of [TranslatableWithArgs].\n     */\n    fun withoutTranslations(primaryLocale: Locale): ObjectFormatterOption\n\n    /**\n     * Uses the given [translator] as [Translator] skipping the options for [TranslationSupplier] and\n     * [LocaleOrderDecider] assuming the given [translator] is implemented differently -- use\n     * [withDefaultTranslationSupplier] or [withTranslationSupplier] in case the given [translator] requires\n     * a [TranslationSupplier] or a [LocaleOrderDecider].\n     */\n    fun withTranslator(translator: Translator): ObjectFormatterOption\n\n    /**\n     * Uses a predefined method to create a [TranslationSupplier] -- see platform specific interface\n     * for further information.\n     */\n    fun withDefaultTranslationSupplier(): LocaleOrderDeciderOption\n\n    /**\n     * Uses the given [translationSupplier] as [TranslationSupplier].\n     */\n    fun withTranslationSupplier(translationSupplier: TranslationSupplier): LocaleOrderDeciderOption\n}\n\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.domain.builders.reporting.impl.ReporterBuilderFinalStepImpl\nimport ch.tutteli.atrium.reporting.Reporter\n\n/**\n * Final step in the [ReporterBuilder] process, creates the desired [Reporter].\n */\ninterface ReporterBuilderFinalStep {\n\n    /**\n     * Creates and returns the new [Reporter].\n     */\n    fun build(): Reporter\n\n    companion object {\n        fun create(factory: () -> Reporter): ReporterBuilderFinalStep = ReporterBuilderFinalStepImpl(factory)\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.impl.ReporterOptionImpl\nimport ch.tutteli.atrium.reporting.AssertionFormatterFacade\nimport ch.tutteli.atrium.reporting.AtriumErrorAdjuster\nimport ch.tutteli.atrium.reporting.Reporter\n\n/**\n * Provides options to finalise the building process, which means creating a [Reporter].\n */\ninterface ReporterOption {\n\n    /**\n     * The previously chosen [AssertionFormatterFacade].\n     */\n    val assertionFormatterFacade: AssertionFormatterFacade\n\n    /**\n     * The previously chosen [AtriumErrorAdjuster].\n     */\n    val atriumErrorAdjuster: AtriumErrorAdjuster\n\n    /**\n     * Uses [CoreFactory.newOnlyFailureReporter] as [Reporter].\n     */\n    fun withOnlyFailureReporter(): ReporterBuilderFinalStep\n\n    /**\n     * Uses the given [factory] to build a custom [Reporter].\n     */\n    fun withCustomReporter(\n        factory: (AssertionFormatterFacade, AtriumErrorAdjuster) -> Reporter\n    ): ReporterBuilderFinalStep\n\n    companion object {\n        fun create(\n            assertionFormatterFacade: AssertionFormatterFacade,\n            atriumErrorAdjuster: AtriumErrorAdjuster\n        ): ReporterOption = ReporterOptionImpl(assertionFormatterFacade, atriumErrorAdjuster)\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.AssertionFormatterControllerOption\nimport ch.tutteli.atrium.domain.builders.reporting.AssertionFormatterFacadeOption\nimport ch.tutteli.atrium.reporting.AssertionFormatterController\nimport ch.tutteli.atrium.reporting.ObjectFormatter\nimport ch.tutteli.atrium.reporting.translating.Translator\n\ninternal class AssertionFormatterControllerOptionImpl(\n    override val objectFormatter: ObjectFormatter,\n    override val translator: Translator\n) : AssertionFormatterControllerOption {\n\n    override fun withDefaultAssertionFormatterController() =\n        withAssertionFormatterController(coreFactory.newAssertionFormatterController())\n\n    override fun withAssertionFormatterController(assertionFormatterController: AssertionFormatterController) =\n        AssertionFormatterFacadeOption.create(assertionFormatterController, objectFormatter, translator)\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.AssertionFormatterFacadeOption\nimport ch.tutteli.atrium.domain.builders.reporting.AssertionPairFormatterOption\nimport ch.tutteli.atrium.reporting.AssertionFormatterController\nimport ch.tutteli.atrium.reporting.AssertionFormatterFacade\nimport ch.tutteli.atrium.reporting.ObjectFormatter\nimport ch.tutteli.atrium.reporting.translating.Translator\n\ninternal class AssertionFormatterFacadeOptionImpl(\n    override val assertionFormatterController: AssertionFormatterController,\n    override val objectFormatter: ObjectFormatter,\n    override val translator: Translator\n) : AssertionFormatterFacadeOption {\n\n    override fun withDefaultAssertionFormatterFacade() =\n        withAssertionFormatterFacade(coreFactory::newAssertionFormatterFacade)\n\n    override fun withAssertionFormatterFacade(factory: (AssertionFormatterController) -> AssertionFormatterFacade) =\n        AssertionPairFormatterOption.create(factory(assertionFormatterController), objectFormatter, translator)\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.domain.builders.reporting.AssertionFormatterChosenOptions\nimport ch.tutteli.atrium.domain.builders.reporting.AssertionPairFormatterOption\nimport ch.tutteli.atrium.domain.builders.reporting.TextAssertionFormatterOption\nimport ch.tutteli.atrium.reporting.AssertionPairFormatter\nimport ch.tutteli.atrium.reporting.ObjectFormatter\nimport ch.tutteli.atrium.reporting.translating.Translator\n\ninternal class AssertionPairFormatterOptionImpl(\n    override val options: AssertionFormatterChosenOptions\n) : AssertionPairFormatterOption {\n\n    override fun withTextAssertionPairFormatter(factory: (ObjectFormatter, Translator) -> AssertionPairFormatter) =\n        TextAssertionFormatterOption.create(options, factory(options.objectFormatter, options.translator))\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.AtriumErrorAdjusterOption\nimport ch.tutteli.atrium.domain.builders.reporting.MultipleAdjustersOption\nimport ch.tutteli.atrium.domain.builders.reporting.ReporterBuilderFinalStep\nimport ch.tutteli.atrium.domain.builders.reporting.ReporterOption\nimport ch.tutteli.atrium.reporting.AssertionFormatterFacade\nimport ch.tutteli.atrium.reporting.AtriumErrorAdjuster\nimport ch.tutteli.atrium.reporting.Reporter\n\ninternal class AtriumErrorAdjusterOptionImpl(\n    override val assertionFormatterFacade: AssertionFormatterFacade\n) : AtriumErrorAdjusterOption {\n\n    override fun withNoOpAtriumErrorAdjuster(): ReporterOption =\n        createReporterOption(coreFactory.newNoOpAtriumErrorAdjuster())\n\n    override fun withRemoveAtriumFromAtriumErrorAdjuster(): ReporterOption =\n        createReporterOption(coreFactory.newRemoveAtriumFromAtriumErrorAdjuster())\n\n    override fun withRemoveRunnerAtriumErrorAdjuster(): ReporterOption =\n        createReporterOption(coreFactory.newRemoveRunnerAtriumErrorAdjuster())\n\n    override fun withAtriumErrorAdjuster(adjuster: AtriumErrorAdjuster): ReporterOption =\n        createReporterOption(adjuster)\n\n    override fun withMultipleAdjusters(configure: MultipleAdjustersOption.() -> Unit): ReporterOption {\n        val adjusters = MultipleAdjustersOption.create()\n            .apply(configure)\n            .adjusters\n        require(adjusters.size > 1) {\n            \"You need to define at least two adjusters, only ${adjusters.size} defined.\"\n        }\n        val first = adjusters.first()\n        val tail = adjusters.drop(1)\n        return createReporterOption(coreFactory.newMultiAtriumErrorAdjuster(first, tail.first(), tail.drop(1)))\n    }\n\n    private fun createReporterOption(atriumErrorAdjuster: AtriumErrorAdjuster) =\n        ReporterOption.create(assertionFormatterFacade, atriumErrorAdjuster)\n\n\n    override fun withOnlyFailureReporter(): ReporterBuilderFinalStep =\n        withDefaultAtriumErrorAdjusters().withOnlyFailureReporter()\n\n    override fun withCustomReporter(factory: (AssertionFormatterFacade) -> Reporter): ReporterBuilderFinalStep =\n        withNoOpAtriumErrorAdjuster().withCustomReporter { facade, _ -> factory(facade) }\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.domain.builders.reporting.ReporterBuilder\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.ReporterFactory\n\n/**\n * Represents the [ReporterFactory] with [ReporterFactory.id] `default`.\n *\n * It is defined as follows (currently):\n * reporterBuilder\n *    .withoutTranslationsUseDefaultLocale()\n *    .withDetailedObjectFormatter()\n *    .withDefaultAssertionFormatterController()\n *    .withDefaultAssertionFormatterFacade()\n *    .withTextSameLineAssertionPairFormatter()\n *    .withTextCapabilities()\n *    .withDefaultAtriumErrorAdjusters()\n *    .withOnlyFailureReporter()\n *    .build()\n *\n */\nclass DefaultReporterFactory : ReporterFactory {\n    override val id = \"default\"\n\n    override fun create(): Reporter =\n        ReporterBuilder.create()\n            .withoutTranslationsUseDefaultLocale()\n            .withDetailedObjectFormatter()\n            .withDefaultAssertionFormatterController()\n            .withDefaultAssertionFormatterFacade()\n            .withTextSameLineAssertionPairFormatter()\n            .withTextCapabilities()\n            .withDefaultAtriumErrorAdjusters()\n            .withOnlyFailureReporter()\n            .build()\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.LocaleOrderDeciderOption\nimport ch.tutteli.atrium.reporting.translating.LocaleOrderDecider\nimport ch.tutteli.atrium.reporting.translating.TranslationSupplier\n\ninternal class LocaleOrderDeciderOptionImpl(\n    override val translationSupplier: TranslationSupplier\n) : LocaleOrderDeciderOption {\n\n    override fun withDefaultLocaleOrderDecider() = withLocaleOrderDecider(coreFactory.newLocaleOrderDecider())\n\n    override fun withLocaleOrderDecider(localeOrderDecider: LocaleOrderDecider) =\n        TranslatorOptionImpl(translationSupplier, localeOrderDecider)\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.MultipleAdjustersOption\nimport ch.tutteli.atrium.reporting.AtriumErrorAdjuster\n\ninternal class MultipleAdjustersOptionImpl : MultipleAdjustersOption {\n\n    private val _adjusters = mutableListOf<AtriumErrorAdjuster>()\n    override val adjusters: List<AtriumErrorAdjuster>\n        get() = _adjusters\n\n    override fun withRemoveRunnerAtriumErrorAdjuster() {\n        _adjusters.add(coreFactory.newRemoveRunnerAtriumErrorAdjuster())\n    }\n\n    override fun withRemoveAtriumFromAtriumErrorAdjuster() {\n        _adjusters.add(coreFactory.newRemoveAtriumFromAtriumErrorAdjuster())\n    }\n\n    override fun withAtriumErrorAdjuster(adjuster: AtriumErrorAdjuster) {\n        _adjusters.add(adjuster)\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.AssertionFormatterControllerOption\nimport ch.tutteli.atrium.domain.builders.reporting.ObjectFormatterOption\nimport ch.tutteli.atrium.reporting.ObjectFormatter\nimport ch.tutteli.atrium.reporting.translating.Translator\n\ninternal class ObjectFormatterOptionImpl(\n    override val translator: Translator\n) : ObjectFormatterOption {\n\n    override fun withDetailedObjectFormatter() = withObjectFormatter(coreFactory::newDetailedObjectFormatter)\n\n    override fun withObjectFormatter(factory: (Translator) -> ObjectFormatter) =\n        AssertionFormatterControllerOption.create(factory(translator), translator)\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.domain.builders.reporting.ReporterBuilderFinalStep\nimport ch.tutteli.atrium.reporting.Reporter\n\nclass ReporterBuilderFinalStepImpl(private val factory: () -> Reporter) : ReporterBuilderFinalStep {\n    override fun build(): Reporter = factory()\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.ReporterBuilderFinalStep\nimport ch.tutteli.atrium.domain.builders.reporting.ReporterOption\nimport ch.tutteli.atrium.reporting.AssertionFormatterFacade\nimport ch.tutteli.atrium.reporting.AtriumErrorAdjuster\nimport ch.tutteli.atrium.reporting.Reporter\n\ninternal class ReporterOptionImpl(\n    override val assertionFormatterFacade: AssertionFormatterFacade,\n    override val atriumErrorAdjuster: AtriumErrorAdjuster\n) : ReporterOption {\n\n    override fun withOnlyFailureReporter(): ReporterBuilderFinalStep =\n        withCustomReporter(coreFactory::newOnlyFailureReporter)\n\n    override fun withCustomReporter(\n        factory: (AssertionFormatterFacade, AtriumErrorAdjuster) -> Reporter\n    ): ReporterBuilderFinalStep = ReporterBuilderFinalStep.create {\n        factory(assertionFormatterFacade, atriumErrorAdjuster)\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.assertions.BulletPointIdentifier\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.AssertionFormatterChosenOptions\nimport ch.tutteli.atrium.domain.builders.reporting.AtriumErrorAdjusterOption\nimport ch.tutteli.atrium.domain.builders.reporting.TextAssertionFormatterOption\nimport ch.tutteli.atrium.reporting.AssertionFormatter\nimport ch.tutteli.atrium.reporting.AssertionFormatterController\nimport ch.tutteli.atrium.reporting.AssertionPairFormatter\nimport ch.tutteli.kbox.forElementAndForEachIn\nimport kotlin.reflect.KClass\n\ninternal class TextAssertionFormatterOptionImpl(\n    override val options: AssertionFormatterChosenOptions,\n    override val assertionPairFormatter: AssertionPairFormatter\n) : TextAssertionFormatterOption {\n\n    override fun withTextCapabilities(vararg bulletPoints: Pair<KClass<out BulletPointIdentifier>, String>): AtriumErrorAdjusterOption {\n        coreFactory.registerTextAssertionFormatterCapabilities(\n            bulletPoints.toMap(),\n            options.assertionFormatterFacade,\n            assertionPairFormatter,\n            options.objectFormatter,\n            options.translator\n        )\n        return AtriumErrorAdjusterOption.create(options.assertionFormatterFacade)\n    }\n\n    override fun withTextAssertionFormatter(\n        factory: (AssertionFormatterChosenOptions) -> (AssertionFormatterController) -> AssertionFormatter,\n        vararg otherFactories: (AssertionFormatterChosenOptions) -> (AssertionFormatterController) -> AssertionFormatter\n    ): AtriumErrorAdjusterOption {\n        forElementAndForEachIn(factory, otherFactories.asIterable()) {\n            options.assertionFormatterFacade.register(it(options))\n        }\n        return AtriumErrorAdjusterOption.create(options.assertionFormatterFacade)\n    }\n}\n","@file:Suppress(\"MethodOverloading\")\npackage ch.tutteli.kbox\n\n/**\n * Applies [action] to `this` and to each entry in [arr].\n */\ninline fun <E> forElementAndForEachIn(element: E, arr: Array<out E>, action: (E) -> Unit) {\n    action(element)\n    arr.forEach(action)\n}\n\n/**\n * Applies [action] to `this` and to each entry in [arr1] and in [arr2].\n */\ninline fun <E> forElementAndForEachIn(element: E, arr1: Array<out E>, arr2: Array<out E>, action: (E) -> Unit) {\n    action(element)\n    forEachIn(arr1, arr2, action)\n}\n\n/**\n * Applies [action] to `this` and to each entry in [arr1], [arr2] and each entry of [Iterable] in [arrays].\n */\ninline fun <E> forElementAndForEachIn(element: E, arr1: Array<out E>, arr2: Array<out E>, vararg arrays: Array<out E>, action: (E) -> Unit) {\n    action(element)\n    forEachIn(arr1, arr2, action)\n    arrays.forEach { it.forEach(action) }\n}\n\n\n/**\n * Applies [action] to `this` and to each entry in [iterable].\n */\ninline fun <E> forElementAndForEachIn(element: E, iterable: Iterable<E>, action: (E) -> Unit) {\n    action(element)\n    iterable.forEach(action)\n}\n\n/**\n * Applies [action] to `this` and to each entry in [iterable1] and in [iterable2].\n */\ninline fun <E> forElementAndForEachIn(element: E, iterable1: Iterable<E>, iterable2: Iterable<E>, action: (E) -> Unit) {\n    action(element)\n    forEachIn(iterable1, iterable2, action)\n}\n\n/**\n * Applies [action] to `this` and to each entry in [iterable1], [iterable2] and each entry of [Iterable] in [iterables].\n */\ninline fun <E> forElementAndForEachIn(element: E, iterable1: Iterable<E>, iterable2: Iterable<E>, vararg iterables: Iterable<E>, action: (E) -> Unit) {\n    action(element)\n    forEachIn(iterable1, iterable2, action)\n    iterables.forEach { it.forEach(action) }\n}\n\n/**\n * Applies [action] to `this` and to each entry in [sequence].\n */\ninline fun <E> forElementAndForEachIn(element: E, sequence: Sequence<E>, action: (E) -> Unit) {\n    action(element)\n    sequence.forEach(action)\n}\n\n/**\n * Applies [action] to `this` and to each entry in [sequence1] and in [sequence2].\n */\ninline fun <E> forElementAndForEachIn(element: E, sequence1: Sequence<E>, sequence2: Sequence<E>, action: (E) -> Unit) {\n    action(element)\n    forEachIn(sequence1, sequence2, action)\n}\n\n/**\n * Applies [action] to `this` and to each entry in in  [sequence1], [sequence2] and each entry of [Sequence] in [sequences].\n */\ninline fun <E> forElementAndForEachIn(element: E, sequence1: Sequence<E>, sequence2: Sequence<E>, vararg sequences: Sequence<E>, action: (E) -> Unit) {\n    action(element)\n    forEachIn(sequence1, sequence2, action)\n    sequences.forEach { it.forEach(action) }\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.domain.builders.reporting.TranslatorOption\nimport ch.tutteli.atrium.reporting.translating.Locale\nimport ch.tutteli.atrium.reporting.translating.LocaleOrderDecider\nimport ch.tutteli.atrium.reporting.translating.TranslationSupplier\nimport ch.tutteli.atrium.reporting.translating.Translator\n\ninternal class TranslatorOptionImpl(\n    override val translationSupplier: TranslationSupplier,\n    override val localeOrderDecider: LocaleOrderDecider\n) : TranslatorOption {\n\n    override fun withDefaultTranslator(primaryLocale: Locale, vararg fallbackLocales: Locale) =\n        ObjectFormatterOptionImpl(\n            coreFactory.newTranslator(\n                translationSupplier,\n                localeOrderDecider,\n                primaryLocale,\n                fallbackLocales.toList()\n            )\n        )\n\n    override fun withTranslator(factory: (TranslationSupplier, LocaleOrderDecider) -> Translator) =\n        ObjectFormatterOptionImpl(factory(translationSupplier, localeOrderDecider))\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl.verb\n\nimport ch.tutteli.atrium.domain.builders.reporting.ExpectBuilder\nimport ch.tutteli.atrium.domain.builders.reporting.ExpectOptions\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\nclass OptionsChooserImpl : ExpectBuilder.OptionsChooser {\n\n    private var description: Translatable? = null\n    private var representation: Any? = null\n    private var nullRepresentation: Any? = null\n    private var reporter: Reporter? = null\n\n    override fun withVerb(verb: Translatable) {\n        this.description = verb\n    }\n\n    override fun withRepresentation(representation: Any) {\n        this.representation = representation\n    }\n\n    override fun withNullRepresentation(representation: Any) {\n        this.nullRepresentation = representation\n    }\n\n    override fun withReporter(reporter: Reporter) {\n        this.reporter = reporter\n    }\n\n    fun build(): ExpectOptions = ExpectOptions(description, representation, nullRepresentation, reporter)\n}\n","package ch.tutteli.atrium.domain.builders.reporting.impl.verb\n\nimport ch.tutteli.atrium.core.Option\nimport ch.tutteli.atrium.core.coreFactory\nimport ch.tutteli.atrium.core.getOrElse\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.ReportingAssertionContainer\nimport ch.tutteli.atrium.domain.builders.reporting.ExpectBuilder\nimport ch.tutteli.atrium.domain.builders.reporting.ExpectOptions\nimport ch.tutteli.atrium.reporting.RawString\nimport ch.tutteli.atrium.reporting.SHOULD_NOT_BE_SHOWN_TO_THE_USER_BUG\nimport ch.tutteli.atrium.reporting.reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\n\nclass AssertionVerbStepImpl<T>(override val maybeSubject: Option<T>) : ExpectBuilder.AssertionVerbStep<T> {\n    override fun withVerb(verb: Translatable): ExpectBuilder.OptionsStep<T> =\n        ExpectBuilder.OptionsStep.create(maybeSubject, verb)\n}\n\nclass OptionsStepImpl<T>(\n    override val maybeSubject: Option<T>,\n    override val assertionVerb: Translatable\n) : ExpectBuilder.OptionsStep<T> {\n\n    override fun withOptions(expectOptions: ExpectOptions): ExpectBuilder.FinalStep<T> = toFinalStep(expectOptions)\n    override fun withoutOptions(): ExpectBuilder.FinalStep<T> = toFinalStep(null)\n\n    private fun toFinalStep(expectOptions: ExpectOptions?) =\n        ExpectBuilder.FinalStep.create(maybeSubject, assertionVerb, expectOptions)\n}\n\nclass FinalStepImpl<T>(\n    override val maybeSubject: Option<T>,\n    override val assertionVerb: Translatable,\n    override val options: ExpectOptions?\n) : ExpectBuilder.FinalStep<T> {\n\n    override fun build(): Expect<T> =\n        coreFactory.newReportingAssertionContainer(\n            ReportingAssertionContainer.AssertionCheckerDecorator.create(\n                options?.assertionVerb ?: assertionVerb,\n                maybeSubject,\n                options?.representation ?: maybeSubject.getOrElse {\n                    RawString.create(SHOULD_NOT_BE_SHOWN_TO_THE_USER_BUG)\n                },\n                coreFactory.newThrowingAssertionChecker(options?.reporter ?: reporter),\n                options?.nullRepresentation ?: RawString.NULL\n            )\n        )\n}\n","package ch.tutteli.atrium.domain.builders.utils\n\nimport ch.tutteli.kbox.glue\n\n/**\n * Represents a parameter object used to express the arguments `T, vararg T`\n * and provides utility functions to transform them.\n */\ninterface VarArgHelper<out T> {\n    /**\n     * The first argument in the argument list `T, vararg T`\n     */\n    val expected: T\n    /**\n     * The second argument in the argument list `T, vararg T`\n     */\n    val otherExpected: Array<out T>\n\n    /**\n     * Creates an [ArgumentMapperBuilder] which allows to map [expected] and [otherExpected].\n     */\n    val mapArguments get() = ArgumentMapperBuilder(expected, otherExpected)\n\n    /**\n     * Returns the arguments as [List].\n     */\n    fun toList(): List<T> = expected glue otherExpected\n}\n","package ch.tutteli.atrium.domain.builders.utils\n\n/**\n * Validates that times is not `1`; throws an IllegalArgumentException otherwise, pointing the user to use the given\n * [exactlyCall] instead of the given [atMostCall].\n */\nfun validateAtMost(\n    times: Int,\n    atMostCall: (Int) -> String,\n    atLeastCall: (Int) -> String,\n    exactlyCall: (Int) -> String\n) {\n    require(1 != times) {\n        \"use ${exactlyCall(times)} instead of ${atMostCall(times)}; \" +\n            \"${atMostCall(times)} defines implicitly ${atLeastCall(1)} as well\"\n    }\n}\n\n/**\n * Validates that [atLeastTimes] is not equal to or greater than [butAtMostTimes]; throws IllegalArgumentException\n * otherwise, pointing the user to use the given [exactlyCall] in case [atLeastTimes] equals [butAtMostTimes].\n */\nfun validateButAtMost(\n    atLeastTimes: Int,\n    butAtMostTimes: Int,\n    atLeastButAtMostCall: (Int, Int) -> String,\n    atLeastCall: (Int) -> String,\n    butAtMostCall: (Int) -> String,\n    exactlyCall: (Int) -> String\n) {\n    require(atLeastTimes != butAtMostTimes) {\n        \"use ${exactlyCall(butAtMostTimes)} instead of ${atLeastButAtMostCall(butAtMostTimes, butAtMostTimes)}\"\n    }\n\n    require(atLeastTimes < butAtMostTimes) {\n        \"specifying ${butAtMostCall(butAtMostTimes)} does not make sense if ${atLeastCall(atLeastTimes)} was used before\"\n    }\n}\n","package ch.tutteli.atrium.domain.builders.utils\n\n/**\n * Represents a group of [T].\n */\ninterface Group<out T> {\n    /**\n     * Returns the members of the group as [List].\n     */\n    fun toList(): List<T>\n}\n\n/**\n * Represents a group of [T] (where `T: Any`) which can be converted to a [List]`<T>`\n */\n@Deprecated(\"Use super-type Group instead; will be removed with 1.0.0\", ReplaceWith(\"Group<T>\"))\ninterface GroupWithoutNullableEntries<out T> : Group<T>\n\n/**\n * Represents a group of [T] (where `T: Any?`) which can be converted to a [List]`<T>`\n */\n@Deprecated(\"Use super-type Group instead; will be removed with 1.0.0\", ReplaceWith(\"Group<T>\"))\ninterface GroupWithNullableEntries<out T : Any?> : Group<T>\n\n/**\n * Adds the given [firstGroup], the [secondGroup] and the [otherGroups] into a new [List] and returns it.\n * @return a [List] containing [firstGroup], [secondGroup] and [otherGroups].\n */\nfun <T> groupsToList(firstGroup: Group<T>, secondGroup: Group<T>, otherGroups: Array<out Group<T>>): List<List<T>> {\n    val groups = ArrayList<List<T>>(otherGroups.size + 2)\n    requireNotEmptyAndAdd(groups, firstGroup)\n    requireNotEmptyAndAdd(groups, secondGroup)\n    otherGroups.forEach { requireNotEmptyAndAdd(groups, it) }\n    return groups\n}\n\nprivate fun <T> requireNotEmptyAndAdd(groups: ArrayList<List<T>>, group: Group<T>) {\n    val list = group.toList()\n    require(list.isNotEmpty()) {\n        \"a group of values cannot be empty.\"\n    }\n    groups.add(list)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.1\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.1\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive), must be in `0..array.size`\n * @param toIndex the end of the range (exclusive), must be in `fromIndex..array.size`\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive), 0 by default.\n * @param toIndex the end of the range (exclusive), size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size)))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    val set = LinkedHashSet<Byte>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    val set = LinkedHashSet<Short>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    val set = LinkedHashSet<Int>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    val set = LinkedHashSet<Long>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    val set = LinkedHashSet<Float>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    val set = LinkedHashSet<Double>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    val set = LinkedHashSet<Boolean>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    val set = LinkedHashSet<Char>(mapCapacity(size))\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun ByteArray.max(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun ShortArray.max(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun IntArray.max(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun LongArray.max(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun FloatArray.max(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun DoubleArray.max(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    if (max.isNaN()) return max\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun CharArray.max(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun ByteArray.min(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun ShortArray.min(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun IntArray.min(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun LongArray.min(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun FloatArray.min(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\npublic fun DoubleArray.min(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    if (min.isNaN()) return min\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun CharArray.min(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package ch.tutteli.atrium.domain.builders.utils\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.creating.PleaseUseReplacementException\nimport kotlin.js.JsName\n\n/**\n * Creates a [ArgumentMapperBuilder] with the given [first] and [others] as arguments;\n * specify the mapping as such using a subsequent step in the building process.\n *\n * For instance (there are more options as second step to choose from):\n * ```\n * fun <K, V> pairs(pair: Pair<K, V>, vararg otherPairs: Pair<K, V>) {\n *   mapArguments(pair, otherPairs).toExpect<Map.Entry<K, V>> { isKeyValue(it) }\n * }\n * ```\n */\nfun <T> mapArguments(first: T, others: Array<out T>): ArgumentMapperBuilder<T> = ArgumentMapperBuilder(first, others)\n\n/**\n * Maps the given [first] and [others] to the given type [R] with the help of the given [mapper].\n *\n * Use the overload without `mapper` in case you want to map to an [Assert][AssertionPlant] lambda with receiver\n * and use one of the available options as second step. For instance, `mapArguments(a, aX).toExpect<String> { ... }`\n */\ninline fun <T, reified R> mapArguments(first: T, others: Array<out T>, mapper: (T) -> R): Pair<R, Array<out R>> =\n    mapArguments(first, others).to(mapper)\n\n/**\n * Creates a [ArgumentMapperBuilder] with the given [first] and [others] as arguments;\n * specify the mapping as such using a subsequent step in the building process.\n */\nfun mapArguments(first: Byte, others: ByteArray): ArgumentMapperBuilder<Byte> =\n    mapArguments(first, others.toTypedArray())\n\n/**\n * Maps the given [first] and [others] to the given type [R] with the help of the given [mapper].\n *\n * Use the overload without `mapper` in case you want to map to an [Assert][AssertionPlant] lambda with receiver\n * and use one of the available options as second step. For instance, `mapArguments(a, aX).toExpect<String> { ... }`\n */\ninline fun <reified R> mapArguments(first: Byte, others: ByteArray, mapper: (Byte) -> R): Pair<R, Array<out R>> =\n    mapArguments(first, others).to(mapper)\n\n/**\n * Creates a [ArgumentMapperBuilder] with the given [first] and [others] as arguments;\n * specify the mapping as such using a subsequent step in the building process.\n */\nfun mapArguments(first: Char, others: CharArray): ArgumentMapperBuilder<Char> =\n    mapArguments(first, others.toTypedArray())\n\n/**\n * Maps the given [first] and [others] to the given type [R] with the help of the given [mapper].\n *\n * Use the overload without `mapper` in case you want to map to an [Assert][AssertionPlant] lambda with receiver\n * and use one of the available options as second step. For instance, `mapArguments(a, aX).toExpect<String> { ... }`\n */\ninline fun <reified R> mapArguments(first: Char, others: CharArray, mapper: (Char) -> R): Pair<R, Array<out R>> =\n    mapArguments(first, others).to(mapper)\n\n/**\n * Creates a [ArgumentMapperBuilder] with the given [first] and [others] as arguments;\n * specify the mapping as such using a subsequent step in the building process.\n */\nfun mapArguments(first: Short, others: ShortArray): ArgumentMapperBuilder<Short> =\n    mapArguments(first, others.toTypedArray())\n\n/**\n * Maps the given [first] and [others] to the given type [R] with the help of the given [mapper].\n *\n * Use the overload without `mapper` in case you want to map to an [Assert][AssertionPlant] lambda with receiver\n * and use one of the available options as second step. For instance, `mapArguments(a, aX).toExpect<String> { ... }`\n */\ninline fun <reified R> mapArguments(first: Short, others: ShortArray, mapper: (Short) -> R): Pair<R, Array<out R>> =\n    mapArguments(first, others).to(mapper)\n\n/**\n * Creates a [ArgumentMapperBuilder] with the given [first] and [others] as arguments;\n * specify the mapping as such using a subsequent step in the building process.\n */\nfun mapArguments(first: Int, others: IntArray): ArgumentMapperBuilder<Int> = mapArguments(first, others.toTypedArray())\n\n/**\n * Maps the given [first] and [others] to the given type [R] with the help of the given [mapper].\n *\n * Use the overload without `mapper` in case you want to map to an [Assert][AssertionPlant] lambda with receiver\n * and use one of the available options as second step. For instance, `mapArguments(a, aX).toExpect<String> { ... }`\n */\ninline fun <reified R> mapArguments(first: Int, others: IntArray, mapper: (Int) -> R): Pair<R, Array<out R>> =\n    mapArguments(first, others).to(mapper)\n\n/**\n * Creates a [ArgumentMapperBuilder] with the given [first] and [others] as arguments;\n * specify the mapping as such using a subsequent step in the building process.\n */\nfun mapArguments(first: Long, others: LongArray): ArgumentMapperBuilder<Long> =\n    mapArguments(first, others.toTypedArray())\n\n/**\n * Maps the given [first] and [others] to the given type [R] with the help of the given [mapper].\n *\n * Use the overload without `mapper` in case you want to map to an [Assert][AssertionPlant] lambda with receiver\n * and use one of the available options as second step. For instance, `mapArguments(a, aX).toExpect<String> { ... }`\n */\ninline fun <reified R> mapArguments(first: Long, others: LongArray, mapper: (Long) -> R): Pair<R, Array<out R>> =\n    mapArguments(first, others).to(mapper)\n\n/**\n * Creates a [ArgumentMapperBuilder] with the given [first] and [others] as arguments;\n * specify the mapping as such using a subsequent step in the building process.\n */\nfun mapArguments(first: Float, others: FloatArray): ArgumentMapperBuilder<Float> =\n    mapArguments(first, others.toTypedArray())\n\n/**\n * Maps the given [first] and [others] to the given type [R] with the help of the given [mapper].\n *\n * Use the overload without `mapper` in case you want to map to an [Assert][AssertionPlant] lambda with receiver\n * and use one of the available options as second step. For instance, `mapArguments(a, aX).toExpect<String> { ... }`\n */\ninline fun <reified R> mapArguments(first: Float, others: FloatArray, mapper: (Float) -> R): Pair<R, Array<out R>> =\n    mapArguments(first, others).to(mapper)\n\n/**\n * Creates a [ArgumentMapperBuilder] with the given [first] and [others] as arguments;\n * specify the mapping as such using a subsequent step in the building process.\n */\nfun mapArguments(first: Double, others: DoubleArray): ArgumentMapperBuilder<Double> =\n    mapArguments(first, others.toTypedArray())\n\n/**\n * Maps the given [first] and [others] to the given type [R] with the help of the given [mapper].\n *\n * Use the overload without `mapper` in case you want to map to an [Assert][AssertionPlant] lambda with receiver\n * and use one of the available options as second step. For instance, `mapArguments(a, aX).toExpect<String> { ... }`\n */\ninline fun <reified R> mapArguments(first: Double, others: DoubleArray, mapper: (Double) -> R): Pair<R, Array<out R>> =\n    mapArguments(first, others).to(mapper)\n\n/**\n * Creates a [ArgumentMapperBuilder] with the given [first] and [others] as arguments;\n * specify the mapping as such using a subsequent step in the building process.\n */\nfun mapArguments(first: Boolean, others: BooleanArray): ArgumentMapperBuilder<Boolean> =\n    mapArguments(first, others.toTypedArray())\n\n/**\n * Maps the given [first] and [others] to the given type [R] with the help of the given [mapper].\n *\n * Use the overload without `mapper` in case you want to map to an [Assert][AssertionPlant] lambda with receiver\n * and use one of the available options as second step. For instance, `mapArguments(a, aX).toExpect<String> { ... }`\n */\ninline fun <reified R> mapArguments(\n    first: Boolean,\n    others: BooleanArray,\n    mapper: (Boolean) -> R\n): Pair<R, Array<out R>> = mapArguments(first, others).to(mapper)\n\n/**\n * Builder to map variable length arguments formulated as ([first]: [T], `vararg` [others] : [T]) to something else.\n */\nclass ArgumentMapperBuilder<out T>(\n    val first: T,\n    val others: Array<out T>\n) {\n\n    /**\n     * Maps each argument to an [Expect]&lt;[R]&gt; lambda with receiver\n     * using the given [assertionCreator] (passing in the argument).\n     *\n     * @returns The mapped [first] and [others].\n     */\n    inline fun <reified R> toExpect(\n        crossinline assertionCreator: Expect<R>.(T) -> Unit\n    ): Pair<Expect<R>.() -> Unit, Array<out Expect<R>.() -> Unit>> = to { t -> subExpect<R> { assertionCreator(t) } }\n\n    /**\n     * Maps each argument to an [Assert][AssertionPlant]&lt;[R]&gt; lambda with receiver\n     * using the given [assertionCreator] (passing in the argument).\n     *\n     * @returns The mapped [first] and [others].\n     */\n    @Deprecated(\"Switch from Assert to Expect and use toExpect instead; will be removed with 1.0.0\")\n    inline fun <reified R : Any> toAssert(\n        crossinline assertionCreator: Assert<R>.(T) -> Unit\n    ): Pair<Assert<R>.() -> Unit, Array<out Assert<R>.() -> Unit>> = to { t -> subAssert<R> { assertionCreator(t) } }\n\n    /**\n     * Maps each argument to an [AssertionPlantNullable]&lt;[R]&gt; lambda with receiver by\n     * using the given [assertionCreator] (passing in the argument).\n     *\n     * Notice, a future version might constrain [T] with a lower bound `Nothing?`.\n     *\n     * @returns The mapped [first] and [others].\n     */\n    @Deprecated(\"Switch from Assert to Expect and use toExpect instead; will be removed with 1.0.0\")\n    inline fun <reified R> toAssertionPlantNullable(\n        crossinline assertionCreator: AssertionPlantNullable<R>.(T) -> Unit\n    ): Pair<AssertionPlantNullable<R>.() -> Unit, Array<out AssertionPlantNullable<R>.() -> Unit>> =\n        to { t -> subAssertNullable<R> { assertionCreator(t) } }\n\n    /**\n     * Maps each argument to the given type [R] by using the given [mapper]\n     *\n     * @returns The mapped [first] and [others].\n     */\n    inline fun <reified R> to(mapper: (T) -> R): Pair<R, Array<out R>> =\n        mapper(first) to others.map { mapper(it) }.toTypedArray()\n}\n\n/**\n * Maps each argument to `null` if it is already `null` and if not, then ...\n *\n * ... what happens otherwise needs to be specified in the next step.\n *\n * Notice, a future version might constrain [T] with a lower bound `Nothing?`.\n *\n * @returns The mapped [ArgumentMapperBuilder.first] and [ArgumentMapperBuilder.others].\n */\nfun <T : Any> ArgumentMapperBuilder<T?>.toNullOr(): ArgumentToNullOrMapperBuilder<T> =\n    ArgumentToNullOrMapperBuilder(this)\n\n@JsName(\"deprecatedToNullOr\")\n@Suppress(\"unused\")\n@Deprecated(\n    \"Since your arguments are not nullable it does not make sense to call this function - use the replacement.\",\n    ReplaceWith(\"toExpect(assertionCreator)\")\n)\nfun <T : Any> ArgumentMapperBuilder<T>.toNullOr(): Nothing =\n    throw PleaseUseReplacementException(\"Since your arguments are not nullable it does not make sense to call this function.\")\n\n/**\n * Builder to map variable length arguments formulated as `(first: T, vararg others : T)` to something else.\n *\n * Its usage is intended to turn the nullable argument type of the given [argumentMapperBuilder] into its non-nullable\n * type if the argument is not null in order that the non-nullable type can be used/passed to function which expect\n * a non-nullable type.\n */\nclass ArgumentToNullOrMapperBuilder<T : Any>(\n    val argumentMapperBuilder: ArgumentMapperBuilder<T?>\n) {\n    /**\n     * Maps each argument to `null` if it is already `null` and if not, then to an [Expect]&lt;[R]&gt;\n     * lambda with receiver by using the given [assertionCreator] (passing in the argument).\n     *\n     * @returns The mapped arguments.\n     */\n    inline fun <R : Any> toExpect(\n        crossinline assertionCreator: Expect<R>.(T) -> Unit\n    ): Pair<(Expect<R>.() -> Unit)?, Array<out (Expect<R>.() -> Unit)?>> =\n        argumentMapperBuilder.to { nullableT -> nullableT?.let { t -> subExpect<R> { assertionCreator(t) } } }\n\n    /**\n     * Maps each argument to `null` if it is already `null` and if not, then to an [AssertionPlantNullable]&lt;[R]&gt;\n     * lambda with receiver by using the given [assertionCreator] (passing in the argument).\n     *\n     * @returns The mapped arguments.\n     */\n    @Deprecated(\"Switch from Assert to Expect and use toExpect instead; will be removed with 1.0.0\")\n    inline fun <R : Any> toAssert(\n        crossinline assertionCreator: Assert<R>.(T) -> Unit\n    ): Pair<(Assert<R>.() -> Unit)?, Array<out (Assert<R>.() -> Unit)?>> =\n        argumentMapperBuilder.to { nullableT -> nullableT?.let { t -> subAssert<R> { assertionCreator(t) } } }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.utils\n\nimport kotlin.jvm.JvmName\nimport kotlin.reflect.*\n\n\n/**\n * Turns the given type into a nullable type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `String!` or in other words, when you deal with Java and you want to turn a platform type into a nullable type.\n *\n * Basically it is a replacement for cast but without introducing one explicitly (we only give an additional hint to the\n * compiler that we expect a nullable type and not a non-nullable one). For instance, instead of writing\n * `getPersons() as List<String>?` you can write `nullable(getPersons())`\n */\ninline fun <T> nullable(t: T): T? = t\n\n/**\n * Turns the given function reference into a function reference with a nullable return type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `String!` or in other words, when you deal with Java and you want to turn the return type (which is a platform\n * type) of your function into a nullable type.\n */\ninline fun <T> nullable(t: KFunction0<T>): KFunction0<T?> = t\n\n/**\n * Turns an [Iterable] into an iterable with a nullable element type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `Iterable<String!>` or in other words, when you deal with Java and you want to turn a platform type into a nullable type.\n *\n * Basically it is a replacement for cast but without introducing one explicitly (we only give an additional hint to the\n * compiler that we expect a nullable type and not a non-nullable one). For instance, instead of writing\n * `getPersons() as Iterable<String?>` you can write `nullableContainer(getPersons())`\n */\ninline fun <T> nullableContainer(iterable: Iterable<T>): Iterable<T?> = iterable\n\n/**\n * Turns an [Array] into an array with a nullable element type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `Array<String!>` or in other words, when you deal with Java and you want to turn a platform type into a nullable type.\n *\n * Basically it is a replacement for cast but without introducing one explicitly (we only give an additional hint to the\n * compiler that we expect a nullable type and not a non-nullable one). For instance, instead of writing\n * `getPersons() as Array<String?>` you can write `nullableContainer(getPersons())`\n */\ninline fun <T> nullableContainer(arr: Array<out T>): Array<out T?> = arr\n\n\n/**\n * Turns a [Map] into a map with a nullable key type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `Map<Int!, `String!`>! or in other words, when you deal with Java and you want to turn a platform type into a\n * nullable type.\n *\n * Basically it is a replacement for cast but without introducing one explicitly (we only give an additional hint to the\n * compiler that we expect a nullable type and not a non-nullable one). For instance, instead of writing\n * `getPersons() as Map<String?, Person>` you can write `nullableKeyMap(getPersons())`\n */\ninline fun <K, V : Any> nullableKeyMap(map: Map<out K, V>): Map<out K?, V> = map\n\n/**\n * Turns a [Map] into a map with a nullable value type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `Map<Int!, `String!`>! or in other words, when you deal with Java and you want to turn a platform type into a\n * nullable type.\n *\n * Basically it is a replacement for cast but without introducing one explicitly (we only give an additional hint to the\n * compiler that we expect a nullable type and not a non-nullable one). For instance, instead of writing\n * `getPersons() as Map<String, Person?>` you can write `nullableValueMap(getPersons())`\n */\ninline fun <K : Any, V> nullableValueMap(map: Map<K, V>): Map<K, V?> = map\n\n/**\n * Turns a [Map] into a map with a nullable key and a nullable value type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `Map<Int!, `String!`>! or in other words, when you deal with Java and you want to turn a platform type into a\n * nullable type.\n *\n * Basically it is a replacement for cast but without introducing one explicitly (we only give an additional hint to the\n * compiler that we expect a nullable type and not a non-nullable one). For instance, instead of writing\n * `getPersons() as Map<String?, Person?>` you can write `nullableKeyValueMap(getPersons())`\n */\ninline fun <K, V> nullableKeyValueMap(map: Map<out K, V>): Map<out K?, V?> = map\n\n/**\n * Turns the given function reference into a function reference with a nullable return type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `String!` or in other words, when you deal with Java and you want to turn the return type (which is a platform\n * type) of your function into a nullable type.\n */\n@JvmName(\"nullable1\")\ninline fun <T1, R> nullable(t: KFunction1<T1, R>): KFunction1<T1, R?> = t\n\n/**\n * Turns the given function reference into a function reference with a nullable return type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `String!` or in other words, when you deal with Java and you want to turn the return type (which is a platform\n * type) of your function into a nullable type.\n */\n@JvmName(\"nullable2\")\ninline fun <T1, T2, R> nullable(t: KFunction2<T1, T2, R>): KFunction2<T1, T2, R?> = t\n\n/**\n * Turns the given function reference into a function reference with a nullable return type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `String!` or in other words, when you deal with Java and you want to turn the return type (which is a platform\n * type) of your function into a nullable type.\n */\n@JvmName(\"nullable3\")\ninline fun <T1, T2, T3, R> nullable(t: KFunction3<T1, T2, T3, R>): KFunction3<T1, T2, T3, R?> = t\n\n/**\n * Turns the given function reference into a function reference with a nullable return type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `String!` or in other words, when you deal with Java and you want to turn the return type (which is a platform\n * type) of your function into a nullable type.\n */\n@JvmName(\"nullable4\")\ninline fun <T1, T2, T3, T4, R> nullable(t: KFunction4<T1, T2, T3, T4, R>): KFunction4<T1, T2, T3, T4, R?> = t\n\n/**\n * Turns the given function reference into a function reference with a nullable return type.\n *\n * Intended to be used in conjunction with [platform types](https://kotlinlang.org/docs/reference/java-interop.html#notation-for-platform-types)\n * such as `String!` or in other words, when you deal with Java and you want to turn the return type (which is a platform\n * type) of your function into a nullable type.\n */\n@JvmName(\"nullable5\")\ninline fun <T1, T2, T3, T4, T5, R> nullable(t: KFunction5<T1, T2, T3, T4, T5, R>): KFunction5<T1, T2, T3, T4, T5, R?> =\n    t\n","package ch.tutteli.atrium.domain.builders.utils\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\n\n/**\n * Helper function to create an  [Assert&lt;T&gt;][AssertionPlant] lambda with receiver;\n * helps to circumvent Kotlin type inference bugs involving lambdas.\n *\n * Following a few examples of bugs (you might want to vote if you encounter the same):\n * - https://youtrack.jetbrains.com/issue/KT-24230\n * - https://youtrack.jetbrains.com/issue/KT-23883\n * - and probably more\n *\n * @param assertionCreator Your assertion creator lambda.\n * @return your passed lambda.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun <T : Any> subAssert(noinline assertionCreator: Assert<T>.() -> Unit) = assertionCreator\n\n\n/**\n * Helper function to create an [AssertionPlantNullable] lambda with receiver;\n * helps to circumvent Kotlin type inference bugs involving lambdas.\n *\n * Following a few examples of bugs (you might want to vote if you encounter the same):\n * - https://youtrack.jetbrains.com/issue/KT-24230\n * - https://youtrack.jetbrains.com/issue/KT-23883\n * - and probably more\n *\n * @param assertionCreator Your assertion creator lambda.\n * @return your passed lambda.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun <T> subAssertNullable(noinline assertionCreator: AssertionPlantNullable<T>.() -> Unit) =\n    assertionCreator\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninline fun <T> subExpect(noinline assertionCreator: Expect<T>.() -> Unit) = assertionCreator\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.FloatingPointAssertions\nimport ch.tutteli.atrium.domain.creating.floatingPointAssertions\n\n/**\n * Delegates inter alia to the implementation of [FloatingPointAssertions].\n * In detail, it implements [FloatingPointAssertions] by delegating to [floatingPointAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nactual object FloatingPointAssertionsBuilder : FloatingPointAssertions {\n\n    override inline fun toBeWithErrorTolerance(\n        subjectProvider: SubjectProvider<Float>,\n        expected: Float,\n        tolerance: Float\n    ) = floatingPointAssertions.toBeWithErrorTolerance(subjectProvider, expected, tolerance)\n\n    override inline fun toBeWithErrorTolerance(\n        subjectProvider: SubjectProvider<Double>,\n        expected: Double,\n        tolerance: Double\n    ) = floatingPointAssertions.toBeWithErrorTolerance(subjectProvider, expected, tolerance)\n}\n","@file:Suppress(\"DEPRECATION\")\n\npackage ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.core.polyfills.registerService\n\n@Suppress(\"unused\" /* here in order that the code is executed when module is loaded */)\nprivate val register = run {\n\n    registerService<ch.tutteli.atrium.reporting.ReporterFactory> { ch.tutteli.atrium.domain.builders.reporting.impl.DefaultReporterFactory() }\n}\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.domain.builders.reporting.impl.ReporterBuilderImpl\nimport ch.tutteli.atrium.reporting.translating.TranslationSupplier\nimport ch.tutteli.atrium.reporting.translating.Translator\n\n/**\n * Provides options to create a [Translator] or [TranslationSupplier].\n */\nactual interface ReporterBuilder : ReporterBuilderCommon {\n    actual companion object {\n        actual fun create(): ReporterBuilder = ReporterBuilderImpl\n    }\n}\n","package ch.tutteli.atrium.domain.builders.reporting\n\nimport ch.tutteli.atrium.domain.builders.reporting.impl.TextAssertionFormatterOptionImpl\nimport ch.tutteli.atrium.reporting.AssertionFormatter\nimport ch.tutteli.atrium.reporting.AssertionFormatterFacade\nimport ch.tutteli.atrium.reporting.AssertionPairFormatter\n\n/**\n * Provides options to register [AssertionFormatter]s to the chosen [AssertionFormatterFacade].\n */\nactual interface TextAssertionFormatterOption : TextAssertionFormatterOptionCommon {\n\n    actual companion object {\n        actual fun create(\n            options: AssertionFormatterChosenOptions,\n            assertionPairFormatter: AssertionPairFormatter\n        ): TextAssertionFormatterOption = TextAssertionFormatterOptionImpl(options, assertionPairFormatter)\n    }\n}\n\n","package ch.tutteli.atrium.domain.builders.reporting.impl\n\nimport ch.tutteli.atrium.domain.builders.reporting.LocaleOrderDeciderOption\nimport ch.tutteli.atrium.domain.builders.reporting.ObjectFormatterOption\nimport ch.tutteli.atrium.domain.builders.reporting.ReporterBuilder\nimport ch.tutteli.atrium.reporting.translating.Locale\nimport ch.tutteli.atrium.reporting.translating.TranslationSupplier\nimport ch.tutteli.atrium.reporting.translating.Translator\nimport ch.tutteli.atrium.reporting.translating.UsingDefaultTranslator\n\ninternal actual object ReporterBuilderImpl : ReporterBuilder {\n\n    override fun withoutTranslations(primaryLocale: Locale) = withTranslator(UsingDefaultTranslator(primaryLocale))\n\n    override fun withTranslator(translator: Translator) = ObjectFormatterOption.create(translator)\n\n    override fun withDefaultTranslationSupplier() = TODO(\"we have to implement a translation supplier for JS\")\n\n    override fun withTranslationSupplier(translationSupplier: TranslationSupplier) =\n        LocaleOrderDeciderOption.create(translationSupplier)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;eAeI,a;;;;;;;;;;;;;;;;;;;;;;;;oBCDJ,qC;;;;;;;;;;;;;;;;;;;sCCWA,mD;;uBC0DA,+C;;;;;qBClEA,oD;;;;;;;;;;;;;wBCDA,mF;;iCCOA,iC;;;ECJA,sB;IAAA,0B;G;;oHAOgC,yB;MAAA,iG;MAAA,mB;QAAQ,gC;O;KAAR,C;;;sHAEE,yB;MAAA,wE;MAAA,mB;QAAQ,2C;O;KAAR,C;;;wHAEE,yB;MAAA,8E;MAAA,mB;QAAQ,OAAuB,gB;O;KAA/B,C;;;gHAKR,yB;MAAA,2D;MAAA,mB;QAAQ,oC;O;KAAR,C;;;yHAES,yB;MAAA,2D;MAAA,mB;QAAQ,6C;O;KAAR,C;;;uHAEF,yB;MAAA,2D;MAAA,mB;QAAQ,2C;O;KAAR,C;;;uHAEA,yB;MAAA,2D;MAAA,mB;QAAQ,2C;O;KAAR,C;;;oHAGH,yB;MAAA,2D;MAAA,mB;QAAQ,wC;O;KAAR,C;;;0HAEM,yB;MAAA,2D;MAAA,mB;QAAQ,8C;O;KAAR,C;;;qHAEL,yB;MAAA,2D;MAAA,mB;QAAQ,yC;O;KAAR,C;;;iHAEJ,yB;MAAA,2D;MAAA,mB;QAAQ,qC;O;KAAR,C;;;gHAED,yB;MAAA,2D;MAAA,mB;QAAQ,oC;O;KAAR,C;;;iHAEC,yB;MAAA,2D;MAAA,mB;QAAQ,qC;O;KAAR,C;;;sHAEK,yB;MAAA,2D;MAAA,mB;QAAQ,0C;O;KAAR,C;;;;;;;;EArClC,kC;IAAA,iC;MAAA,gB;;IAAA,0B;G;;;EAoF4E,wE;IAAA,qB;MAAE,gC;IAAkB,C;G;qDAtB5F,0C;IAsBuB,OAAA,uBAAe,4BAAmB,aAAnB,EAAkC,sDAAlC,C;G;qDAEtC,oD;IAUe,OAAA,uBAAe,oBAAW,wBAAX,EAAqC,cAArC,C;G;EAuB0D,kF;IAAA,qB;MAAE,gC;IAAkB,C;G;+DArB5G,0C;IAqB+B,OAAA,uBAAe,oCAA2B,aAA3B,EAA0C,gEAA1C,C;G;+DAE9C,oD;IAUe,kCAAc,wBAAd,EAAwC,cAAxC,C;G;;;;;;ECxInB,sB;IAAA,0B;G;;oHAYuB,yB;MAAA,iG;MAAA,mB;QA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,WxEv/R2D,CyEmM9D,C;K;GA7ER,C;EASA,wC;IAKI,oBAAa,KAAb,EAA2B,eAAP,MAAO,CAA3B,C;G;uIAEJ,yB;IAAA,iF;IAuDI,iC;IDo+QJ,qE;IxElqRA,uD;IyEuIA,kD;MAUuD,YAA5B,aAAa,KAAb,EAAoB,MAApB,C;MAmDnB,WAnDkD,MAmDlD,CAAO,WAAP,C;MAAwB,gBAAP,Y;MDq+Qd,kBAAM,eAAa,gBAAb,C;MA6UA,U;MAAb,uD;QAAa,WAAb,iB;QACI,WAAY,WCt2RsC,MAmDpB,CDmzRJ,ICnzRI,CDmzRlB,C;;MCt2RO,OAmDnB,SzEnM8D,YwEu/R3D,WxEv/R2D,CyEmM9D,C;K;GA7DR,C;EAekC,8C;IAC9B,kB;IACA,oB;G;sLAGA,yB;IAAA,6B;IAmCA,iC;IDo+QJ,qE;IxElqRA,uD;IyEmK4F,2F;MAAA,4B;QAAE,oCAAiB,SAAjB,C;QAAoB,W;MAAA,C;K;IAR9G,6C;MAyCI,WAjCoF,+DAiC7E,UAjC6E,C;MAiC5D,gBAAP,W;MDq+Qd,kBAAM,eAAa,gBAAb,C;MA6UA,U;MAAb,uD;QAAa,WAAb,iB;QACI,WAAY,WCp1RwE,+DDo1R1D,ICp1R0D,CDo1RxE,C;;MCp1RiD,OAiC7D,SzEnM8D,YwEu/R3D,WxEv/R2D,CyEmM9D,C;K;GAzCJ,C;sLAUA,yB;IAAA,6B;IAyBA,iC;IDo+QJ,qE;IxElqRA,uD;IyE8K4F,2F;MAAA,4B;QAAE,oCAAiB,SAAjB,C;QAAoB,W;MAAA,C;K;IAT9G,6C;MA+BI,WAtBoF,+DAsB7E,UAtB6E,C;MAsB5D,gBAAP,W;MDq+Qd,kBAAM,eAAa,gBAAb,C;MA6UA,U;MAAb,uD;QAAa,WAAb,iB;QACI,WAAY,WCz0RwE,+DDy0R1D,ICz0R0D,CDy0RxE,C;;MCz0RiD,OAsB7D,SzEnM8D,YwEu/R3D,WxEv/R2D,CyEmM9D,C;K;GA/BJ,C;sNAWA,yB;IAAA,6B;IAcA,iC;IDo+QJ,qE;IxElqRA,uD;IyE4LuC,2G;MAAA,4B;QAAE,oCAAiB,SAAjB,C;QAAoB,W;MAAA,C;K;IAZzD,6C;MAoBI,WAR+B,+EAQxB,UARwB,C;MAQP,gBAAP,W;MDq+Qd,kBAAM,eAAa,gBAAb,C;MA6UA,U;MAAb,uD;QAAa,WAAb,iB;QACI,WAAY,WC3zRmB,+ED2zRL,IC3zRK,CD2zRnB,C;;MC3zRZ,OAQA,SzEnM8D,YwEu/R3D,WxEv/R2D,CyEmM9D,C;K;GApBJ,C;0KAcA,yB;IAAA,iC;IDo+QJ,qE;IxElqRA,uD;IyE8LI,mC;MAMI,kBAAO,UAAP,C;MAAwB,gBAAP,W;MDq+Qd,kBAAM,eAAa,gBAAb,C;MA6UA,U;MAAb,uD;QAAa,WAAb,iB;QACI,WAAY,WCnzRkB,ODmzRJ,ICnzRI,CDmzRlB,C;;MCnzRZ,gBzEnM8D,YwEu/R3D,WxEv/R2D,CyEmM9D,C;K;GANJ,C;;;;;;EASJ,6B;IAUI,yCAA8B,SAA9B,C;G;EAEJ,6B;IAOI,MAAM,kCAA8B,qFAA9B,C;G;EASkC,8D;IACxC,kD;G;sMAEA,yB;IAAA,6B;IAxCA,iC;IDo+QJ,qE;IxElqRA,uD;IyE+OmF,0G;MAAA,4B;QAAE,oCAAiB,SAAjB,C;QAAoB,W;MAAA,C;K;IATrG,mC;MAS0B,YAAtB,0B;MA3CA,gBAAO,W;MAAP,WA2CwC,SA3CxC,WA2C2E,8EAAnC,SAAmC,CA3C3E,O;MAAwB,gBAAP,Y;MDq+Qd,kBAAM,eAAa,gBAAb,C;MA6UA,U;MAAb,uD;QAAa,WAAb,iB;QACI,WAAY,WAAc,IAAd,WCxwR+D,8EDwwRjD,ICxwRiD,CDwwR/D,Q;;MCxwRZ,OA3CA,SzEnM8D,YwEu/R3D,WxEv/R2D,CyEmM9D,C;K;GAkCJ,C;sMAWA,yB;IAAA,6B;IAnDA,iC;IDo+QJ,qE;IxElqRA,uD;IyE2PmF,0G;MAAA,4B;QAAE,oCAAiB,SAAjB,C;QAAoB,W;MAAA,C;K;IAVrG,mC;MAU0B,YAAtB,0B;MAvDA,gBAAO,W;MAAP,WAuDwC,SAvDxC,WAuD2E,8EAAnC,SAAmC,CAvD3E,O;MAAwB,gBAAP,Y;MDq+Qd,kBAAM,eAAa,gBAAb,C;MA6UA,U;MAAb,uD;QAAa,WAAb,iB;QACI,WAAY,WAAc,IAAd,WC5vR+D,8ED4vRjD,IC5vRiD,CD4vR/D,Q;;MC5vRZ,OAvDA,SzEnM8D,YwEu/R3D,WxEv/R2D,CyEmM9D,C;K;GA6CJ,C;;;;;;4HCvPJ,a;IAUoC,Q;G;8HAEpC,a;IAO4D,Q;G;8IAE5D,oB;IAUwE,e;G;gJAExE,e;IAUqE,U;G;wIAGrE,e;IAW6E,U;G;4IAE7E,e;IAWuE,U;G;kJAEvE,e;IAW6E,U;G;8HAE7E,a;IAQwE,Q;G;8HAExE,a;IAQoF,Q;G;8HAEpF,a;IAQgG,Q;G;8HAEhG,a;IAQ4G,Q;G;8HAE5G,a;IASI,Q;G;8HCvIJ,4B;IAakF,uB;G;6IAGlF,4B;IAcI,uB;G;8HAEJ,4B;IAC4E,uB;G;EC/B5E,0C;IAAA,8C;G;uOAOI,yB;IAAA,+F;IAAA,uD;MAII,OAAA,gCAAwB,gCAAuB,eAAvB,EAAwC,QAAxC,EAAkD,SAAlD,C;K;GAJ5B,C;uOAMA,yB;IAAA,+F;IAAA,uD;MAII,OAAA,gCAAwB,gCAAuB,eAAvB,EAAwC,QAAxC,EAAkD,SAAlD,C;K;GAJ5B,C;;;;;;;EAbJ,sD;IAAA,qD;MAAA,oC;;IAAA,8C;G;ECAiE,kC;IAAE,OAAiD,4B;EAAyB,C;;;ICCzI,uC;;EAAA,qC;IAAA,yC;G;+CACI,Y;IAAuC,wC;G;;;;;;;EAD3C,iD;IAAA,gD;MAAA,+B;;IAAA,yC;G;;;;;;;ICEA,oD;;EAAA,kD;IAAA,sD;G;oEACI,2C;IAGkC,4CAAiC,OAAjC,EAA0C,sBAA1C,C;G;;;;;;;EAJtC,8D;IAAA,6D;MAAA,4C;;IAAA,sD;G;;;;;;;;;;;;;ECFJ,+B;IAAA,mC;G;6DAEI,yB;IAA0D,mCAAe,2BAAuB,aAAvB,CAAf,C;G;yDAE1D,sB;IAAsD,OAAA,6CAAsB,gBAAO,UAAP,C;G;iEAE5E,Y;I3Ea8C,MAAM,6BAAoB,sC2EbnB,oD3EaD,C;G;kE2EXpD,+B;IACI,OAAA,gDAAyB,gBAAO,mBAAP,C;G;;;;;;;EATjC,2C;IAAA,0C;MAAA,yB;;IAAA,mC;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oB7BIuC,iC;E/CKmC,4CyEVT,sBzEUS,C;;;;;"}