<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>symbolicLinkResolving.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">atrium-api-cc-infix-en_GB-jvm</a> &gt; <a href="index.source.html" class="el_package">ch.tutteli.atrium.domain.robstoll.lib.creating.filesystem</a> &gt; <span class="el_source">symbolicLinkResolving.kt</span></div><h1>symbolicLinkResolving.kt</h1><pre class="source lang-java linenums">package ch.tutteli.atrium.domain.robstoll.lib.creating.filesystem

import ch.tutteli.atrium.assertions.Assertion
import ch.tutteli.atrium.assertions.AssertionGroup
import ch.tutteli.atrium.assertions.builders.withExplanatoryAssertion
import ch.tutteli.atrium.domain.builders.ExpectImpl
import ch.tutteli.atrium.translations.DescriptionPathAssertion.FAILURE_DUE_TO_LINK_LOOP
import ch.tutteli.atrium.translations.DescriptionPathAssertion.HINT_FOLLOWED_SYMBOLIC_LINK
import ch.tutteli.niok.followSymbolicLink
import java.io.IOException
import java.nio.file.Path
import java.util.*

inline fun explainForResolvedLink(path: Path, resolvedPathAssertionProvider: (realPath: Path) -&gt; Assertion): Assertion {
<span class="nc" id="L15">    val hintList = LinkedList&lt;Assertion&gt;()</span>
<span class="nc" id="L16">    val realPath = addAllLevelResolvedSymlinkHints(path, hintList)</span>
<span class="nc" id="L17">    val resolvedPathAssertion = resolvedPathAssertionProvider(realPath)</span>
<span class="nc bnc" id="L18" title="All 4 branches missed.">    return if (hintList.isNotEmpty()) {</span>
<span class="nc" id="L19">        when (resolvedPathAssertion) {</span>
            //TODO this should be done differently
<span class="nc bnc" id="L21" title="All 2 branches missed.">            is AssertionGroup -&gt; hintList.addAll(resolvedPathAssertion.assertions)</span>
<span class="nc" id="L22">            else -&gt; hintList.add(resolvedPathAssertion)</span>
        }
<span class="nc" id="L24">        ExpectImpl.builder.explanatoryGroup.withDefaultType</span>
<span class="nc" id="L25">            .withAssertions(hintList)</span>
<span class="nc" id="L26">            .build()</span>
    } else {
<span class="nc" id="L28">        resolvedPathAssertion</span>
    }
}

/**
 * Resolves the provided [path] and returns the resolved target (if resolving is possible).
 * Adds explanatory hints for all involved symbolic links to [hintList].
 */
@PublishedApi
internal fun addAllLevelResolvedSymlinkHints(path: Path, hintList: Deque&lt;Assertion&gt;): Path {
<span class="nc" id="L38">    val absolutePath = path.toAbsolutePath().normalize()</span>
<span class="nc" id="L39">    return addAllLevelResolvedSymlinkHints(absolutePath, hintList, Stack())</span>
}

private fun addAllLevelResolvedSymlinkHints(
    absolutePath: Path,
    hintList: Deque&lt;Assertion&gt;,
    loopDetection: Stack&lt;Path&gt;
): Path {
<span class="nc" id="L47">    var currentPath = absolutePath.root</span>

<span class="nc bnc" id="L49" title="All 2 branches missed.">    for (part in absolutePath) {</span>
<span class="nc" id="L50">        currentPath = currentPath.resolve(part)</span>

<span class="nc" id="L52">        val loopDetectionIndex = loopDetection.indexOf(currentPath)</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">        if (loopDetectionIndex != -1) {</span>
            // add to the list so [hintForLinkLoop] prints this duplicate twice
<span class="nc" id="L55">            loopDetection.add(currentPath)</span>
<span class="nc" id="L56">            hintList.add(hintForLinkLoop(loopDetection, loopDetectionIndex))</span>
<span class="nc" id="L57">            return absolutePath</span>
        }

<span class="nc" id="L60">        val nextPathAfterFollowSymbolicLink = addOneStepResolvedSymlinkHint(currentPath, hintList)</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">        if (nextPathAfterFollowSymbolicLink != null) {</span>
<span class="nc" id="L62">            loopDetection.push(currentPath)</span>
<span class="nc" id="L63">            currentPath = addAllLevelResolvedSymlinkHints(nextPathAfterFollowSymbolicLink, hintList, loopDetection)</span>
<span class="nc" id="L64">            loopDetection.pop()</span>
        }
    }
<span class="nc" id="L67">    return currentPath</span>
}

/**
 * If [absolutePath] is surely a symlink, adds an explanatory hint to [hintList] and returns the link target.
 * Return `null` and does not modify [hintList] otherwise.
 */
private fun addOneStepResolvedSymlinkHint(absolutePath: Path, hintList: Deque&lt;Assertion&gt;): Path? {
    // we use try-catch as a control flow structure, where within the try we assume [absolutePath] to be a symbolic link
<span class="nc" id="L76">    return try {</span>
<span class="nc" id="L77">        val nextPath = absolutePath</span>
<span class="nc" id="L78">            .resolveSibling(absolutePath.followSymbolicLink())</span>
<span class="nc" id="L79">            .normalize()</span>

<span class="nc" id="L81">        hintList.add(</span>
<span class="nc" id="L82">            ExpectImpl.builder.explanatory</span>
<span class="nc" id="L83">                .withExplanation(HINT_FOLLOWED_SYMBOLIC_LINK, absolutePath, nextPath)</span>
<span class="nc" id="L84">                .build()</span>
        )
<span class="nc" id="L86">        nextPath</span>
<span class="nc" id="L87">    } catch (e: IOException) {</span>
        // either this is not a link, or we cannot check it. The best we can do is assume it is not a link.
<span class="nc" id="L89">        null</span>
    }
}

private fun hintForLinkLoop(loop: List&lt;Path&gt;, startIndex: Int): Assertion {
<span class="nc" id="L94">    val loopRepresentation = loop.subList(startIndex, loop.size).joinToString(&quot; -&gt; &quot;)</span>
<span class="nc" id="L95">    return ExpectImpl.builder.explanatoryGroup.withWarningType</span>
<span class="nc" id="L96">        .withExplanatoryAssertion(FAILURE_DUE_TO_LINK_LOOP, loopRepresentation)</span>
<span class="nc" id="L97">        .build()</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>