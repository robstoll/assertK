{"version":3,"file":"atrium-api-cc-infix-en_GB-js.js","sources":["../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/AssertImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/anyAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/ExpectImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charSequenceAssertionsBuilders.kt","generated/_Collections.kt","text/regex/RegexExtensions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/FeatureAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterableAssertionsBuilders.kt","../../../../../kbox-common/src/main/kotlin/ch/tutteli/kbox/varargToList.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/throwableAssertionsBuilders.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/anyAssertions.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/arrayAssertions.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/charSequenceAssertions.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/charSequenceContainsCheckers.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/charSequenceContainsCreators.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/charSequenceContainsSearchBehaviours.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/collectionAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/CollectionAssertionsBuilder.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/comparableAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ComparableAssertionsBuilder.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/charsequence/contains/builders/impl/AtLeastCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/charsequence/contains/builders/impl/AtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/charsequence/contains/builders/impl/ButAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/charsequence/contains/builders/impl/ExactlyCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/charsequence/contains/builders/impl/NotCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/charsequence/contains/builders/impl/NotOrAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/charsequence/contains/builders/impl/nameContainsNotFun.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/iterable/contains/builders/impl/AtLeastCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/iterable/contains/builders/impl/AtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/iterable/contains/builders/impl/ButAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/iterable/contains/builders/impl/ExactlyCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/iterable/contains/builders/impl/NotCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/iterable/contains/builders/impl/NotOrAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/iterable/contains/builders/impl/nameContainsNotFun.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/list/get/builders/ListGetNullableOption.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/list/get/builders/ListGetOption.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/list/get/builders/impl/ListGetNullableOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ListAssertionsBuilder.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/list/get/builders/impl/ListGetOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/map/get/builders/MapGetNullableOption.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/map/get/builders/MapGetOption.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/map/get/builders/impl/MapGetNullableOptionImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapAssertionsBuilder.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/creating/map/get/builders/impl/MapGetOptionImpl.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/featureAssertions.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/iterableAssertions.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/iterableContainsCheckers.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/iterableContainsInAnyOrderCreators.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/iterableContainsInAnyOrderOnlyCreators.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/iterableContainsInOrderOnlyCreators.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/iterableContainsInOrderOnlyGroupedCreators.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/iterableContainsSearchBehaviours.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/keywords/keywords.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/listAssertions.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/mapAssertions.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/mapEntryAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapEntryAssertionsBuilder.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/pairAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/PairAssertionsBuilder.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/parameterObjects.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/sequenceAssertions.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/throwableAssertions.kt","../../../../../atrium-api-cc-infix-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/infix/en_GB/typeTransformationAssertions.kt"],"sourcesContent":["@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.BaseAssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.subjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give users of Atrium a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\")\nobject AssertImpl : AssertImplCommon {\n\n    override inline val builder get() = assertionBuilder\n\n    override inline val collector get() = AssertionCollectorBuilder\n\n    override inline val coreFactory get() = ch.tutteli.atrium.core.coreFactory\n\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    override inline val any get() = AnyAssertionsBuilder\n\n    override inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    override inline val collection get() = CollectionAssertionsBuilder\n\n    override inline val comparable get() = ComparableAssertionsBuilder\n\n    @Suppress(\"DEPRECATION\")\n    override inline val feature get() = FeatureAssertionsBuilder\n\n    override inline val floatingPoint get() = FloatingPointAssertionsBuilder\n\n    override inline val iterable get() = IterableAssertionsBuilder\n\n    override inline val list get() = ListAssertionsBuilder\n\n    override inline val map get() = MapAssertionsBuilder\n\n    override inline val pair get() = PairAssertionsBuilder\n\n    override inline val throwable get() = ThrowableAssertionsBuilder\n}\n\ninterface AssertImplCommon {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    val builder: AssertionBuilder\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    val collector: AssertionCollectorBuilder\n\n    /**\n     * Returns the implementation of [CoreFactory].\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.core.coreFactory]\n     * which in turn delegates to the implementation via [loadSingleService].\n     */\n    val coreFactory: CoreFactory\n\n    /**\n     * Creates a new [AssertionPlant] based on the given [subjectProvider] whereas the [AssertionPlant] delegates\n     * assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlant] but merely want to make feature assertions so that\n     * you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlant<R> = subjectChanger.unreportedToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = subjectChanger.unreported(originalAssertionCreator, transformation)\n\n    /**\n     * Creates a new [AssertionPlantNullable] based on the given [subjectProvider] whereas the [AssertionPlant]\n     * delegates assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlantNullable] but merely want to make feature\n     * assertions so that you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R> changeToNullableSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlantNullable<R> = subjectChanger.unreportedNullableToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeToNullableSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = changeSubject(originalAssertionCreator, transformation)\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    val any: AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    val charSequence: CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    val collection: CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    val comparable: ComparableAssertionsBuilder\n\n    /**\n     * Returns [FeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    @Suppress(\"DEPRECATION\")\n    val feature: FeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    val floatingPoint: FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    val iterable: IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    val list: ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    val map: MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    val pair: PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    val throwable: ThrowableAssertionsBuilder\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\", \"DEPRECATION\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.AnyAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.AnyTypeTransformation\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.AnyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.anyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.FailureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.failureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.anyAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [AnyAssertions].\n * In detail, it implements [AnyAssertions] by delegating to [anyAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject AnyAssertionsBuilder : AnyAssertions {\n\n    override inline fun <T : Any> toBe(subjectProvider: SubjectProvider<T>, expected: T): Assertion =\n        anyAssertions.toBe(subjectProvider, expected)\n\n    override inline fun <T> notToBe(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.notToBe(subjectProvider, expected)\n\n    override inline fun <T> isSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isSame(subjectProvider, expected)\n\n    override inline fun <T> isNotSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isNotSame(subjectProvider, expected)\n\n    override inline fun <T> toBeNull(subjectProvider: SubjectProvider<T>) =\n        anyAssertions.toBeNull(subjectProvider)\n\n    override inline fun <T : Any> toBeNullable(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        expectedOrNull: T?\n    ) = anyAssertions.toBeNullable(assertionContainer, type, expectedOrNull)\n\n    override inline fun <T : Any> toBeNullIfNullGivenElse(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (Expect<T>.() -> Unit)?\n    ) = anyAssertions.toBeNullIfNullGivenElse(assertionContainer, type, assertionCreatorOrNull)\n\n    override inline fun <T, TSub : Any> isA(assertionContainer: Expect<T>, subType: KClass<TSub>) =\n        anyAssertions.isA(assertionContainer, subType)\n\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullable(plant: AssertionPlantNullable<T?>, type: KClass<T>, expectedOrNull: T?) =\n        anyAssertions.isNullable(plant, type, expectedOrNull)\n\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyAssertions.isNotNull(plant, type, assertionCreator)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNullBut(plant: AssertionPlantNullable<T?>, type: KClass<T>, expected: T) =\n        anyAssertions.isNotNullBut(plant, type, expected)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullIfNullGivenElse(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (AssertionPlant<T>.() -> Unit)?\n    ) = anyAssertions.isNullIfNullGivenElse(plant, type, assertionCreatorOrNull)\n\n\n    /**\n     * Returns [AnyTypeTransformationAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyTypeTransformationAssertions].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from `Assert` to `Expect` use `ExpectImpl.changeSubject` or `ExpectImpl.feature.extract` instead; will be removed with 1.0.0\")\n    inline val typeTransformation\n        get() = AnyTypeTransformationAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [AnyTypeTransformationAssertions].\n * In detail, it implements [AnyTypeTransformationAssertions] by delegating to [anyTypeTransformationAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationAssertionsBuilder : AnyTypeTransformationAssertions {\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\n        \"This function will be removed in v.1.0.0 in favour of AssertImpl.any.isNotNull\", ReplaceWith(\n            \"plant.addAssertion(AssertImpl.any.isNotNull(plant, type, assertionCreator))\",\n            \"ch.tutteli.atrium.domain.builders.AssertImpl\"\n        )\n    )\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyTypeTransformationAssertions.isNotNull(plant, type, assertionCreator)\n\n    override inline fun <TSub : Any> isA(\n        plant: AssertionPlant<Any>,\n        subType: KClass<TSub>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit\n    ) = anyTypeTransformationAssertions.isA(plant, subType, assertionCreator)\n\n    override inline fun <T : Any, TSub : T> downCast(\n        description: Translatable,\n        subType: KClass<TSub>,\n        subjectPlant: BaseAssertionPlant<T?, *>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit,\n        failureHandler: AnyTypeTransformation.FailureHandler<T, TSub>\n    ) = anyTypeTransformationAssertions.downCast(description, subType, subjectPlant, assertionCreator, failureHandler)\n\n    override inline fun <S : Any, T : Any> transform(\n        parameterObject: AnyTypeTransformation.ParameterObject<S, T>,\n        noinline canBeTransformed: (S) -> Boolean,\n        noinline transform: (S) -> T,\n        failureHandler: AnyTypeTransformation.FailureHandler<S, T>\n    ) = anyTypeTransformationAssertions.transform(parameterObject, canBeTransformed, transform, failureHandler)\n\n    /**\n     * Returns [AnyTypeTransformationFailureHandlerFactoryBuilder]\n     * which inter alia delegates to the implementation of [FailureHandlerFactory].\n     */\n    inline val failureHandlers get() = AnyTypeTransformationFailureHandlerFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [FailureHandlerFactory].\n * In detail, it implements [FailureHandlerFactory] by delegating to [failureHandlerFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationFailureHandlerFactoryBuilder : FailureHandlerFactory {\n\n    override inline fun <S : Any, T : Any> newExplanatory() = failureHandlerFactory.newExplanatory<S, T>()\n\n    override inline fun <S : Any, T : Any> newExplanatoryWithHint(\n        noinline showHint: () -> Boolean,\n        noinline failureHintFactory: () -> Assertion\n    ) = failureHandlerFactory.newExplanatoryWithHint<S, T>(showHint, failureHintFactory)\n}\n","package ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.changers.SubjectChangerBuilder\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.SubjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give assertion writers (and other consumers of the domain) a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\nobject ExpectImpl {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    inline val builder get() = assertionBuilder\n\n    /**\n     * Returns [SubjectChangerBuilder] - helping you to change the subject of the assertion.\n     * In detail, its an `inline` property which returns [SubjectChangerBuilder]\n     * which inter alia delegates to the implementation of [SubjectChanger].\n     *\n     * In case you want to extract a feature (e.g. get the first element of a `List`) instead of changing the subject\n     * into another representation (e.g. down-cast `Person` to `Student`) then you should use\n     * [feature.extractor][NewFeatureAssertionsBuilder.extractor] instead.\n     */\n    inline fun <T> changeSubject(originalAssertionContainer: Expect<T>) =\n        SubjectChangerBuilder.create(originalAssertionContainer)\n\n    @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    inline fun <T> changeSubject(originalAssertionContainer: SubjectProvider<T>) =\n        SubjectChangerBuilder.create(originalAssertionContainer)\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * In detail, its an `inline` property which returns [AssertionCollectorBuilder]\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    inline val collector get() = AssertionCollectorBuilder\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    inline val any get() = AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    inline val collection get() = CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    inline val comparable get() = ComparableAssertionsBuilder\n\n    /**\n     * Returns [NewFeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    inline val feature get() = NewFeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    inline val floatingPoint get() = FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    inline val iterable get() = IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    val list get() = ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    inline val map get() = MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    inline val pair get() = PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    inline val throwable get() = ThrowableAssertionsBuilder\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CharSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.CharSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.charSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.SearchBehaviourFactory\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.searchBehaviourFactory\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceAssertions].\n * In detail, it implements [CharSequenceAssertions] by delegating to [charSequenceAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceAssertionsBuilder : CharSequenceAssertions {\n\n    override inline fun <T : CharSequence> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <T : CharSequence> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun startsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsWith(subjectProvider, expected)\n\n    override inline fun startsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsNotWith(subjectProvider, expected)\n\n    override inline fun endsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsWith(subjectProvider, expected)\n\n    override inline fun endsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsNotWith(subjectProvider, expected)\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun isNotBlank(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotBlank(subjectProvider)\n\n    override inline fun <T : CharSequence> matches(assertionContainer: Expect<T>, expected: Regex) =\n        charSequenceAssertions.matches(assertionContainer, expected)\n\n    override inline fun <T : CharSequence> mismatches(assertionContainer: Expect<T>, expected: Regex) =\n        charSequenceAssertions.mismatches(assertionContainer, expected)\n\n    /**\n     * Returns [CharSequenceContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceContainsAssertions].\n     */\n    inline val contains get() = CharSequenceContainsAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceContainsAssertions].\n * In detail, it implements [CharSequenceContainsAssertions] by delegating to [charSequenceContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceContainsAssertionsBuilder : CharSequenceContainsAssertions {\n\n    override inline fun <T : CharSequence> values(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Any>\n    ) = charSequenceContainsAssertions.values(checkerOption, expected)\n\n    override inline fun <T : CharSequence> valuesIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Any>\n    ) = charSequenceContainsAssertions.valuesIgnoringCase(checkerOption, expected)\n\n    override inline fun <T : CharSequence> defaultTranslationOf(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOf(checkerOption, expected)\n\n    override inline fun <T : CharSequence> defaultTranslationOfIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOfIgnoringCase(checkerOption, expected)\n\n    @JvmName(\"stringRegex\")\n    inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<String>\n    ) = regex(checkerOption, expected.map { it.toRegex() })\n\n    override inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Regex>\n    ) = charSequenceContainsAssertions.regex(checkerOption, expected)\n\n    override inline fun <T : CharSequence> regexIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<String>\n    ) = charSequenceContainsAssertions.regexIgnoringCase(checkerOption, expected)\n\n    /**\n     * Returns [CharSequenceContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = CharSequenceContainsSearchBehaviourFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <T : CharSequence> ignoringCase(\n        containsBuilder: CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    ): CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour> =\n        searchBehaviourFactory.ignoringCase(containsBuilder)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Converts the string into a regular expression [Regex] with the default options.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(): Regex = Regex(this)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified single [option].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(option: RegexOption): Regex = Regex(this, option)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified set of [options].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(options: Set<RegexOption>): Regex = Regex(this, options)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\", \"DEPRECATION\")\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.creating.FeatureAssertions\nimport ch.tutteli.atrium.domain.creating.feature.extract.FeatureExtractor\nimport ch.tutteli.atrium.domain.creating.featureAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\nimport kotlin.reflect.*\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [FeatureAssertions].\n * In detail, it implements [FeatureAssertions] by delegating to [featureAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use then ExpectImpl.feature, NewFeatureAssertionsBuilder respectively; will be removed with 1.0.0\")\nobject FeatureAssertionsBuilder : FeatureAssertions {\n\n    @Suppress(\"DEPRECATION\")\n    inline val extractor: FeatureExtractor.DescriptionOption get() = FeatureExtractor.builder\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>)\n        = property(plant, { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) }, Untranslatable(property.name))\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>)\n        = property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable): AssertionPlant<TProperty>\n        = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable): AssertionPlant<TProperty>\n        = featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit)\n        = property(plant, { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) },  Untranslatable(property.name), assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit)\n        = property(plant, property,  Untranslatable(property.name), assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit): AssertionPlant<TProperty>\n        = property(plant, subjectProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit): AssertionPlant<TProperty>\n        = property(plant, subjectProvider, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>): AssertionPlantNullable<TProperty> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\")  property.invoke(plant.subject) }\n        return property(plant, l, Untranslatable(property.name))\n    }\n\n    inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>)\n        = property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable): AssertionPlantNullable<TProperty>\n        = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable): AssertionPlantNullable<TProperty>\n        = featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    //Arg0\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>): AssertionPlant<R>\n        = returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>): AssertionPlant<R>\n        = returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\") method(plant.subject) }\n        return returnValueOf0(plant, l, l, method.name)\n    }\n\n    inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>): AssertionPlantNullable<R>\n        = returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    //Arg1\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1): AssertionPlant<R>\n        = returnValueOf1(plant, {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }, arg1, method.name)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }, arg1, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1) -> R = {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }\n        return returnValueOf1(plant, l, arg1, method.name)\n    }\n\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n        = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    //Arg2\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n        = returnValueOf2(plant, {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }, arg1, arg2, method.name)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }, arg1, arg2, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2) -> R = {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }\n        return returnValueOf2(plant, l, arg1, arg2, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    //Arg3\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n        = returnValueOf3(plant, {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }, arg1, arg2, arg3, method.name)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }, arg1, arg2, arg3, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2, T3) -> R = {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }\n        return returnValueOf3(plant, l, arg1, arg2, arg3, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    //Arg4\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n        = returnValueOf4(plant, {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }, arg1, arg2, arg3, arg4, method.name)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }, arg1, arg2, arg3, arg4, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2, T3, T4) -> R = {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }\n        return returnValueOf4(plant, l, arg1, arg2, arg3, arg4, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    //Arg5\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n        = returnValueOf5(plant, {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }, arg1, arg2, arg3, arg4, arg5, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1, T2, T3, T4, T5) -> R = {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }\n        return returnValueOf5(plant, l, arg1, arg2, arg3, arg4, arg5, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.IterableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.IterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.iterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.*\nimport ch.tutteli.atrium.domain.creating.iterableAssertions\n\n/**\n * Delegates inter alia to the implementation of [IterableAssertions].\n * In detail, it implements [IterableAssertions] by delegating to [iterableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableAssertionsBuilder : IterableAssertions {\n\n    override inline fun <E, T : Iterable<E>> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <E, T : Iterable<E>> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun <E : Any, T : Iterable<E?>> all(\n        assertionContainer: Expect<T>,\n        noinline assertionCreator: (Expect<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(assertionContainer, assertionCreator)\n\n\n    override inline fun <E, T : Iterable<E>> hasNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNext(expect)\n\n    override inline fun <E, T : Iterable<E>> hasNotNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNotNext(expect)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> min(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, E> =\n        iterableAssertions.min(assertionContainer)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> max(assertionContainer: Expect<T>) =\n        iterableAssertions.max(assertionContainer)\n\n    /**\n     * Returns [IterableContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [IterableContainsAssertions].\n     */\n    inline val contains get() = IterableContainsAssertionsBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any> all(\n        plant: AssertionPlant<Iterable<E?>>,\n        noinline assertionCreator: (AssertionPlant<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(plant, assertionCreator)\n}\n\n/**\n * Delegates inter alia to the implementation of [IterableContainsAssertions].\n * In detail, it implements [IterableContainsAssertions] by delegating to [iterableContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableContainsAssertionsBuilder : IterableContainsAssertions {\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrder(checkerOption, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrder(checkerOption, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrderOnly(\n        builder: IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnly(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnly(\n        builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnly(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<E>>\n    ): Assertion = iterableContainsAssertions.valuesInOrderOnlyGrouped(builder, groups)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(Expect<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGrouped(builder, groups)\n\n\n    /**\n     * Returns [IterableContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = IterableContainsSearchBehaviourFactoryBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderWithAssert(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderWithAssert(checkerOption, assertionCreators)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGroupedWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(AssertionPlant<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGroupedWithAssert(builder, groups)\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <E, T : Iterable<E>> inAnyOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inAnyOrderOnly(builder: IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnly(builder: IterableContains.Builder<E, T, InOrderSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGrouped(builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGrouped(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGroupedWithin(builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGroupedWithin(builder)\n\n}\n","package ch.tutteli.kbox\n\n/**\n * Adds the given [arg] and the [otherArgs] into a new [List] and returns it.\n *\n * This function is intended for API functions which expect `x: T, vararg otherX: T` and want to pass the arguments\n * to another function which expects only one argument of `List<T>`.\n *\n * @return a [List] containing [arg] and [otherArgs].\n */\nfun <T> varargToList(arg: T, otherArgs: Array<out T>): List<T> {\n    val list = ArrayList<T>(otherArgs.size + 1)\n    list.add(arg)\n    list.addAll(otherArgs)\n    return list\n}\n\n/**\n * Delegates to [varargToList] -- adds `this` and the [otherArgs] into a new [List] and returns it.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\ninline infix fun <T> T.glue(otherArgs: Array<out T>): List<T> = varargToList(this, otherArgs)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.creating.ThrowableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ChangedSubjectPostStep\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.ThrowableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.throwableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.providers.absentThrowableMessageProviderFactory\nimport ch.tutteli.atrium.domain.creating.throwableAssertions\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [ThrowableAssertions].\n * In detail, it implements [ThrowableAssertions] by delegating to [throwableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ThrowableAssertionsBuilder : ThrowableAssertions {\n\n    override inline fun thrownBuilder(\n        assertionVerb: Translatable,\n        noinline act: () -> Unit,\n        reporter: Reporter\n    ): ThrowableThrown.Builder = throwableAssertions.thrownBuilder(assertionVerb, act, reporter)\n\n    /**\n     * Returns [ThrowableThrownAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableThrownAssertions].\n     */\n    inline val thrown get() = ThrowableThrownAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ThrowableThrownAssertions].\n * In detail, it implements [ThrowableThrownAssertions] by delegating to [throwableThrownAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ThrowableThrownAssertionsBuilder : ThrowableThrownAssertions {\n\n    override inline fun <TExpected : Throwable> isA(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>\n    ) = throwableThrownAssertions.isA(throwableThrownBuilder, expectedType)\n\n    override inline fun notThrown(\n        throwableThrownBuilder: ThrowableThrown.Builder\n    ): ChangedSubjectPostStep<Throwable?, Nothing?> = throwableThrownAssertions.notThrown(throwableThrownBuilder)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <TExpected : Throwable> toBe(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>,\n        noinline assertionCreator: AssertionPlant<TExpected>.() -> Unit\n    ) = throwableThrownAssertions.toBe(throwableThrownBuilder, expectedType, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun nothingThrown(throwableThrownBuilder: ThrowableThrown.Builder) =\n        throwableThrownAssertions.nothingThrown(throwableThrownBuilder)\n\n    /**\n     * Returns [AbsentThrowableMessageProviderFactoryBuilder]\n     * which inter alia delegates to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Will be removed with 1.0.0\")\n    inline val providers\n        get() = AbsentThrowableMessageProviderFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n * In detail, it implements [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory] by delegating to [absentThrowableMessageProviderFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Will be removed with 1.0.0\")\nobject AbsentThrowableMessageProviderFactoryBuilder :\n    ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory {\n\n    override inline fun translatableBased(translatable: Translatable): ThrowableThrown.AbsentThrowableMessageProvider =\n        absentThrowableMessageProviderFactory.translatableBased(translatable)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"AnyAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.ERR_KEYWORD_GIVEN_COLLECTION_ASSUMED\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.Keyword\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.PleaseUseReplacementException\nimport ch.tutteli.atrium.reporting.Reporter\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is (equal to) [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).toBe(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Any> Assert<T>.toBe(expected: T)\n    = addAssertion(AssertImpl.any.toBe(this, expected))\n\n@Deprecated(ERR_KEYWORD_GIVEN_COLLECTION_ASSUMED, ReplaceWith(\"this toBe (keyword as Any)\"))\n@Suppress(\"UNUSED_PARAMETER\", \"unused\")\ninfix fun <T: Any> Assert<T>.toBe(keyword: Keyword): Nothing\n    = throw PleaseUseReplacementException(\"this toBe (keyword as Any)\")\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not (equal to) [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).notToBe(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Any> Assert<T>.notToBe(expected: T)\n    = addAssertion(AssertImpl.any.notToBe(this, expected))\n\n@Deprecated(ERR_KEYWORD_GIVEN_COLLECTION_ASSUMED, ReplaceWith(\"this notToBe (keyword as Any)\"))\n@Suppress(\"UNUSED_PARAMETER\", \"unused\")\ninfix fun <T: Any> Assert<T>.notToBe(keyword: Keyword): Nothing\n    = throw PleaseUseReplacementException(\"this notToBe (keyword as Any)\")\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is the same instance as [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).isSameAs(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Any> Assert<T>.isSameAs(expected: T)\n    = addAssertion(AssertImpl.any.isSame(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not the same instance as [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).isNotSameAs(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Any> Assert<T>.isNotSameAs(expected: T)\n    = addAssertion(AssertImpl.any.isNotSame(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is [expected].\n *\n * @return Does not support a fluent API because: what else would you want to assert about `null` anyway?\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninline infix fun <reified T : Any> AssertionPlantNullable<T?>.toBe(expected: T?) {\n    addAssertion(AssertImpl.any.isNullable(this, T::class, expected))\n}\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is either `null` if [assertionCreatorOrNull]\n * is `null` or is not `null` and holds all assertions [assertionCreatorOrNull] might create.\n *\n * It is a shortcut for\n * ```kotlin\n * if (assertionCreatorOrNull == null)\n *   o toBe null\n * else\n *   o notToBeNull assertionCreatorOrNull\n * ```\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninline infix fun <reified T : Any> AssertionPlantNullable<T?>.toBeNullIfNullGivenElse(noinline assertionCreatorOrNull: (Assert<T>.() -> Unit)?) {\n    addAssertion(AssertImpl.any.isNullIfNullGivenElse(this, T::class, assertionCreatorOrNull))\n}\n\n/**\n * Can be used to create a group of sub assertions when using the fluent API.\n *\n * For instance `assert(1).isLessThan(3).and { isEven(); isGreaterThan(1) }` creates\n * two assertions where the second one consists of two sub-assertions. In case the first assertion holds, then the\n * second one is evaluated as a whole. Meaning, even though 1 is not even, it still evaluates that 1 is greater than 1.\n * Hence the reporting might (depending on the configured [Reporter]) contain both failing sub-assertions.\n *\n * @return This plant to support a fluent API.\n */\ninfix fun <T : Any> AssertionPlant<T>.and(assertionCreator: Assert<T>.() -> Unit)\n    = addAssertionsCreatedBy(assertionCreator)\n\n/**\n * Inline property referring actually to `this` and allows to write nicer sub-assertions.\n *\n * For instance, instead of:\n * ```\n * assert(\"hello world\"){\n *   this startsWith \"hello\"\n *   this ends with \"world\"\n * }\n * ```\n * You can write\n * ```\n * assert(\"hello world\"){\n *   o startsWith \"hello\"\n *   o ends with \"world\"\n * }\n * ```\n */\ninline val <T: Any> Assert<T>.o get() : Assert<T> = this\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\nimport kotlin.jvm.JvmName\n\n/**\n * Turns `Assert<Array<E>>` into `Assert<Iterable<E>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Array<out E>::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\nfun <E> Assert<Array<out E>>.asIterable(): Assert<Iterable<E>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<Array<E>>` into `Assert<Iterable<E>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Array<out E>::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\ninfix fun <E> Assert<Array<out E>>.asIterable(assertionCreator: Assert<Iterable<E>>.() -> Unit): Assert<Iterable<E>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Byte>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ByteArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [Assert] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"byteArrAsIterable\")\nfun Assert<ByteArray>.asIterable(): Assert<Iterable<Byte>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Byte>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ByteArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [Assert] for the transformed subject.\n */\n@JvmName(\"byteArrAsIterable\")\ninfix fun Assert<ByteArray>.asIterable(assertionCreator: Assert<Iterable<Byte>>.() -> Unit): Assert<Iterable<Byte>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Char>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(CharArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"charArrAsIterable\")\nfun Assert<CharArray>.asIterable(): Assert<Iterable<Char>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Char>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(CharArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@JvmName(\"charArrAsIterable\")\ninfix fun Assert<CharArray>.asIterable(assertionCreator: Assert<Iterable<Char>>.() -> Unit): Assert<Iterable<Char>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<ShortArray>` into `Assert<Iterable<Short>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ShortArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"shortArrAsIterable\")\nfun Assert<ShortArray>.asIterable(): Assert<Iterable<Short>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<ShortArray>` into `Assert<Iterable<Short>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ShortArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@JvmName(\"shortArrAsIterable\")\ninfix fun Assert<ShortArray>.asIterable(assertionCreator: Assert<Iterable<Short>>.() -> Unit): Assert<Iterable<Short>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<IntArray>` into `Assert<Iterable<Int>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(IntArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"intArrAsIterable\")\nfun Assert<IntArray>.asIterable(): Assert<Iterable<Int>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<IntArray>` into `Assert<Iterable<Int>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(IntArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@JvmName(\"intArrAsIterable\")\ninfix fun Assert<IntArray>.asIterable(assertionCreator: Assert<Iterable<Int>>.() -> Unit): Assert<Iterable<Int>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<LongArray>` into `Assert<Iterable<Double>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(LongArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"longArrAsIterable\")\nfun Assert<LongArray>.asIterable(): Assert<Iterable<Long>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<LongArray>` into `Assert<Iterable<Double>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(LongArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@JvmName(\"longArrAsIterable\")\ninfix fun Assert<LongArray>.asIterable(assertionCreator: Assert<Iterable<Long>>.() -> Unit): Assert<Iterable<Long>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<FloatArray>` into `Assert<Iterable<Float>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(FloatArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"floatArrAsIterable\")\nfun Assert<FloatArray>.asIterable(): Assert<Iterable<Float>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<FloatArray>` into `Assert<Iterable<Float>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(FloatArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@JvmName(\"floatArrAsIterable\")\ninfix fun Assert<FloatArray>.asIterable(assertionCreator: Assert<Iterable<Float>>.() -> Unit): Assert<Iterable<Float>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<DoubleArray>` into `Assert<Iterable<Double>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(DoubleArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"doubleArrAsIterable\")\nfun Assert<DoubleArray>.asIterable(): Assert<Iterable<Double>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<DoubleArray>` into `Assert<Iterable<Double>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(DoubleArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@JvmName(\"doubleArrAsIterable\")\ninfix fun Assert<DoubleArray>.asIterable(assertionCreator: Assert<Iterable<Double>>.() -> Unit): Assert<Iterable<Double>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<BooleanArray>` into `Assert<Iterable<Boolean>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(BooleanArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"boolArrAsIterable\")\nfun Assert<BooleanArray>.asIterable(): Assert<Iterable<Boolean>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<BooleanArray>` into `Assert<Iterable<Boolean>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(BooleanArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@JvmName(\"boolArrAsIterable\")\ninfix fun Assert<BooleanArray>.asIterable(assertionCreator: Assert<Iterable<Boolean>>.() -> Unit): Assert<Iterable<Boolean>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.Blank\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.Empty\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.contain\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NotSearchBehaviour\n\n/**\n * Creates a [CharSequenceContains.Builder] based on this [AssertionPlant] which allows to define\n * a sophisticated `contains` assertions.\n *\n * @param contain Has to be `contain`.\n *\n * @return The newly created builder.\n */\ninfix fun <T : CharSequence> Assert<T>.to(@Suppress(\"UNUSED_PARAMETER\") contain: contain): CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    = AssertImpl.charSequence.containsBuilder(this)\n\n/**\n * Creates a [CharSequenceContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains not` assertions.\n *\n * @return The newly created builder.\n */\ninfix fun <T : CharSequence> Assert<T>.notTo(@Suppress(\"UNUSED_PARAMETER\") contain: contain): NotCheckerOption<T, NotSearchBehaviour>\n    = NotCheckerOptionImpl(AssertImpl.charSequence.containsNotBuilder(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the [toString] representation of the given [expected]\n * using a non disjoint search.\n *\n * It is a shortcut for `to contain atLeast 1 value expected`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\ninfix fun <T : CharSequence> Assert<T>.contains(expected: Any): AssertionPlant<T>\n    = this contains Values(expected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [values] [toString] representation\n * using a non disjoint search.\n *\n * It is a shortcut for `to contain atLeast 1 the Values(...)`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [Values.expected]\n * is defined as `'a'` and one [Values.otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use the property `contains` to create a more sophisticated `contains`\n * assertion where you can use options such as [atLeast], [atMost] and [exactly] to control the number of occurrences\n * you expect.\n *\n * Meaning you might want to use:\n *   `to contain exactly 2 the value 'a'`\n * instead of:\n *   `contains Values('a', 'a')`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case one of the [values] is not a [CharSequence], [Number] or [Char].\n */\ninfix fun <T : CharSequence> Assert<T>.contains(values: Values<Any>): AssertionPlant<T>\n    = this to contain atLeast 1 the values\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a sequence which matches the given [pattern].\n *\n * It is a shortcut for `to contain atLeast 1 regex pattern`.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.containsRegex(pattern: String): AssertionPlant<T>\n    = this contains RegexPatterns(pattern)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a sequence which matches the given [patterns]\n * using a non disjoint search.\n *\n * It is a shortcut for `to contain atLeast 1 the RegexPatterns(...)`.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and\n * [RegexPatterns.expected] is defined as `'a(b)?'` and one of the [RegexPatterns.otherExpected] is defined as\n * `'a(b)?'` as well, then both match, even though they match the same sequence in the input of the search.\n * Use an option such as [atLeast], [atMost] and [exactly] to control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `to contain exactly 2 the regex 'a(b)?'`\n * instead of:\n *   `to contain atLeast 1 the RegexPatterns('a(b)?', 'a(b)?')`\n *\n * @param patterns The patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.contains(patterns: RegexPatterns): AssertionPlant<T>\n    = this to contain atLeast 1 the patterns\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not [expected]'s [toString] representation.\n *\n * Delegates to [containsNot] [Values].\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.containsNot(expected: Any)\n    = this containsNot Values(expected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the [toString] representation\n * of the given [values].\n *\n * It is a shortcut for `notTo contain the Values(expected, *otherExpected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.containsNot(values: Values<Any>)\n    = this notTo contain the values\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] starts with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.startsWith(expected: CharSequence)\n    = addAssertion(AssertImpl.charSequence.startsWith(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not start with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.startsNotWith(expected: CharSequence)\n    = addAssertion(AssertImpl.charSequence.startsNotWith(this, expected))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] ends with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.endsWith(expected: CharSequence)\n    = addAssertion(AssertImpl.charSequence.endsWith(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not end with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.endsNotWith(expected: CharSequence)\n    = addAssertion(AssertImpl.charSequence.endsNotWith(this, expected))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isEmpty].\n *\n * @param Empty Has to be `Empty`.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.toBe(@Suppress(\"UNUSED_PARAMETER\") Empty: Empty)\n    = addAssertion(AssertImpl.charSequence.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isNotEmpty].\n *\n * @param Empty Has to be `Empty`.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.notToBe(@Suppress(\"UNUSED_PARAMETER\") Empty: Empty)\n    = addAssertion(AssertImpl.charSequence.isNotEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isNotBlank].\n *\n * @param Blank Has to be `Blank`.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> Assert<T>.notToBe(@Suppress(\"UNUSED_PARAMETER\") Blank: Blank)\n    = addAssertion(AssertImpl.charSequence.isNotBlank(this))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.*\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl.*\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we are looking\n * for occurs `at least` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n */\ninfix fun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.atLeast(times: Int): AtLeastCheckerOption<T, S>\n    = AtLeastCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains at least` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `at most` number of [times] within the search input.\n *\n * The resulting restriction will be a `contains at least but at most` assertion.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n * @throws IllegalArgumentException In case [times] of this `at most` restriction equals to the number of the\n *   `at least` restriction; use the [genau] restriction instead.\n */\ninfix fun <T : CharSequence, S : SearchBehaviour> AtLeastCheckerOption<T, S>.butAtMost(times: Int): ButAtMostCheckerOption<T, S>\n    = ButAtMostCheckerOptionImpl(times, this, containsBuilder)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `exactly` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n */\ninfix fun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.exactly(times: Int): ExactlyCheckerOption<T, S>\n    = ExactlyCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `at least` once but `at most` number of [times] within the search input.\n *\n * If you want to use a higher lower bound than one, then use `atLeast(2).butAtMost(3)` instead of `atMost(3)`.\n * And in case you want to state that it is either not contained at all or at most a certain number of times,\n * then use `notOrAstMost(2)` instead.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] equals to one; use [exactly] instead.\n */\ninfix fun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.atMost(times: Int): AtMostCheckerOption<T, S>\n    = AtMostCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `not at all or at most` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n */\ninfix fun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.notOrAtMost(times: Int): NotOrAtMostCheckerOption<T, S>\n    = NotOrAtMostCheckerOptionImpl(times, this)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] object shall be searched,\n * using a non disjoint search.\n *\n * Delegates to `the Values(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\ninfix fun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.value(expected: Any): AssertionPlant<T>\n    = this the Values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given [values]\n * shall be searched, using a non disjoint search.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [Values.expected]\n * is defined as `'a'` and one [Values.otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to control\n * the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `to contain exactly 2 the value 'a'`\n * instead of:\n *   `to contain atLeast 1 the Values('a', 'a')`\n *\n * @param values The values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case one of the [values] is not a [CharSequence], [Number] or [Char].\n */\ninfix fun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.the(values: Values<Any>): AssertionPlant<T>\n    = addAssertion(AssertImpl.charSequence.contains.values(this, values.toList()))\n\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value shall be searched\n * (ignoring case), using a non disjoint search.\n *\n * Delegates to `the Values(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n@JvmName(\"valueIgnoringCase\")\ninfix fun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.value(expected: Any): AssertionPlant<T>\n    = this the Values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [values]\n * shall be searched (ignoring case), using a non disjoint search.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [Values.expected]\n * is defined as `'a'` and one [Values.otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to control\n * the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `to contain ignoring case exactly 2 the value 'a'`\n * instead of:\n *   `to contain ignoring case atLeast 1 the Values('a', 'a')`\n *\n * @param values The values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case one of the [values] is not a [CharSequence], [Number] or [Char].\n */\n@JvmName(\"valuesIgnoringCase\")\ninfix fun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.the(values: Values<Any>): AssertionPlant<T>\n    = addAssertion(AssertImpl.charSequence.contains.valuesIgnoringCase(this, values.toList()))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value shall be searched\n * (ignoring case), using a non disjoint search where it needs to be contained at least once.\n *\n * Delegates to `atLeast 1 value expected`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\ninfix fun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.value(expected: Any): AssertionPlant<T>\n    = this atLeast 1 value expected\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [values]\n * shall be searched (ignoring case), using a non disjoint search\n * where each need to be contained at least once.\n *\n * Delegates to `atLeast 1 the value`\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [Values.expected]\n * is defined as `'a'` and one [Values.otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to control\n * the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `to contain ignoring case exactly 2 the value 'a'`\n * instead of:\n *   `to contain ignoring case atLeast 1 the Values('a', 'a')`\n *\n * @param values The values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case one of the [values] is not a [CharSequence], [Number] or [Char].\n */\ninfix fun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.the(values: Values<Any>): AssertionPlant<T>\n    = this atLeast 1 the values\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * is expected to have a match, using a non disjoint search.\n *\n * Delegates to `the RegexPatterns(pattern)`.\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.regex(pattern: String): AssertionPlant<T>\n    = this the RegexPatterns(pattern)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [patterns]\n * are expected to have a match, using a non disjoint search.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and\n * [patterns].[pattern][RegexPatterns.expected] is defined as `'a(b)?'` and one of the\n * [patterns].[otherPatterns][RegexPatterns.otherExpected] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to\n * control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `to contain exactly 2 the regex 'a(b)?'`\n * instead of:\n *   `to contain atLeast 1 the RegexPatterns('a(b)?', 'a(b)?')`\n *\n * @param patterns The patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.the(patterns: RegexPatterns): AssertionPlant<T>\n    = addAssertion(AssertImpl.charSequence.contains.regex(this, patterns.toList()))\n\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * is expected to have a match (ignoring case), using a non disjoint search.\n *\n * Delegates to `the RegexPatterns(pattern)`.\n *\n * @param pattern The patterns which is expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@JvmName(\"regexIgnoringCase\")\ninfix fun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.regex(pattern: String): AssertionPlant<T>\n    = this the RegexPatterns(pattern)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [patterns]\n * are expected to have a match (ignoring case), using a non disjoint search.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and\n * [patterns].[pattern][RegexPatterns.expected] is defined as `'a(b)?'` and one of the\n * [patterns].[otherPatterns][RegexPatterns.otherExpected] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to\n * control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `to contain ignoring case exactly 2 the regex 'a(b)?'`\n * instead of:\n *   `to contain ignoring case atLeast 1 the RegexPatterns('a(b)?', 'a(b)?')`\n *\n * @param patterns The patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@JvmName(\"regexIgnoringCase\")\ninfix fun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.the(patterns: RegexPatterns): AssertionPlant<T>\n    = addAssertion(AssertImpl.charSequence.contains.regexIgnoringCase(this, patterns.toList()))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * is expected to have at least one match (ignoring case), using a non disjoint search.\n *\n * Delegates to `the RegexPatterns(pattern)`.\n *\n * @param pattern The patterns which is expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.regex(pattern: String): AssertionPlant<T>\n    = this atLeast 1 regex pattern\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [patterns]\n * are expected to have at least one match (ignoring case), using a non disjoint search.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and\n * [patterns].[pattern][RegexPatterns.expected] is defined as `'a(b)?'` and one of the\n * [patterns].[otherPatterns][RegexPatterns.otherExpected] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to\n * control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `to contain ignoring case exactly 2 the regex 'a(b)?'`\n * instead of:\n *   `to contain ignoring case atLeast 1 the RegexPatterns('a(b)?', 'a(b)?')`\n *\n * @param patterns The patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.the(patterns: RegexPatterns): AssertionPlant<T>\n    = this atLeast 1 the patterns\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nprivate fun <T : CharSequence, S : CharSequenceContains.SearchBehaviour> CharSequenceContains.CheckerOption<T, S>.addAssertion(assertion: Assertion): AssertionPlant<T>\n    = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.case\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NotSearchBehaviour\n\n/**\n * Defines that the search behaviour `ignore case` shall be applied to this sophisticated `contains` assertion.\n *\n * @param case Has to be `case`.\n *\n * @return The newly created builder.\n */\ninfix fun <T : CharSequence> CharSequenceContains.Builder<T, NoOpSearchBehaviour>.ignoring(@Suppress(\"UNUSED_PARAMETER\") case: case): CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>\n    = AssertImpl.charSequence.contains.searchBehaviours.ignoringCase(this)\n\n/**\n * Defines that the search behaviour `ignore case` shall be applied to this sophisticated `contains not` assertion.\n *\n * @param case Has to be `case`.\n *\n * @return The newly created builder.\n */\ninfix fun <T : CharSequence> NotCheckerOption<T, NotSearchBehaviour>.ignoring(@Suppress(\"UNUSED_PARAMETER\") case: case): NotCheckerOption<T, IgnoringCaseSearchBehaviour>\n    = NotCheckerOptionImpl(containsBuilder ignoring case)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.Empty\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Collection.size] is [size].\n *\n * Shortcut for `size toBe expectedSize` depends on the underlying implementation though.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <T : Collection<*>> Assert<T>.hasSize(size: Int)\n    = addAssertion(AssertImpl.collection.hasSize(this, size))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is an empty [Collection].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Collection<*>> Assert<T>.toBe(@Suppress(\"UNUSED_PARAMETER\") Empty: Empty)\n    = addAssertion(AssertImpl.collection.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not an empty [Collection].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Collection<*>> Assert<T>.notToBe(@Suppress(\"UNUSED_PARAMETER\") Empty: Empty)\n    = addAssertion(AssertImpl.collection.isNotEmpty(this))\n\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property\n * [size][Collection.size] so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval Assert<Collection<*>>.size get(): Assert<Int> = property(Collection<*>::size)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [size][Collection.size]\n * holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <E, T: Collection<E>> Assert<T>.size (assertionCreator: Assert<Int>.() -> Unit): Assert<T>\n    = addAssertion(AssertImpl.collection.size(this, assertionCreator))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CollectionAssertions\nimport ch.tutteli.atrium.domain.creating.collectionAssertions\n\n/**\n * Delegates inter alia to the implementation of [CollectionAssertions].\n * In detail, it implements [CollectionAssertions] by delegating to [collectionAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CollectionAssertionsBuilder : CollectionAssertions {\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Collection<*>> size(assertionContainer: Expect<T>) =\n        collectionAssertions.size(assertionContainer)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Collection<*>>, size: Int) =\n        collectionAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun size(plant: AssertionPlant<Collection<*>>, noinline assertionCreator: Assert<Int>.() -> Unit) =\n        collectionAssertions.size(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is less than [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Comparable<T>> Assert<T>.isLessThan(expected: T)\n    = addAssertion(AssertImpl.comparable.isLessThan(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is less than or equals [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Comparable<T>> Assert<T>.isLessOrEquals(expected: T)\n    = addAssertion(AssertImpl.comparable.isLessOrEquals(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is greater than [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Comparable<T>> Assert<T>.isGreaterThan(expected: T)\n    = addAssertion(AssertImpl.comparable.isGreaterThan(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is greater than or equals [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Comparable<T>> Assert<T>.isGreaterOrEquals(expected: T)\n    = addAssertion(AssertImpl.comparable.isGreaterOrEquals(this, expected))\n\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.ComparableAssertions\nimport ch.tutteli.atrium.domain.creating.comparableAssertions\n\n/**\n * Delegates inter alia to the implementation of [ComparableAssertions].\n * In detail, it implements [ComparableAssertions] by delegating to [comparableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ComparableAssertionsBuilder : ComparableAssertions {\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessOrEquals(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterOrEquals(subjectProvider, expected)\n}\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.AtLeastCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains at least`-check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class AtLeastCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : AtLeastCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"`${containsBuilder::atLeast.name} $it`\" }\n), AtLeastCheckerOption<T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.AtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.AtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class AtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : AtMostCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"`${containsBuilder::atMost.name} $it`\" },\n    { \"`${containsBuilder::atLeast.name} $it`\" },\n    { \"`${containsBuilder::exactly.name} $it`\" }\n), AtMostCheckerOption<T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.infix.en_GB.butAtMost\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.ButAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.ButAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied to the input of the search.\n *\n * @constructor Represents the builder of the second step of a `contains at least but at most` check within the\n *   fluent API of a sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class ButAtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    atLeastBuilder: AtLeastCheckerOption<T, S>,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : ButAtMostCheckerOptionBase<T, S>(\n    times,\n    atLeastBuilder,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { l, u -> \"`${containsBuilder::atLeast.name} $l ${atLeastBuilder::butAtMost.name} $u`\" },\n    { \"`${containsBuilder::atMost.name} $it`\" },\n    { \"`${containsBuilder::atLeast.name} $it`\" },\n    { \"`${atLeastBuilder::butAtMost.name} $it`\" },\n    { \"`${containsBuilder::exactly.name} $it`\" }\n), ButAtMostCheckerOption<T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.ExactlyCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.ExactlyCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class ExactlyCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : ExactlyCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"`${containsBuilder::exactly.name} $it`\" }\n), ExactlyCheckerOption<T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.NotCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n *  Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class NotCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : NotCheckerOptionBase<T, S>(containsBuilder),\n    NotCheckerOption<T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.NotOrAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.notOrAtMost\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.NotOrAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not or at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class NotOrAtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : NotOrAtMostCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"`${containsBuilder::notOrAtMost.name} $it`\" }\n), NotOrAtMostCheckerOption<T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.Values\nimport ch.tutteli.atrium.api.cc.infix.en_GB.containsNot\nimport ch.tutteli.atrium.creating.Assert\nimport kotlin.reflect.KFunction2\n\ninternal fun nameContainsNotValuesFun(): String {\n    val f: KFunction2<Assert<CharSequence>, Values<Any>, Assert<CharSequence>> = Assert<CharSequence>::containsNot\n    return \"${f.name} ${Values::class.simpleName}\"\n}\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.AtLeastCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n *   `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class AtLeastCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : AtLeastCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"`${containsBuilder::atLeast.name} $it`\" }\n), AtLeastCheckerOption<E, T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.AtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.AtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class AtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : AtMostCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"`${containsBuilder::atMost.name} $it`\" },\n    { \"`${containsBuilder::atLeast.name} $it`\" },\n    { \"`${containsBuilder::exactly.name} $it`\" }\n), AtMostCheckerOption<E, T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.infix.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.infix.en_GB.butAtMost\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.ButAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.ButAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of the second step of a `contains at least but at most` check within the\n *   fluent API of a sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class ButAtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    atLeastBuilder: AtLeastCheckerOption<E, T, S>,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : ButAtMostCheckerOptionBase<E, T, S>(\n    times,\n    atLeastBuilder,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { l, u -> \"`${containsBuilder::atLeast.name} $l ${atLeastBuilder::butAtMost.name} $u`\" },\n    { \"`${containsBuilder::atMost.name} $it`\" },\n    { \"`${containsBuilder::atLeast.name} $it`\" },\n    { \"`${atLeastBuilder::butAtMost.name} $it`\" },\n    { \"`${containsBuilder::exactly.name} $it`\" }\n), ButAtMostCheckerOption<E, T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.ExactlyCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.ExactlyCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class ExactlyCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : ExactlyCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"`${containsBuilder::exactly.name} $it`\" }\n), ExactlyCheckerOption<E, T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.NotCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n *   `contains not` assertion for [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class NotCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : NotCheckerOptionBase<E, T, S>(containsBuilder),\n    NotCheckerOption<E, T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.NotOrAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.notOrAtMost\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.NotOrAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class NotOrAtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : NotOrAtMostCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"`${containsBuilder::notOrAtMost.name} $it`\" }\n), NotOrAtMostCheckerOption<E, T, S>\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.Values\nimport ch.tutteli.atrium.api.cc.infix.en_GB.containsNot\nimport ch.tutteli.atrium.creating.Assert\nimport kotlin.reflect.KFunction2\n\ninternal fun nameContainsNotValuesFun(): String {\n    val f: KFunction2<Assert<CharSequence>, Values<Any>, Assert<CharSequence>> = Assert<CharSequence>::containsNot\n    return \"${f.name} ${Values::class.simpleName}\"\n}\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders.impl.ListGetNullableOptionImpl\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\n\n/**\n * Represents the extension point for another option after a `get index`-step within a\n * sophisticated `get` assertion building process for [List].\n *\n * @param E The element type of the [List].\n * @param T A subtype of [List].\n */\ninterface ListGetNullableOption<E, T: List<E>> {\n    /**\n     * The [AssertionPlant] for which this assertion is created\n     */\n    val plant: Assert<T>\n\n    /**\n     * The given index which will be used to perform the [List.get].\n     */\n    val index: Int\n\n    /**\n     * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject] and that\n     * the corresponding nullable entry holds all assertions the given [assertionCreator] might create for it.\n     *\n     * Notice, that the corresponding entry of the given [index] can be `null` even if the index is within bounds\n     * as the [List] has a nullable element type.\n     *\n     * @return This plant to support a fluent API.\n     * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n     *   does not hold.\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n     */\n    infix fun assertIt(assertionCreator: AssertionPlantNullable<E>.() -> Unit): Assert<T>\n\n    companion object {\n        fun <E, T: List<E>> create(plant: Assert<T>, index: Int): ListGetNullableOption<E, T>\n            = ListGetNullableOptionImpl(plant, index)\n    }\n}\n\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders.impl.ListGetOptionImpl\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\n\n/**\n * Represents the extension point for another option after a `get index`-step within a\n * sophisticated `get` assertion building process for [List].\n *\n * @param E The element type of the [List].\n * @param T A subtype of [List].\n */\ninterface ListGetOption<E : Any, T: List<E>> {\n    /**\n     * The [AssertionPlant] for which this assertion is created\n     */\n    val plant: Assert<T>\n\n    /**\n     * The given index which will be used to perform the [List.get].\n     */\n    val index: Int\n\n    /**\n     * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject] and that\n     * the corresponding entry holds all assertions the given [assertionCreator] might create for it.\n     *\n     * @return This plant to support a fluent API.\n     * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n     *   does not hold.\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n     */\n    infix fun assertIt(assertionCreator: Assert<E>.() -> Unit): Assert<T>\n\n    companion object {\n        fun <E: Any, T: List<E>> create(plant: Assert<T>, index: Int): ListGetOption<E, T>\n            = ListGetOptionImpl(plant, index)\n    }\n}\n\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders.ListGetNullableOption\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\ninternal class ListGetNullableOptionImpl<E, T: List<E>>(\n    override val plant: Assert<T>,\n    override val index: Int\n) : ListGetNullableOption<E, T> {\n\n    @Suppress(\"DEPRECATION\")\n    override infix fun assertIt(assertionCreator: AssertionPlantNullable<E>.() -> Unit): Assert<T>\n        = plant.addAssertion(AssertImpl.list.getNullable(plant, index, assertionCreator))\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.ListAssertions\nimport ch.tutteli.atrium.domain.creating.listAssertions\n\n/**\n * Delegates inter alia to the implementation of [ListAssertions].\n * In detail, it implements [ListAssertions] by delegating to [listAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ListAssertionsBuilder : ListAssertions {\n\n    override inline fun <E, T : List<E>> get(\n        assertionContainer: Expect<T>,\n        index: Int\n    ) = listAssertions.get(assertionContainer, index)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T : Any> get(plant: AssertionPlant<List<T>>, index: Int): AssertionPlant<T> =\n        listAssertions.get(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T : Any> get(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = listAssertions.get(plant, index, assertionCreator)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T> getNullable(plant: AssertionPlant<List<T>>, index: Int): AssertionPlantNullable<T> =\n        listAssertions.getNullable(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T> getNullable(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlantNullable<T>.() -> Unit\n    ) = listAssertions.getNullable(plant, index, assertionCreator)\n}\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders.ListGetOption\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\ninternal class ListGetOptionImpl<E : Any, T: List<E>>(\n    override val plant: Assert<T>,\n    override val index: Int\n) : ListGetOption<E, T> {\n\n    @Suppress(\"DEPRECATION\")\n    override infix fun assertIt(assertionCreator: Assert<E>.() -> Unit): Assert<T>\n        = plant.addAssertion(AssertImpl.list.get(plant, index, assertionCreator))\n}\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders.impl.MapGetNullableOptionImpl\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\n\n/**\n * Represents the extension point for another option after a `get key`-step within a\n * sophisticated `get` assertion building process for [Map].\n *\n * @param K The key type of the [Map].\n * @param V the value type of the [Map].\n * @param T A subtype of [Map].\n */\ninterface MapGetNullableOption<K, V, T: Map<out K, V>> {\n    /**\n     * The [AssertionPlant] for which this assertion is created\n     */\n    val plant: Assert<T>\n\n    /**\n     * The given key which will be used to perform the [Map.get].\n     */\n    val key: K\n\n    /**\n     * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the previously specified [key]\n     * and that the corresponding nullable value holds all assertions the given [assertionCreator] might create for it.\n     *\n     * Notice, that the corresponding value of the given [key] can be `null` even if the key exists as the [Map] has a\n     * nullable value type.\n     *\n     * @return This plant to support a fluent API.\n     * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n     *   does not hold.\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n     */\n    infix fun assertIt(assertionCreator: AssertionPlantNullable<V>.() -> Unit): Assert<T>\n\n    companion object {\n        fun <K, V, T: Map<out K, V>> create(plant: Assert<T>, key: K): MapGetNullableOption<K, V, T>\n            = MapGetNullableOptionImpl(plant, key)\n    }\n}\n\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders.impl.MapGetOptionImpl\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\n\n/**\n * Represents the extension point for another option after a `get key`-step within a\n * sophisticated `get` assertion building process for [Map].\n *\n * @param K The key type of the [Map].\n * @param V the value type of the [Map].\n * @param T A subtype of [Map].\n */\ninterface MapGetOption<K, V : Any, T : Map<out K, V>> {\n    /**\n     * The [AssertionPlant] for which this assertion is created\n     */\n    val plant: Assert<T>\n\n    /**\n     * The given key which will be used to perform the [Map.get].\n     */\n    val key: K\n\n    /**\n     * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the previously specified [key] and that the\n     * corresponding value holds all assertions the given [assertionCreator] might create for it.\n     *\n     * @return This plant to support a fluent API.\n     * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n     * does not hold.\n     * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n     */\n    infix fun assertIt(assertionCreator: Assert<V>.() -> Unit): Assert<T>\n\n    companion object {\n        /**\n         * Creates a [MapGetOption] based on the given [plant] and [key].\n         */\n        fun <K, V : Any, T: Map<out K, V>> create(plant: Assert<T>, key: K): MapGetOption<K, V, T>\n            = MapGetOptionImpl(plant, key)\n    }\n}\n\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders.MapGetNullableOption\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\ninternal class MapGetNullableOptionImpl<K, V, T: Map<out K, V>>(\n    override val plant: Assert<T>,\n    override val key: K\n) : MapGetNullableOption<K, V, T> {\n\n    @Suppress(\"DEPRECATION\")\n    override infix fun assertIt(assertionCreator: AssertionPlantNullable<V>.() -> Unit): Assert<T>\n        = plant.addAssertion(AssertImpl.map.getExistingNullable(plant, key, assertionCreator))\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.MapAssertions\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.mapAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapAssertions].\n * In detail, it implements [MapAssertions] by delegating to [mapAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject MapAssertionsBuilder : MapAssertions {\n\n    /**\n     * Returns [MapEntryAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapEntryAssertions].\n     */\n    inline val entry get() : MapEntryAssertionsBuilder = MapEntryAssertionsBuilder\n\n    override inline fun <K, V : Any, T : Map<out K, V?>> contains(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValuePairs: List<Pair<K, V?>>\n    ) = mapAssertions.contains(assertionContainer, valueType, keyValuePairs)\n\n    override inline fun <K, V : Any, T : Map<out K, V?>> containsKeyWithValueAssertions(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValues: List<Pair<K, (Expect<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(assertionContainer, valueType, keyValues)\n\n\n    override inline fun <K> containsKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsKey(subjectProvider, key)\n\n    override inline fun <K> containsNotKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsNotKey(subjectProvider, key)\n\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isEmpty(subjectProvider)\n\n    override inline fun <K, V, T : Map<out K, V>> getExisting(\n        assertionContainer: Expect<T>,\n        key: K\n    ): ExtractedFeaturePostStep<T, V> = mapAssertions.getExisting(assertionContainer, key)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Map<*, *>> size(assertionContainer: Expect<T>) = mapAssertions.size(assertionContainer)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> contains(\n        plant: AssertionPlant<Map<out K, V>>,\n        keyValuePairs: List<Pair<K, V>>\n    ) = mapAssertions.contains(plant, keyValuePairs)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> containsKeyWithValueAssertions(\n        plant: AssertionPlant<Map<out K, V?>>,\n        keyValues: List<Pair<K, (Assert<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(plant, keyValues)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExisting(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ) = mapAssertions.getExisting(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExistingNullable(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ) = mapAssertions.getExistingNullable(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Map<*, *>>, size: Int) = mapAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> keys(\n        plant: AssertionPlant<Map<out K, *>>,\n        noinline assertionCreator: AssertionPlant<Set<K>>.() -> Unit\n    ): Assertion = mapAssertions.keys(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> values(\n        plant: AssertionPlant<Map<*, V>>,\n        noinline assertionCreator: AssertionPlant<Collection<V>>.() -> Unit\n    ): Assertion = mapAssertions.values(plant, assertionCreator)\n}\n","package ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders.impl\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders.MapGetOption\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\ninternal class MapGetOptionImpl<K, V : Any, T: Map<out K, V>>(\n    override val plant: Assert<T>,\n    override val key: K\n) : MapGetOption<K, V, T> {\n\n    @Suppress(\"DEPRECATION\")\n    override infix fun assertIt(assertionCreator: Assert<V>.() -> Unit): Assert<T>\n        = plant.addAssertion(AssertImpl.map.getExisting(plant, key, assertionCreator))\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.FeatureAssertionGroupType\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.CollectingAssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.PleaseUseReplacementException\nimport kotlin.reflect.*\nimport kotlin.jvm.JvmName\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlant] for the given [property].\n */\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty0<TProperty>): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>): AssertionPlant<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlant] for the given [property].\n */\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty1<T, TProperty>): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant --\n * starting with a group consisting of the [Assertion]s created by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the given [property].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty0<TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant --\n * starting with a group consisting of the [Assertion]s created by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the given [property].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty1<T, TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\nfun <T : Any, TProperty : Any?> Assert<T>.property(property: KProperty0<TProperty>): AssertionPlantNullable<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any?> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>): AssertionPlantNullable<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\nfun <T : Any, TProperty : Any?> Assert<T>.property(property: KProperty1<T, TProperty>): AssertionPlantNullable<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n\n// Arg 0 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds [AssertionGroup]s\n * with a [FeatureAssertionGroupType], containing the assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction0<R>): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction0<R>): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds [AssertionGroup]s\n * with a [FeatureAssertionGroupType], containing the assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction1<T, R>): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction0<R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction0<R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction1<T, R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\nfun <T : Any, R : Any?> Assert<T>.returnValueOf(method: KFunction0<R>): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction0<R>): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, R : Any?> Assert<T>.returnValueOf(method: KFunction1<T, R>): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n\n// Arg 1 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction2<T, T1, R>, arg1: T1): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction2<T, T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\nfun <T : Any, T1, R : Any?> Assert<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, R : Any?> Assert<T>.returnValueOf(method: KFunction2<T, T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n\n// Arg 2 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1] and [arg2], which\n * eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\nfun <T : Any, T1, T2, R : Any?> Assert<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1] and [arg2], which\n * eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, R : Any?> Assert<T>.returnValueOf(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n\n// Arg 3 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\nfun <T : Any, T1, T2, T3, R : Any?> Assert<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, T3, R : Any?> Assert<T>.returnValueOf(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n\n// Arg 4 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3]\n * and [arg4], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\nfun <T : Any, T1, T2, T3, T4, R : Any?> Assert<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3]\n * and [arg4], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, T3, T4, R : Any?> Assert<T>.returnValueOf(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n\n// Arg 5 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created\n * by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created\n * by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3],\n * [arg4] and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the\n * assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> Assert<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3],\n * [arg4] and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the\n * assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> Assert<T>.returnValueOf(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.contain\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.only\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.order\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NotSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Creates an [IterableContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains` assertions.\n *\n * @return The newly created builder.\n */\ninfix fun <E, T : Iterable<E>> Assert<T>.to(@Suppress(\"UNUSED_PARAMETER\") contain: contain): IterableContains.Builder<E, T, NoOpSearchBehaviour>\n    = AssertImpl.iterable.containsBuilder(this)\n\n/**\n * Creates an [IterableContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains not` assertions.\n *\n * @return The newly created builder.\n */\ninfix fun <E, T : Iterable<E>> Assert<T>.notTo(@Suppress(\"UNUSED_PARAMETER\") contain: contain): NotCheckerOption<E, T, NotSearchBehaviour>\n    = NotCheckerOptionImpl(AssertImpl.iterable.containsNotBuilder(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the [expected] value.\n *\n * It is a shortcut for `to contain inAny order atLeast 1 value expected`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> Assert<T>.contains(expected: E)\n    = o to contain inAny order atLeast 1 value expected\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the expected [values].\n *\n * It is a shortcut for `to contain inAny order atLeast 1 the Values(...)`\n *\n * Notice, that it does not search for unique matches. Meaning, if the iterable is `setOf('a', 'b')` and\n * [values].[expected][Values.expected] is defined as `'a'` and\n * one [values].[otherExpected][Values.otherExpected] is defined as `'a'` as well, then both match,\n * even though they match the same entry. Use an option such as [atLeast], [atMost] and [exactly] to control the\n * number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `to contain inAny order exactly 2 value 'a'`\n * instead of:\n *   `contains Values('a', 'a')`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> Assert<T>.contains(values: Values<E>): AssertionPlant<T>\n    = o to contain inAny order atLeast 1 the values\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding the\n * assertions created by [assertionCreatorOrNull] or an entry which is `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n * It is a shortcut for `to contain inAny order atLeast 1 entry assertionCreatorOrNull`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E : Any, T : Iterable<E?>> Assert<T>.contains(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = o to contain inAny order atLeast 1 entry assertionCreatorOrNull\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding the\n * assertions created by [entries].[assertionCreatorOrNull][Entries.assertionCreatorOrNull] or an entry\n * which is `null` in case [entries].[assertionCreatorOrNull][Entries.assertionCreatorOrNull]\n * is defined as `null` -- likewise an entry (can be the same) is searched for each of the\n * [entries].[otherAssertionCreatorsOrNulls][Entries.otherAssertionCreatorsOrNulls].\n *\n * It is a shortcut for `to contain inAny order atLeast 1 the Entries(...)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E : Any, T : Iterable<E?>> Assert<T>.contains(entries: Entries<E>): AssertionPlant<T>\n    = o to contain inAny order atLeast 1 the entries\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only\n * the [expected] value.\n *\n * It is a shortcut for `to contain inGiven order and only value expected`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> Assert<T>.containsExactly(expected: E): AssertionPlant<T>\n    = o to contain inGiven order and only value expected\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only\n * the expected [values] in the defined order.\n *\n * It is a shortcut for `to contain inGiven order and only the Values(...)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> Assert<T>.containsExactly(values: Values<E>): AssertionPlant<T>\n    = o to contain inGiven order and only the values\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only one entry\n * which is holding the assertions created by [assertionCreatorOrNull] or\n * only one entry which is `null` in case [assertionCreatorOrNull] is defined as `null`.\n *\n * It is a shortcut for `to contain inGiven order and only entry assertionCreatorOrNull`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E : Any, T : Iterable<E?>> Assert<T>.containsExactly(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = o to contain inGiven order and only entry assertionCreatorOrNull\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only an entry holding\n * the assertions created by [entries].[assertionCreatorOrNull][Entries.assertionCreatorOrNull] or\n * `null` in case [entries].[assertionCreatorOrNull][Entries.assertionCreatorOrNull] is defined as `null`\n * and likewise an additional entry for each\n * [entries].[otherAssertionCreatorsOrNulls][Entries.otherAssertionCreatorsOrNulls] (if given)\n * whereas the entries have to appear in the defined order.\n *\n * It is a shortcut for `to contain inGiven order and only the Entries(...)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E : Any, T : Iterable<E?>> Assert<T>.containsExactly(entries: Entries<E>): AssertionPlant<T>\n    = o to contain inGiven order and only the entries\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the [expected] value.\n *\n * It is a shortcut for `notTo contain value expected`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> Assert<T>.containsNot(expected: E): AssertionPlant<T>\n    = o notTo contain value expected\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the expected [values].\n *\n * It is a shortcut for `notTo contain the Values(...)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> Assert<T>.containsNot(values: Values<E>): AssertionPlant<T>\n    = o notTo contain the values\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding\n * the assertions created by the [assertionCreatorOrNull] or an entry\n * which is `null` in case [assertionCreatorOrNull] is defined as `null`.\n *\n * It is a shortcut for `to contain inAny order atLeast 1 entry assertionCreatorOrNull`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E : Any, T : Iterable<E?>> Assert<T>.any(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = o to contain inAny order atLeast 1 entry assertionCreatorOrNull\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain a single entry\n * which holds all assertions created by [assertionCreatorOrNull]\n * or does not contain a single entry which is `null` in case [assertionCreatorOrNull] is defined as `null`.\n *\n *  It is a shortcut for `notTo contain entry assertionCreatorOrNull`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E : Any, T : Iterable<E?>> Assert<T>.none(assertionCreatorOrNull: (Assert<E>.() -> Unit)?)\n    = o notTo contain entry assertionCreatorOrNull\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] has at least one element and\n * that every element holds all assertions created by the\n * [assertionCreatorOrNull] or that all elements are `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <E : Any, T : Iterable<E?>> Assert<T>.all(assertionCreatorOrNull: (Assert<E>.() -> Unit)?)\n    = addAssertion(AssertImpl.iterable.all(this, assertionCreatorOrNull))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.*\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.iterable.contains.builders.impl.*\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we are looking\n * for occurs `at least` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\ninfix fun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.atLeast(times: Int): AtLeastCheckerOption<E, T, S>\n    = AtLeastCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains at least` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `at most` number of [times] within the [Iterable].\n *\n * The resulting restriction will be a `contains at least but at most` assertion.\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] of this `at most` restriction equals to the number of the\n *   `at least` restriction; use the [exactly] restriction instead.\n */\ninfix fun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> AtLeastCheckerOption<E, T, S>.butAtMost(times: Int): ButAtMostCheckerOption<E, T, S>\n    = ButAtMostCheckerOptionImpl(times, this, containsBuilder)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `exactly` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\ninfix fun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.exactly(times: Int): ExactlyCheckerOption<E, T, S>\n    = ExactlyCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `at least` once but `at most` number of [times] within the [Iterable].\n *\n * If you want to use a higher lower bound than one, then use `atLeast(2).butAtMost(3)` instead of `atMost(3)`.\n * And in case you want to state that it is either not contained at all or at most a certain number of times,\n * then use `notOrAstMost(2)` instead.\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] equals to one; use [exactly] instead.\n */\ninfix fun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.atMost(times: Int): AtMostCheckerOption<E, T, S>\n    = AtMostCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `not at all or at most` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\ninfix fun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.notOrAtMost(times: Int): NotOrAtMostCheckerOption<E, T, S>\n    = NotOrAtMostCheckerOptionImpl(times, this)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInAnyOrderCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value shall be searched within the [Iterable].\n *\n * Delegates to `the Values(expectedOrNull)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>.value(expected: E): AssertionPlant<T>\n    = this the Values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [values]\n * shall be searched within the [Iterable].\n *\n * Notice, that it does not search for unique matches. Meaning, if the iterable is `setOf('a', 'b')` and\n * [values].[expected][Values.expected] is defined as `'a'` and one\n * [values].[otherExpected][Values.otherExpected] is defined as `'a'` as well, then both match,\n * even though they match the same entry. Use an option such as [atLeast], [atMost] and [exactly] to control the\n * number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `to contain inAny order exactly 2 value 'a'`\n * instead of:\n *   `to contain inAny order exactly 1 the Values('a', 'a')`\n *\n * @param values The values which are expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>.the(values: Values<E>): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInAnyOrder(this, values.toList()))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry shall be searched which either\n * holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * Delegates to `the Entries(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking for\n *   has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E : Any, T : Iterable<E?>> IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>.entry(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = this the Entries(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry shall be searched which either\n * holds all assertions [entries].[assertionCreatorOrNull][Entries.assertionCreatorOrNull] might create or\n * needs to be `null` in case [entries].[assertionCreatorOrNull][Entries.otherAssertionCreatorsOrNulls]\n * is defined as `null` -- likewise an entry (can be the same) is searched for each of\n * the [entries].[otherAssertionCreatorsOrNulls][Entries.otherAssertionCreatorsOrNulls].\n *\n * @param entries The parameter object which contains the identification lambdas.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <E : Any, T : Iterable<E?>> IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>.the(entries: Entries<E>): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInAnyOrderWithAssert(this, entries.toList()))\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nprivate fun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.CheckerOption<E, T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInAnyOrderOnlyCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderOnlySearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] must contain only the\n * [expected] value.\n *\n * Delegates to `the Values(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>.value(expected: E): AssertionPlant<T>\n    = this the Values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [values]\n * must be contained in [Iterable] but it does not matter in which order.\n *\n * @param values The values which are expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>.the(values: Values<E>): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInAnyOrderOnly(this, values.toList()))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] must contain only one\n * entry which holds all assertions created by the given [assertionCreatorOrNull] or has to be `null` in case\n * [assertionCreatorOrNull] is defined as `null`.\n *\n * Delegates to `the Entries(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>.entry(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = this the Entries(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry needs to be contained in the\n * [Iterable] which holds all assertions [entries].[assertionCreatorOrNull][Entries.assertionCreatorOrNull]\n * might create or it needs to be `null` in case\n * [entries].[assertionCreatorOrNull][Entries.assertionCreatorOrNull] is defined as `null` -- likewise an\n * entry for each [entries].[otherAssertionCreatorsOrNulls][Entries.otherAssertionCreatorsOrNulls] needs to\n * be contained in the [Iterable] where it does not matter in which order the entries appear but only as many entries\n * should be returned by the [Iterable] as assertion creators are defined.\n *\n * Notice, that a first-wins strategy applies which means your assertion creator lambdas -- which kind of serve as\n * identification lambdas -- should be ordered in such a way that the most specific identification lambda appears\n * first, not that a less specific lambda wins. For instance, given a `setOf(1, 2)` you should not search for\n * `Entries({ isGreaterThan(0) }, { toBe(1) })` but for `Entries({ toBe(1) }, { isGreaterThan(0) })`\n * otherwise `isGreaterThan(0)` matches `1` before `toBe(1)` would match it. As a consequence `toBe(1)` could\n * only match the entry which is left -- in this case `2` -- and of course this would fail.\n *\n * @param entries The parameter object containing the identification lambdas.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>.the(entries: Entries<E>): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInAnyOrderOnlyWithAssert(this, entries.toList()))\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\ninternal fun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.Builder<E, T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInOrderOnlyCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlySearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value.\n *\n * Delegates to `the Values(expected)`.\n *\n * @param expected The nullable value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.value(expected: E): AssertionPlant<T>\n    = this the Values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * expected [values] in the specified order.\n *\n * @param values The nullable values which are expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.the(values: Values<E>): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInOrderOnly(this, values.toList()))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only a\n * single entry which holds all assertions created by the given [assertionCreatorOrNull] or needs to be `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n * Delegates to `the Entries(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>.entry(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = this the Entries(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only an\n * entry which holds all assertions [entries].[assertionCreatorOrNull][Entries.assertionCreatorOrNull]\n * might create or is `null` in case [entries].[assertionCreatorOrNull][Entries.otherAssertionCreatorsOrNulls]\n * is defined as `null` and likewise a further entry for each\n * [entries].[otherAssertionCreatorsOrNulls][Entries.otherExpected]\n * (if given) whereas the entries have to appear in the specified order.\n *\n * This function will be renamed on the JVM level to `the` with 1.0.0;\n *\n * @param entries The parameter object containing the identification lambdas.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>.the(entries: Entries<E>): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInOrderOnlyWithAssert(this, entries.toList()))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInOrderOnlyGroupedCreatorsKt\")\n\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.utils.Group\nimport ch.tutteli.atrium.domain.builders.utils.groupsToList\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlyGroupedWithinSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [Order.firstGroup] as well as\n * the [Order.secondGroup] and optionally [Order.otherExpectedGroups] of values need to be\n * contained in [Iterable] in the specified order whereas the values within the groups can occur in any order.\n *\n * @param order A parameter object containing the different groups which have to appear in order in the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlyGroupedWithinSearchBehaviour>.inAny(\n    order: Order<E, Group<E>>\n): AssertionPlant<T> = addAssertion(\n    AssertImpl.iterable.contains.valuesInOrderOnlyGrouped(\n        this,\n        groupsToList(order.firstGroup, order.secondGroup, order.otherExpectedGroups)\n    )\n)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [Order.firstGroup] as well as\n * the [Order.secondGroup] and optionally [Order.otherExpectedGroups] of identification lambdas, identifying an entry,\n * need to be contained in [Iterable] in the specified order whereas the identification lambdas within the groups\n * can occur in any order.\n *\n * An identification lambda can also be defined as `null` in which case it matches an entry which is `null` as well.\n *\n * @param order A parameter object containing the different groups which have to appear in order in the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"inAnyOrderEntries\")\ninfix fun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlyGroupedWithinSearchBehaviour>.inAny(\n    order: Order<(Assert<E>.() -> Unit)?, Group<(Assert<E>.() -> Unit)?>>\n): AssertionPlant<T> = addAssertion(\n    AssertImpl.iterable.contains.entriesInOrderOnlyGroupedWithAssert(\n        this,\n        groupsToList(order.firstGroup, order.secondGroup, order.otherExpectedGroups)\n    )\n)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.entries\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.group\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.only\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.order\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.*\n\n/**\n * Defines that the search behaviour \"find entries `in any order` in the [Iterable]\" shall be applied to this\n * sophisticated `contains` in [Iterable] assertion.\n *\n * @param order Has to be `order`.\n *\n * @return The newly created builder.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, NoOpSearchBehaviour>.inAny(@Suppress(\"UNUSED_PARAMETER\") order: order)\n    = AssertImpl.iterable.contains.searchBehaviours.inAnyOrder(this)\n\n/**\n * Defines that the constraint \"`only` the specified entries exist in the [Iterable]\" shall be applied to this\n * sophisticated `contains` [Iterable] assertion.\n *\n * @return The newly created builder.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>.but(@Suppress(\"UNUSED_PARAMETER\") only: only)\n    = AssertImpl.iterable.contains.searchBehaviours.inAnyOrderOnly(this)\n\n\n/**\n * Defines that the search behaviour \"find entries `in order` in the [Iterable]\" shall be applied to this\n * sophisticated `contains` in [Iterable] assertion.\n *\n * @param order Has to be `order`.\n *\n * @return The newly created builder.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, NoOpSearchBehaviour>.inGiven(@Suppress(\"UNUSED_PARAMETER\") order: order)\n    = AssertImpl.iterable.contains.searchBehaviours.inOrder(this)\n\n/**\n * Defines that the constraint \"`only` the specified entries exist in the [Iterable]\" shall be applied to this\n * sophisticated `contains in order` [Iterable] assertion.\n *\n * @return The newly created builder.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderSearchBehaviour>.and(@Suppress(\"UNUSED_PARAMETER\") only: only)\n    = AssertImpl.iterable.contains.searchBehaviours.inOrderOnly(this)\n\n/**\n * Defines that the [Iterable] contains groups of entries `in order only` where the entries within the group can be in\n * any order.\n *\n * @return The newly created builder.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.grouped(@Suppress(\"UNUSED_PARAMETER\") entries: entries)\n    = AssertImpl.iterable.contains.searchBehaviours.inOrderOnlyGrouped(this)\n\n/**\n * Defines that the [Iterable] contains groups of entries `in order only` where the entries within the group can be in\n * any order.\n *\n * @return The newly created builder.\n */\ninfix fun <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>.within(@Suppress(\"UNUSED_PARAMETER\") group: group)\n    = AssertImpl.iterable.contains.searchBehaviours.inOrderOnlyGroupedWithin(this)\n","@file:Suppress(\"ClassName\")\npackage ch.tutteli.atrium.api.cc.infix.en_GB.keywords\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.and\nimport ch.tutteli.atrium.api.cc.infix.en_GB.grouped\nimport ch.tutteli.atrium.api.cc.infix.en_GB.ignoring\nimport ch.tutteli.atrium.api.cc.infix.en_GB.inAny\nimport ch.tutteli.atrium.api.cc.infix.en_GB.to\nimport ch.tutteli.atrium.api.cc.infix.en_GB.within\n\n/**\n * Marker interface for keywords.\n *\n * For instance, can be used to add a deprecated overload in case an assertion function accepts Any as argument type\n * (see toBe).\n */\ninterface Keyword\ninternal const val ERR_KEYWORD_GIVEN_COLLECTION_ASSUMED = \"This call will most probably fail at runtime because the given subject is not a collection as you might have assumed. If you really want to compare the subject against the keyword, then cast the keyword to Any\"\n\n/**\n * Represents a helper construct which allows to express emptiness.\n * It can be used for a parameter less function so that it has one parameter and thus can be used as infix function.\n */\nobject Empty: Keyword\n\n/**\n * Represents a helper construct which allows to express blankness.\n * It can be used for a parameter less function so that it has one parameter and thus can be used as infix function.\n */\nobject Blank: Keyword\n\n/**\n * Represents the pseudo keyword `contain` as in [to] `contain`.\n */\nobject contain: Keyword\n\n/**\n * Represents the pseudo keyword `case` as in [ignoring] `case`.\n */\nobject case: Keyword\n\n/**\n * Represents the pseudo keyword `entries` as in [grouped] `entries`.\n */\nobject entries: Keyword\n\n/**\n * Represents the pseudo keyword `group` as in [within] `group`.\n */\nobject group: Keyword\n\n/**\n * Represents the pseudo keyword `only` as in [and] `only`.\n */\nobject only: Keyword\n\n/**\n * Represents the pseudo keyword `order` as in [inAny] `order`.\n */\nobject order: Keyword\n\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders.ListGetNullableOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.list.get.builders.ListGetOption\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject],\n * creates a feature assertion plant for the corresponding element and returns the newly created plant.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the given [index] is out of bound.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <E: Any, T: List<E>> Assert<T>.get(index: Int)\n    = AssertImpl.list.get(this, index)\n\n/**\n * Prepares the assertion about the return value of calling [get][List.get] with the given [index].\n *\n * @return A fluent builder to finish the assertion.\n */\ninfix fun <E : Any, T: List<E>> Assert<T>.get(index: Index): ListGetOption<E, T>\n    = ListGetOption.create(this, index.index)\n\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject],\n * creates a feature assertion plant for the corresponding nullable element and returns the newly created plant.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the given [index] is out of bound.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <E, T: List<E>> Assert<T>.get(index: Int)\n    = AssertImpl.list.getNullable(this, index)\n\n/**\n * Prepares the assertion about the nullable return value of calling [get][List.get] with the given [index].\n *\n * Notice, that the corresponding element of the given [index] can be `null` even if the index is within bounds\n * as the [List] has a nullable element type.\n *\n * @return A fluent builder to finish the assertion.\n */\ninfix fun <E, T: List<E>> Assert<T>.get(index: Index): ListGetNullableOption<E, T>\n    = ListGetNullableOption.create(this, index.index)\n\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders.MapGetNullableOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.creating.map.get.builders.MapGetOption\nimport ch.tutteli.atrium.api.cc.infix.en_GB.keywords.Empty\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\nimport kotlin.js.JsName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a key as defined by\n * [keyValuePair]'s [Pair.first] with a corresponding value as defined by [keyValuePair]'s [Pair.second].\n *\n * Delegates to `contains Pairs(keyValuePair)`.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <K, V, T: Map<out K, V>> Assert<T>.contains(keyValuePair: Pair<K, V>)\n    = this contains Pairs(keyValuePair)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains for each entry in [keyValuePairs],\n * a key as defined by entry's [Pair.first] with a corresponding value as defined by entry's [Pair.second].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K, V, T: Map<out K, V>> Assert<T>.contains(keyValuePairs: Pairs<K, V>)\n    = addAssertion(AssertImpl.map.contains(this, keyValuePairs.toList()))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a key as defined by [keyValue]'s [KeyValue.key]\n * with a corresponding value which either holds all assertions [keyValue]'s\n * [KeyValue.valueAssertionCreatorOrNull] might create or needs to be `null` in case\n * [KeyValue.valueAssertionCreatorOrNull] is defined as `null`.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <K, V : Any, T: Map<out K, V?>> Assert<T>.contains(keyValue: KeyValue<K, V>)\n    = contains(All(keyValue))\n\n/**\n * Makes the assertion that for each of the [KeyValue] in [keyValues], the [Assert.subject][SubjectProvider.subject] contains\n * a key as defined by keyValue's [KeyValue.key] with a corresponding value which either holds all assertions\n * keyValue's [KeyValue.valueAssertionCreatorOrNull] might create or needs to be `null` in case\n * [KeyValue.valueAssertionCreatorOrNull] is defined as `null`.\n *\n * Notice, that it does not search for unique matches. Meaning, if the map is `mapOf('a' to 1)` and one of the\n * [keyValues] is defined as `Key('a') { isGreaterThan(0) }` and another one is defined as `Key('a') { isLessThan(2) }`\n * then both match, even though they match the same entry.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K, V : Any, T: Map<out K, V?>> Assert<T>.contains(keyValues: All<KeyValue<K, V>>)\n    = addAssertion(AssertImpl.map.containsKeyWithValueAssertions(this, keyValues.toList().map { it.toPair() }))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <K> Assert<Map<out K, *>>.containsKey(key: K)\n    = addAssertion(AssertImpl.map.containsKey(this, key))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the given [key].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <K> Assert<Map<out K, *>>.containsNotKey(key: K)\n    = addAssertion(AssertImpl.map.containsNotKey(this, key))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key], creates a feature\n * assertion plant for the corresponding value and returns the newly created plant.\n *\n * @return The newly created plant for the feature\n * @throws AssertionError Might throw an [AssertionError] if the given [key] does not exist.\n */\n@Suppress(\"DEPRECATION\")\n@JsName(\"getExisting\")\ninfix fun <K, V: Any, T: Map<out K, V>> Assert<T>.getExisting(key: K): Assert<V>\n    = AssertImpl.map.getExisting(this, key)\n\n/**\n * Prepares the assertion about the return value of calling [get][Map.get] with the given [key].\n *\n * @return A fluent builder to finish the assertion.\n */\ninfix fun <K, V: Any, T: Map<out K, V>> Assert<T>.getExisting(key: Key<K>): MapGetOption<K, V, T>\n    = MapGetOption.create(this, key.key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key], creates a feature\n * assertion plant for the corresponding nullable value and returns the newly created plant.\n *\n * @return The newly created plant for the feature\n * @throws AssertionError Might throw an [AssertionError] if the given [key] does not exist.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K, V, T: Map<out K, V>> Assert<T>.getExisting(key: K)\n    = AssertImpl.map.getExistingNullable(this, key)\n\n/**\n * Prepares the assertion about the nullable return value of calling [get][Map.get] with the given [key].\n *\n * Notice, that the corresponding value of the given [key] can be `null` even if the key exists as the [Map] has a\n * nullable value type.\n *\n * @return A fluent builder to finish the assertion.\n */\ninfix fun <K, V, T: Map<out K, V>> Assert<T>.getExisting(key: Key<K>): MapGetNullableOption<K, V, T>\n    = MapGetNullableOption.create(this, key.key)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Map.size] is [size].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <T : Map<*, *>> Assert<T>.hasSize(size: Int)\n    = addAssertion(AssertImpl.map.hasSize(this, size))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is an empty [Map].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Map<*, *>> Assert<T>.toBe(@Suppress(\"UNUSED_PARAMETER\") Empty: Empty)\n    = addAssertion(AssertImpl.map.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not an empty [Map].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninfix fun <T : Map<*, *>> Assert<T>.notToBe(@Suppress(\"UNUSED_PARAMETER\") Empty: Empty)\n    = addAssertion(AssertImpl.map.isNotEmpty(this))\n\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [keys][Map.keys] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <K, V> Assert<Map<out K, V>>.keys get() : Assert<Set<K>> = property(Map<out K, V>::keys)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [keys][Map.keys] holds all assertions the given\n * [assertionCreator] might create.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K, V, T: Map<out K, V>> Assert<T>.keys(assertionCreator: Assert<Set<K>>.() -> Unit)\n    = addAssertion(AssertImpl.map.keys(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [values][Map.values] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <K, V> Assert<Map<out K, V>>.values get() : Assert<Collection<V>> = property(Map<out K, V>::values)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [values][Map.values] holds all assertions the given\n * [assertionCreator] might create.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K, V, T: Map<out K, V>> Assert<T>.values(assertionCreator: Assert<Collection<V>>.() -> Unit)\n    = addAssertion(AssertImpl.map.values(this, assertionCreator))\n\n/**\n * Turns `Assert<Map<out K, V>>` into `Assert<Set<Map.Entry<K, V>>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `property(subject::entries)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\nfun <K, V> Assert<Map<out K, V>>.asEntries(): Assert<Set<Map.Entry<K, V>>>\n    = ExpectImpl.changeSubject(this).unreported { it.entries }\n\n/**\n * Turns `Assert<Map<out K, V>>` into `Assert<Set<Map.Entry<K, V>>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `property(subject::entries)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\ninfix fun <K, V> Assert<Map<out K, V>>.asEntries(assertionCreator: Assert<Set<Map.Entry<K, V>>>.() -> Unit): Assert<Set<Map.Entry<K, V>>>\n    = asEntries().addAssertionsCreatedBy(assertionCreator)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Map.Entry.key] is (equal to) the given [Pair.first] and\n * [Map.Entry.value] is [Pair.second].\n *\n * Kind of a shortcut for `key.toBe(keyValuePair.first); value.toBe(keyValuePair.second)` but should be evaluated in\n * an assertion group block -- which has the effect that the assertion about the value is still evaluated even\n * if the assertion about the key fails. Moreover, it might be that reporting differs compared to using the long form.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K : Any, V : Any> Assert<Map.Entry<K, V>>.isKeyValue(keyValuePair: Pair<K, V>): Assert<Map.Entry<K, V>>\n    = addAssertion(AssertImpl.map.entry.isKeyValue(this, keyValuePair.first, keyValuePair.second))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <K : Any> Assert<Map.Entry<K, *>>.key get() : Assert<K> = property(Map.Entry<K, *>::key)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] (which could be `null`)\n * so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <K> Assert<Map.Entry<K, *>>.key get() : AssertionPlantNullable<K> = property(Map.Entry<K, *>::key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K : Any, V> Assert<Map.Entry<K, V>>.key(assertionCreator: Assert<K>.() -> Unit)\n    = addAssertion(AssertImpl.map.entry.key(this, assertionCreator))\n\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <V : Any> Assert<Map.Entry<*, V>>.value get() : Assert<V> = property(Map.Entry<*, V>::value)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value]\n * (which could be `null`) so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <V> Assert<Map.Entry<*, V>>.value get() : AssertionPlantNullable<V> = property(Map.Entry<*, V>::value)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K, V: Any> Assert<Map.Entry<K, V>>.value(assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.map.entry.value(this, assertionCreator))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.mapEntryAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapEntryAssertions].\n * In detail, it implements [MapEntryAssertions] by delegating to [mapEntryAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject MapEntryAssertionsBuilder : MapEntryAssertions {\n    override inline fun <K : Any, V : Any, T : Map.Entry<K, V>> isKeyValue(\n        assertionContainer: Expect<T>,\n        key: K,\n        value: V\n    ) = mapEntryAssertions.isKeyValue(assertionContainer, key, value)\n\n    override inline fun <K : Any, V : Any, T : Map.Entry<K?, V?>> isKeyValue(\n        assertionContainer: Expect<T>,\n        key: K?,\n        value: V?,\n        keyType: KClass<K>,\n        valueType: KClass<V>\n    ) = mapEntryAssertions.isKeyValue(assertionContainer, key, value, keyType, valueType)\n\n    override inline fun <K, T : Map.Entry<K, *>> key(assertionContainer: Expect<T>) =\n        mapEntryAssertions.key(assertionContainer)\n\n    override inline fun <V, T : Map.Entry<*, V>> value(assertionContainer: Expect<T>) =\n        mapEntryAssertions.value(assertionContainer)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any, V : Any> isKeyValue(\n        plant: AssertionPlant<Map.Entry<K, V>>,\n        key: K,\n        value: V\n    ): Assertion = mapEntryAssertions.isKeyValue(plant, key, value)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> key(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.key(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> value(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.value(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableKey(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableKey(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableValue(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableValue(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <K : Any> Assert<Pair<K, *>>.first get() : Assert<K> = property(Pair<K, *>::first)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] (which could be `null`)\n * so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <K> Assert<Pair<K, *>>.first get() : AssertionPlantNullable<K> = property(Pair<K, *>::first)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K : Any, V> Assert<Pair<K, V>>.first(assertionCreator: Assert<K>.() -> Unit)\n    = addAssertion(AssertImpl.pair.first(this, assertionCreator))\n\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <V : Any> Assert<Pair<*, V>>.second get() : Assert<V> = property(Pair<*, V>::second)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second]\n * (which could be `null`) so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreatorOrNull lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\nval <V> Assert<Pair<*, V>>.second get() : AssertionPlantNullable<V> = property(Pair<*, V>::second)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Suppress(\"DEPRECATION\")\ninfix fun <K, V: Any> Assert<Pair<K, V>>.second(assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.pair.second(this, assertionCreator))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.PairAssertions\nimport ch.tutteli.atrium.domain.creating.pairAssertions\n\n/**\n * Delegates inter alia to the implementation of [PairAssertions].\n * In detail, it implements [PairAssertions] by delegating to [pairAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject PairAssertionsBuilder : PairAssertions {\n\n    override inline fun <K, T : Pair<K, *>> first(assertionContainer: Expect<T>) =\n        pairAssertions.first(assertionContainer)\n\n    override inline fun <V, T : Pair<*, V>> second(assertionContainer: Expect<T>) =\n        pairAssertions.second(assertionContainer)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> first(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = pairAssertions.first(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> second(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = pairAssertions.second(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableFirst(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = pairAssertions.nullableFirst(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableSecond(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = pairAssertions.nullableSecond(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"ParameterObjectsKt\")\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.utils.*\nimport ch.tutteli.kbox.glue\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n\n/**\n * Parameter object to express `T, vararg T` in the infix-api.\n */\nclass All<out T>(override val expected: T, override vararg val otherExpected: T) : VarArgHelper<T>\n\n\n/**\n * Parameter object to express a [Group] with a single identification lambda.\n *\n * @param assertionCreatorOrNull The identification lambda identifying the entry where an entry is considered\n *   to be identified if it holds all [Assertion]s the lambda might create.\n *   In case it is defined as `null`, then an entry is identified if it is `null` as well.\n */\nclass Entry<in T: Any>(\n    val assertionCreatorOrNull: (Assert<T>.() -> Unit)?\n): GroupWithoutNullableEntries<(Assert<T>.() -> Unit)?>, GroupWithNullableEntries<(Assert<T>.() -> Unit)?> {\n    override fun toList(): List<(Assert<T>.() -> Unit)?> = listOf(assertionCreatorOrNull)\n}\n\n/**\n * Parameter object to express a [Group] of identification lambdas.\n *\n * It is also used to express `(Assert<T>.() -> Unit)?, vararg (Assert<T>.() -> Unit)?` at other places the infix-api.\n *\n * In case `null` is used for an identification lambda then it is expected that the corresponding entry\n * is `null` as well.\n *\n * @param assertionCreatorOrNull The identification lambda identifying the entry where an entry is considered\n *   to be identified if it holds all [Assertion]s the lambda might create.\n *   In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls A variable amount of additional identification lambdas or `null`s.\n */\nclass Entries<in T : Any>(\n    val assertionCreatorOrNull: (Assert<T>.() -> Unit)?,\n    vararg val otherAssertionCreatorsOrNulls: (Assert<T>.() -> Unit)?\n) : GroupWithoutNullableEntries<(Assert<T>.() -> Unit)?>, GroupWithNullableEntries<(Assert<T>.() -> Unit)?>, VarArgHelper<(Assert<T>.() -> Unit)?> {\n    override val expected get() = assertionCreatorOrNull\n    override val otherExpected get() = otherAssertionCreatorsOrNulls\n\n    override fun toList(): List<(Assert<T>.() -> Unit)?> = assertionCreatorOrNull glue otherAssertionCreatorsOrNulls\n}\n\n/**\n * Wrapper for a single index -- can be used as distinguishable type for an overload where Int is already in use.\n */\ndata class Index(val index: Int)\n\n/**\n * Wrapper for a single key -- can be used as distinguishable type for an overload where [K] is already in use.\n */\ndata class Key<out K>(val key: K)\n\n/**\n * Parameter object to express a key/value [Pair] whose value type is a lambda with an\n * [Assert][AssertionPlant] receiver, which means one can either pass a lambda or `null`.\n */\ndata class KeyValue<out K, V : Any>(val key: K, val valueAssertionCreatorOrNull: (Assert<V>.() -> Unit)?) {\n    fun toPair(): Pair<K, (Assert<V>.() -> Unit)?> = key to valueAssertionCreatorOrNull\n    override fun toString(): String\n        = \"KeyValue(key=$key, value=${if (valueAssertionCreatorOrNull == null) \"null\" else \"lambda\"})\"\n}\n\n\n/**\n * Parameter object to express `Group<T>, Group<T>, vararg Group<T>` in the infix-api.\n *\n * Notice, most probably the type parameter G will be removed in the future, will be fixed to [Group].\n */\nclass Order<out T, out G : Group<T>>(\n    val firstGroup: G,\n    val secondGroup: G,\n    vararg val otherExpectedGroups: G\n)\n\n/**\n * Parameter object to express `Pair<K, V>, vararg Pair<K, V>` in the infix-api.\n */\nclass Pairs<out K, out V>(\n    override val expected: Pair<K, V>,\n    override vararg val otherExpected: Pair<K, V>\n) : VarArgHelper<Pair<K, V>>\n\n/**\n * Parameter object to express `String, vararg String` in the infix-api.\n */\nclass RegexPatterns(pattern: String, vararg otherPatterns: String) : VarArgHelper<String> {\n    override val expected = pattern\n    override val otherExpected = otherPatterns\n}\n\n\n/**\n * Represents a [Group] with a single value.\n */\ndata class Value<out T>(val expected: T) : GroupWithNullableEntries<T>, GroupWithoutNullableEntries<T> {\n    override fun toList() = listOf(expected)\n}\n\n/**\n * Represents a [Group] of multiple values.\n */\nclass Values<out T>(\n    override val expected: T,\n    override vararg val otherExpected: T\n) : GroupWithoutNullableEntries<T>, GroupWithNullableEntries<T>, VarArgHelper<T>  {\n    override fun toList() = listOf(expected, *otherExpected)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\n\n/**\n * Turns `Assert<Sequence<E>>` into `Assert<Iterable<E>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Sequence::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\nfun <E> Assert<Sequence<E>>.asIterable(): Assert<Iterable<E>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\n\n/**\n *  Makes the assertion that the thrown [Throwable] is of type [TExpected] and holds all assertions the\n * [assertionCreator] might create in addition.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion (a [Throwable] was thrown) holds or not.\n * Define subsequent assertions via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninline infix fun <reified TExpected : Throwable> ThrowableThrown.Builder.toThrow(noinline assertionCreator: Assert<TExpected>.() -> Unit) {\n    @Suppress(\"DEPRECATION\")\n    AssertImpl.throwable.thrown.toBe(this, TExpected::class, assertionCreator)\n}\n\n/**\n * Makes the assertion that no [Throwable] is thrown at all.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because we assume nothing happens,\n *   so there is nothing we could make assertions on in addition.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\nfun ThrowableThrown.Builder.notToThrow(){\n    @Suppress(\"DEPRECATION\")\n    AssertImpl.throwable.thrown.nothingThrown(this)\n}\n\n/**\n * Creates an [AssertionPlantNullable] for the [message][Throwable.message] of the plant's\n * [subject][SubjectProvider.subject] (which is a [Throwable]) and makes the assertion that the message ought\n * [notToBeNull] and uses [assertionCreator] which might create further [Assertion]s which are lazily evaluated at the end.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion [message][Throwable.message] is not null) holds or not.\n * Define subsequent assertions via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] in case [message][Throwable.message] is `null`\n *   or if an additionally created [Assertion]s (by calling [assertionCreator]) does not hold.\n */\ninfix fun <T : Throwable> Assert<T>.message(assertionCreator: Assert<String>.() -> Unit) {\n    property(Throwable::message).notToBeNull(assertionCreator)\n}\n\n/**\n * Creates the assertion that the [Throwable]'s [message][Throwable.message] is not null (see [message]) and contains\n * the [toString] representation of the given [expected] using a non disjoint search.\n *\n * It is a shortcut for `message { this to contain atLeast 1 value expected }`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion [message][Throwable.message] is not null) holds or not.\n *\n * @throws AssertionError Might throw an [AssertionError] in case [message][Throwable.message] is `null`\n *   or does not contain the [expected] object.\n */\ninfix fun <T : Throwable> Assert<T>.messageContains(expected: Any) {\n    this messageContains Values(expected)\n}\n\n/**\n * Creates the assertion that the [Throwable]'s [message][Throwable.message] is not null (see [message]) and contains\n * the [toString] representation of the given [values] using a non disjoint search.\n *\n * It is a shortcut for `message { this to contain atLeast 1 the values }`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed as\n * [values] (this function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion [message][Throwable.message] is not null) holds or not.\n *\n * @throws AssertionError Might throw an [AssertionError] in case [message][Throwable.message] is `null`\n *   or does not contain all the [values].\n */\ninfix fun <T : Throwable> Assert<T>.messageContains(values: Values<Any>) {\n    message { contains(values) }\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"TypeTransformationAssertionsKt\")\n\npackage ch.tutteli.atrium.api.cc.infix.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that [AssertionPlantNullable.subject][SubjectProvider.subject] is not null and if so, uses [assertionCreator]\n * which could create further assertions which are added as a group.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion ([Assert.subject][SubjectProvider.subject] is not null) holds or not. Define subsequent assertions\n *   via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Suppress(\"DEPRECATION\")\ninline infix fun <reified T : Any> AssertionPlantNullable<T?>.notToBeNull(noinline assertionCreator: Assert<T>.() -> Unit) {\n    addAssertion(AssertImpl.any.isNotNull(this, T::class, assertionCreator))\n}\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] *is a* [TSub] (the same type or a sub-type) and if so,\n * uses [assertionCreator] which could create further assertions which are added as a group.\n *\n * Notice, that asserting a function type is [flawed](https://youtrack.jetbrains.com/issue/KT-27846).\n * The actual types are ignored as function types erase to Function0,\n * Function1 etc. on byte code level, which means the assertion holds as long as the [Assert.subject][SubjectProvider.subject] is a\n * function and has the same amount of arguments regardless if the types differ. For instance\n * `assert({x: Int -> \"hello\"}).isA<String -> Unit>{}` holds, even though `(Int) -> String` is clearly not\n * a `(String) -> Unit`.\n *\n * More generally speaking, the [flaw](https://youtrack.jetbrains.com/issue/KT-27826) applies to all generic types.\n * For instance `isA<List<String>>` would only check if the [Assert.subject][SubjectProvider.subject] is a `List` without checking if\n * the element type is actually `String`. Or in other words\n * `assert(listOf(1, 2)).isA<List<String>>{}` holds, even though `List<Int>` is clearly not a `List<String>`.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion ([Assert.subject][SubjectProvider.subject] *is a* [TSub]) holds or not. Define subsequent assertions\n *   via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\ninline infix fun <reified TSub : Any> Assert<Any>.isA(noinline assertionCreator: AssertionPlant<TSub>.() -> Unit) {\n    @Suppress(\"DEPRECATION\")\n    AssertImpl.any.typeTransformation.isA(this, TSub::class, assertionCreator)\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;iBAmC4B,4E;mBCXxB,gH;;;;;;;;;;8BCgBA,2G;;iBCiCA,+I;gCCgtCJ,yD;uBAAA,gD;mBC/wCA,qC;yBFiHI,uJ;;;;;;;;;;;;;;;;;;;;;;;;4BG/FA,mI;mBC2CA,2I;;;2BAsFA,mJ;;;;;;;qBC5IJ,oD;;;;mBC6CI,0I;;;;;;;;;;;;;;;;;;;;;;;;;EC7CJ,mC;IVkBoC,6B;IUR9B,sCTFE,wBAAc,cSEiB,STFjB,ESEuB,QTFvB,CSEhB,C;G;EAEN,oC;IAGM,MAAM,kCAA8B,4BAA9B,C;G;EAEZ,sC;IVCoC,6B;IUS9B,sCThBE,wBAAc,iBSgBoB,SThBpB,ESgB0B,QThB1B,CSgBhB,C;G;EAEN,uC;IAGM,MAAM,kCAA8B,+BAA9B,C;G;EAEZ,uC;IVhBoC,6B;IU0B9B,sCT9BE,wBAAc,gBS8BmB,ST9BnB,ES8ByB,QT9BzB,CS8BhB,C;G;EAEN,0C;IV5BoC,6B;IUsC9B,sCTvCE,wBAAc,mBSuCsB,STvCtB,ESuC4B,QTvC5B,CSuChB,C;G;sHAEN,yB;IAAA,gC;IVxC4B,6G;ICsBxB,mJ;ISkBJ,gD;MVxCoC,6B;MUgDJ,yB;MAA5B,+BTvBI,wBAAc,oBSuBqB,STvBrB,EAAkB,IAAlB,ESuBqC,QTvBrC,CSuBlB,C;IACJ,C;GATA,C;0JAWA,yB;IAAA,gC;IVnD4B,6G;ICyCxB,mJ;ISUJ,8D;MVnDoC,6B;MUoEJ,yB;MAA5B,+BTrBI,wBAAc,+BSqBgC,STrBhC,EAA6B,IAA7B,ESqBgD,sBTrBhD,CSqBlB,C;IACJ,C;GAlBA,C;EAoBA,0C;IAWM,gDAAuB,gBAAvB,C;G;sHAoB0B,qB;IAAoB,gB;G;ECvHJ,+B;IAAE,OAAG,WAAH,EAAG,C;EAAa,C;EAVlE,iC;IAUM,OTyBE,+BAAsB,gBSzBC,STyBD,CSzBO,oBAAW,iBAAX,C;G;EAErC,oD;IAUM,OAAA,uBAAa,gCAAuB,gBAAvB,C;G;EAc6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OTDE,+BAAsB,gBSCC,STDD,CSCO,oBAAW,mBAAX,C;G;EAErC,oD;IAWM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAc6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OT5BE,+BAAsB,gBS4BC,ST5BD,CS4BO,oBAAW,mBAAX,C;G;EAErC,oD;IAWM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAc6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OTvDE,+BAAsB,gBSuDC,STvDD,CSuDO,oBAAW,mBAAX,C;G;EAErC,oD;IAWM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAc6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OTlFE,+BAAsB,gBSkFC,STlFD,CSkFO,oBAAW,mBAAX,C;G;EAErC,oD;IAWM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAc6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OT7GE,+BAAsB,gBS6GC,ST7GD,CS6GO,oBAAW,mBAAX,C;G;EAErC,oD;IAWM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAc6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OTxIE,+BAAsB,gBSwIC,STxID,CSwIO,oBAAW,mBAAX,C;G;EAErC,oD;IAWM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAc6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OTnKE,+BAAsB,gBSmKC,STnKD,CSmKO,oBAAW,mBAAX,C;G;EAErC,oD;IAWM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAc6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OT9LE,+BAAsB,gBS8LC,ST9LD,CS8LO,oBAAW,mBAAX,C;G;EAErC,oD;IAWM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;ECtOnB,kC;IZqB6C,sC;IYZvC,OTEE,iCAAuB,yBSFe,STEf,C;G;ESA/B,mC;IZU6C,sC;IYHvC,gCTJE,iCAAuB,4BSIuC,STJvC,CSIzB,C;G;EAEN,uC;IAgBM,6BAAc,WAAO,QAAP,KAAd,C;G;EAEN,uC;IA0BM,mCAAQ,qBAAR,GAAwB,CAAxB,GAA8B,MAA9B,C;G;EAGN,2C;IASM,6BAAc,kBAAc,OAAd,KAAd,C;G;EAEN,yC;IAuBM,qCAAQ,qBAAR,GAAwB,CAAxB,GAA8B,QAA9B,C;G;EAEN,0C;IAYM,gCAAiB,WAAO,QAAP,KAAjB,C;G;EAEN,0C;IAaM,4BAAW,qBAAX,GAAuB,MAAvB,C;G;EAEN,yC;IZ/G6C,sC;IYsHvC,sCT1HE,iCAAuB,oBS0HuB,ST1HvB,ES0H6B,QT1H7B,CS0HzB,C;G;EAEN,4C;IZxH6C,sC;IY+HvC,sCThIE,iCAAuB,uBSgI0B,SThI1B,ESgIgC,QThIhC,CSgIzB,C;G;EAGN,uC;IZlI6C,sC;IYyIvC,sCTvIE,iCAAuB,kBSuIqB,STvIrB,ESuI2B,QTvI3B,CSuIzB,C;G;EAEN,0C;IZ3I6C,sC;IYkJvC,sCT7IE,iCAAuB,qBS6IwB,ST7IxB,ES6I8B,QT7I9B,CS6IzB,C;G;EAGN,kC;IZrJ6C,sC;IY8JvC,sCTtJE,iCAAuB,iBSsJoB,STtJpB,CSsJzB,C;G;EAEN,qC;IZhK6C,sC;IYyKvC,sCT9JE,iCAAuB,oBS8JuB,ST9JvB,CS8JzB,C;G;EAEN,qC;IZ3K6C,sC;IYoLvC,sCTtKE,iCAAuB,oBSsKuB,STtKvB,CSsKzB,C;G;ECjNN,mC;IAYM,oCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,qC;IAgBM,sCAA2B,KAA3B,EAAkC,SAAlC,EAAwC,yBAAxC,C;G;EAEN,mC;IAYM,oCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,kC;IAiBM,mCAAwB,KAAxB,EAA+B,SAA/B,C;G;EAEN,uC;IAYM,wCAA6B,KAA7B,EAAoC,SAApC,C;G;EVQF,yDAIsC,yB;IEvF1C,sD;WFuF0C,c;MAAE,OEnFA,WFmFA,EEnFA,C;K;GFmFF,C;EWrF1C,oC;IAkBM,sBAAS,WAAO,QAAP,KAAT,C;G;EAEN,gC;IdK6C,sC;IG0Bb,8C;IWNoB,eAAa,MAAO,S;IAAlE,+BXmBE,uCAA+B,gBWnBoB,SXmBpB,EAAsB,QAAtB,CWnBjC,C;G;EAGN,sC;IAmBM,wBAAS,WAAO,QAAP,KAAT,C;G;EAEN,kC;Id5C6C,sC;IG0Bb,8C;IW4CoB,eAAyB,MAAO,S;IAA9E,+BX1BE,uCAA+B,4BW0BgC,SX1BhC,EAAkC,QAAlC,CW0BjC,C;G;EAEN,sC;IAkBM,kCAAa,CAAb,GAAqB,QAArB,C;G;EAEN,kC;IAyBM,gCAAa,CAAb,GAAmB,MAAnB,C;G;EAEN,mC;IAYM,wBAAS,kBAAc,OAAd,KAAT,C;G;EAEN,oC;IdrI6C,sC;IG0Bb,8C;IWiIoB,eAAY,QAAS,S;IVgmC9D,kBAAM,eAAa,wBD/rCD,QC+rCC,EAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,ODpwCY,QCowCZ,W;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WCx1CwB,WDw1CV,ICx1CU,CDw1CxB,C;;IUtqCd,+BX1FE,uCAA+B,eW0FmB,SX1FnB,ECiwC5B,WDjwC4B,CW0FjC,C;G;EAGN,qC;IAaM,wBAAS,kBAAc,OAAd,KAAT,C;G;EAEN,oC;Id7K6C,sC;IG0Bb,8C;IW0KoB,eAAwB,QAAS,S;IAA/E,+BX9HE,uCAA+B,2BW8H+B,SX9H/B,EAAiC,QAAjC,CW8HjC,C;G;EAEN,qC;IAYM,kCAAa,CAAb,GAAqB,OAArB,C;G;EAEN,oC;IAsBM,gCAAa,CAAb,GAAmB,QAAnB,C;G;EAEN,4C;IAOM,wCAAsB,SAAtB,C;G;EC5QN,qC;IfyB6C,sC;IG0Bb,8C;IAkDQ,0D;IY7FlC,OZ0GE,uCAAuB,sBY1GsC,SZ0GtC,C;G;EYxG/B,uC;IAQM,gCAAqB,oCAAyB,MAAzB,CAArB,C;G;ECpBN,kC;IhB6B2C,oC;IgBnBrC,sCCaE,+BAAqB,iBDboB,SCapB,EDb0B,ICa1B,CDbvB,C;G;EAEN,kC;IhBiB2C,oC;IgBVrC,sCCTE,+BAAqB,iBDSoB,SCTpB,CDSvB,C;G;EAEN,qC;IhBQ2C,oC;IgBDrC,sCCfE,+BAAqB,oBDeuB,SCfvB,CDevB,C;G;EAYyB,6B;IAAqB,+DAAS,qB;aAAe,c;KAAxB,E;G;EAEpD,2C;IhBb2C,oC;IgBwBrC,sCCzBE,+BAAqB,cDyBiB,SCzBjB,EDyBuB,gBCzBvB,CDyBvB,C;G;EExDN,yC;IlBkC2C,oC;IkB3BrC,sCCKE,+BAAqB,mBDLuB,SCKvB,EDL6B,QCK7B,CDLvB,C;G;EAEN,6C;IlByB2C,oC;IkBlBrC,sCCCE,+BAAqB,uBDD2B,SCC3B,EDDiC,QCCjC,CDDvB,C;G;EAEN,4C;IlBgB2C,oC;IkBTrC,sCCHE,+BAAqB,sBDG0B,SCH1B,EDGgC,QCHhC,CDGvB,C;G;EAEN,gD;IlBO2C,oC;IkBArC,sCCPE,+BAAqB,0BDO8B,SCP9B,EDOoC,QCPpC,CDOvB,C;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EErBqG,0D;IAGvG,oCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,qDAJA,C;G;EAIA,uE;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;;;;;;ECL2D,yD;IAGtG,mCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,oDAJA,EAKA,sDALA,EAMA,sDANA,C;G;EAIA,sE;IAAA,qB;MAAE,aAA4B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,wE;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;EAC3C,wE;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;;;;;;ECP8D,4E;IAIzG,sCACA,KADA,EAEA,cAFA,EAGA,eAHA,EAIA,0BAJA,EAKA,uEALA,EAMA,yDANA,EAOA,yDAPA,EAQA,wDARA,EASA,yDATA,C;G;EAKA,iG;IAAA,uB;MAAU,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,CAApC,SAAkE,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAAlE,SAAyE,CAAzE,M;IAA6E,C;G;EACvF,2E;IAAA,qB;MAAE,aAA4B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,2E;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;EAC3C,0E;IAAA,qB;MAAE,aAA8B,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAA9B,SAAqC,EAArC,M;IAA0C,C;G;EAC5C,2E;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;;;;;;ECjB4D,0D;IAGvG,oCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,qDAJA,C;G;EAIA,uE;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;;;;;;ECVwD,+C;IAEnG,gCAA2B,eAA3B,C;G;;;;;;ECC2G,8D;IAG3G,wCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,yDAJA,C;G;EAIA,2E;IAAA,qB;MAAE,aAAiC,8BAA7B,4B;;OAA6B,YAA7B,uBAA6B,eAAjC,SAAwC,EAAxC,M;IAA6C,C;G;;;;;;ECpBnD,oC;IACI,sCAA6E,6B;;KAA7E,C;IACA,OAAU,CAAE,aAAL,kBAA2B,4BAA3B,C;EACX,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECUsG,4D;IAGlG,sCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,uDAJA,C;G;EAIA,yE;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;;;;;;ECLsD,2D;IAGjG,qCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,sDAJA,EAKA,sDALA,EAMA,sDANA,C;G;EAIA,wE;IAAA,qB;MAAE,aAA4B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,wE;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;EAC3C,wE;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;;;;;;ECPyD,8E;IAIpG,wCACA,KADA,EAEA,cAFA,EAGA,eAHA,EAIA,4BAJA,EAKA,yEALA,EAMA,yDANA,EAOA,yDAPA,EAQA,wDARA,EASA,yDATA,C;G;EAKA,mG;IAAA,uB;MAAU,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,CAApC,SAAkE,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAAlE,SAAyE,CAAzE,M;IAA6E,C;G;EACvF,2E;IAAA,qB;MAAE,aAA4B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,2E;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;EAC3C,0E;IAAA,qB;MAAE,aAA8B,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAA9B,SAAqC,EAArC,M;IAA0C,C;G;EAC5C,2E;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;;;;;;ECjBuD,4D;IAGlG,sCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,uDAJA,C;G;EAIA,yE;IAAA,qB;MAAE,aAA6B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;;;;;;ECTmD,iD;IAE9F,kCAA8B,eAA9B,C;G;;;;;;ECAsG,gE;IAGtG,0CACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,2DAJA,C;G;EAIA,6E;IAAA,qB;MAAE,aAAiC,8BAA7B,4B;;OAA6B,YAA7B,uBAA6B,eAAjC,SAAwC,EAAxC,M;IAA6C,C;G;;;;;;ECpBnD,sC;IACI,sCAA6E,6B;;KAA7E,C;IACA,OAAU,CAAE,aAAL,kBAA2B,4BAA3B,C;EACX,C;;IC+BI,6C;;EAAA,2C;IAAA,+C;G;6DACI,wB;IACM,qCAA0B,KAA1B,EAAiC,KAAjC,C;G;;;;;;;EAFV,uD;IAAA,sD;MAAA,qC;;IAAA,+C;G;;;;;;;ICJA,qC;;EAAA,mC;IAAA,uC;G;qDACI,wB;IACM,6BAAkB,KAAlB,EAAyB,KAAzB,C;G;;;;;;;EAFV,+C;IAAA,8C;MAAA,6B;;IAAA,uC;G;;;;;;EC9BmD,iD;IACnD,2B;IACA,4B;G;;SADA,Y;MAAA,0B;K;;;SACA,Y;MAAA,2B;K;;yDAGA,4B;IAEM,qB;IpCoC2B,8B;IoCpCQ,YAAY,U;IAAZ,YAAmB,U;IAAtD,OAAM,0BCoCR,yBAAe,qBAAY,KAAZ,EAAmB,KAAnB,EDpCgD,gBCoChD,CDpCP,C;G;;;;;;EERqC,yC;IACjD,4B;IACA,4B;G;;SADA,Y;MAAA,2B;K;;;SACA,Y;MAAA,2B;K;;iDAGA,4B;IAEM,qB;ItCqC2B,8B;IsCrCQ,YAAI,U;IAAJ,YAAW,U;IAA9C,OAAM,0BDuBR,yBAAe,aAAI,KAAJ,EAAW,KAAX,ECvBwC,gBDuBxC,CCvBP,C;G;;;;;;;IC6BZ,4C;;EAAA,0C;IAAA,8C;G;4DACI,sB;IACM,oCAAyB,KAAzB,EAAgC,GAAhC,C;G;;;;;;;EAFV,sD;IAAA,qD;MAAA,oC;;IAAA,8C;G;;;;;;;ICJA,oC;;EAAA,kC;IAAA,sC;G;oDACI,sB;IAIM,4BAAiB,KAAjB,EAAwB,GAAxB,C;G;;;;;;;EALV,8C;IAAA,6C;MAAA,4B;;IAAA,sC;G;;;;;;EC/B2D,8C;IAC3D,4B;IACA,wB;G;;SADA,Y;MAAA,2B;K;;;SACA,Y;MAAA,yB;K;;wDAGA,4B;IAEM,qB;IzCsC0B,6B;IyCtCQ,YAAoB,U;IAApB,UAA2B,Q;IAA7D,OAAM,0BCqFR,wBAAc,6BAAoB,KAApB,EAA2B,GAA3B,EDrFsD,gBCqFtD,CDrFN,C;G;;;;;;EER6C,sC;IACzD,4B;IACA,wB;G;;SADA,Y;MAAA,2B;K;;;SACA,Y;MAAA,yB;K;;gDAGA,4B;IAEM,qB;I3CuC0B,6B;I2CvCQ,YAAY,U;IAAZ,UAAmB,Q;IAArD,OAAM,0BDyER,wBAAc,qBAAY,KAAZ,EAAmB,GAAnB,ECzE8C,gBDyE9C,CCzEN,C;G;;;;;;ErCaU,mF;IAAA,mB;MAAE,OAAyB,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAapC,qF;IAAA,mB;MAAE,OAAyB,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAc9C,qF;IAAA,mB;MAAE,OAA0B,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAiBrB,uF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAc3B,yF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAe3C,yF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAiBX,uF;IAAA,qB;MAAO,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAchC,yF;IAAA,qB;MAAO,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAerC,yF;IAAA,qB;MAAO,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAiB3B,uF;IAAA,yB;MAAW,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAcpC,yF;IAAA,yB;MAAW,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAepC,yF;IAAA,yB;MAAW,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAiBpC,uF;IAAA,6B;MAAe,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAcxC,yF;IAAA,6B;MAAe,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAepC,yF;IAAA,6B;MAAe,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAiB5C,uF;IAAA,iC;MAAmB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAc5C,yF;IAAA,iC;MAAmB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAepC,yF;IAAA,iC;MAAmB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAiBpD,uF;IAAA,qC;MAAuB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;EAchD,yF;IAAA,qC;MAAuB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;EAerC,yF;IAAA,qC;MAAuB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;EsC1T3F,uC;I5C6BwC,iC;I4CtBlC,OtCUI,4BAAkB,kBsCVM,StCUN,EsCVY,QtCUZ,EAHQ,wBsCPI,QtCOoB,aAAxB,CAGR,C;G;EsCR5B,yC;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yC;I5CewC,iC;I4CRlC,OtCJI,4BAAkB,kBsCIM,StCJN,EANF,yCsCUc,QtCVd,EsCUQ,StCVR,CAME,EAN2D,wBsCU/C,QtCVuE,aAAxB,CAM3D,C;G;EsCO5B,2D;I5CKwC,iC;I4CMlC,OtClBI,4BAAkB,kBsCkBM,StClBN,EsCkBY,QtClBZ,EAUS,wBsCQG,QtCRqB,aAAxB,CAVT,CAaqB,gCsCKC,gBtCLD,C;G;EsCOjD,2D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2D;I5CbwC,iC;I4CwBlC,OtCpCI,4BAAkB,kBsCoCM,StCpCN,EAOF,2CsC6Bc,QtC7Bd,EsC6BQ,StC7BR,CAPE,EAO4D,wBsC6BhD,QtC7BwE,aAAxB,CAP5D,CAaqB,gCsCuBC,gBtCvBD,C;G;EsC0BjD,yC;I5C3BwC,iC;I4CkClC,OtCjBI,4BAAkB,kBsCiBM,StCjBN,EsCiBY,QtCjBZ,EAHQ,wBsCoBI,QtCpBoB,aAAxB,CAGR,C;G;EsCmB5B,yC;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yC;I5CzCwC,iC;IMShC,QAAQ,2CsCuCwB,QtCvCxB,EsCuCkB,StCvClB,C;IsCuCV,OtC/BI,4BAAkB,kBsC+BM,StC/BN,EAPG,CAOH,EAPM,wBsCsCM,QtCtCkB,aAAxB,CAON,C;G;EsCoC5B,0C;I5CrDwC,iC;I4C4DlC,OtC5BI,4BAAkB,wBsC4BY,StC5BZ,EsC4BkB,MtC5BlB,EsC4BkB,MtC/BC,aAGnB,C;G;EsC8B5B,4C;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,4C;I5CnEwC,iC;I4C2ElC,OtC3CI,4BAAkB,wBsC2CY,StC3CZ,EANI,+CsCiDc,MtCjDd,EsCiDQ,StCjDR,CAMJ,EsC2CkB,MtCjD6C,aAM/D,C;G;EsC8C5B,8D;I5C9EwC,iC;I4C0FlC,OtC1DI,4BAAkB,wBsC0DY,StC1DZ,EsC0DkB,MtC1DlB,EsC0DkB,MtC/CC,aAXnB,CAckB,gCsC4CQ,gBtC5CR,C;G;EsC8C9C,8D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,8D;I5CjGwC,iC;I4C8GlC,OtC9EI,4BAAkB,wBsC8EY,StC9EZ,EAQI,iDsCsEc,MtCtEd,EsCsEQ,StCtER,CARJ,EsC8EkB,MtCtE6C,aAR/D,CAckB,gCsCgEQ,gBtChER,C;G;EsCmE9C,4C;I5CjHwC,iC;I4CyHlC,OtC1DI,4BAAkB,wBsC0DY,StC1DZ,EsC0DkB,MtC1DlB,EsC0DkB,MtC7DC,aAGnB,C;G;EsC4D5B,4C;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,4C;I5ChIwC,iC;IMuDhC,QAAQ,iDsCkF8B,MtClF9B,EsCkFwB,StClFxB,C;IsCkFV,OtCvEI,4BAAkB,wBsCuEY,StCvEZ,EAVS,CAUT,EAVY,CAUZ,EsCuEkB,MtCjFI,aAUtB,C;G;EsC4E5B,kD;I5C9IwC,iC;I4CsJlC,OtCxEI,4BAAkB,wBsCwEY,StCxEZ,EsCwEkB,MtCxElB,EsCwE0B,ItCxE1B,EsCwEkB,MtC3EO,aAGzB,C;G;EsC0E5B,kD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,mD;I5C7JwC,iC;I4CsKlC,OtCxFI,4BAAkB,wBsCwFY,StCxFZ,EANI,+CsC8Fc,MtC9Fd,EsC8FQ,StC9FR,CAMJ,EsCwF0B,ItCxF1B,EsCwFkB,MtC9F4D,aAM9E,C;G;EsC2F5B,qE;I5CzKwC,iC;I4CqLlC,OtCvGI,4BAAkB,wBsCuGY,StCvGZ,EsCuGkB,MtCvGlB,EsCuG0B,ItCvG1B,EsCuGkB,MtC5FO,aAXzB,CAcwB,gCsCyFQ,gBtCzFR,C;G;EsC2FpD,qE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,qE;I5C5LwC,iC;I4CyMlC,OtC3HI,4BAAkB,wBsC2HY,StC3HZ,EAQI,iDsCmHc,MtCnHd,EsCmHQ,StCnHR,CARJ,EsC2H0B,ItC3H1B,EsC2HkB,MtCnH4D,aAR9E,CAcwB,gCsC6GQ,gBtC7GR,C;G;EsCgHpD,mD;I5C5MwC,iC;I4CoNlC,OtCvGI,4BAAkB,wBsCuGY,StCvGZ,EsCuGkB,MtCvGlB,EsCuG0B,ItCvG1B,EsCuGkB,MtC1GO,aAGzB,C;G;EsCyG5B,mD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,mD;I5C3NwC,iC;IMqGhC,QAAmB,iDsC+HmB,MtC/HnB,EsC+Ha,StC/Hb,C;IsC+HrB,OtCvHI,4BAAkB,wBsCuHY,StCvHZ,EAPS,CAOT,EsCuH0B,ItCvH1B,EsCuHkB,MtC9HO,aAOzB,C;G;EsC4H5B,yD;I5CzOwC,iC;I4CiPlC,OtCrHI,4BAAkB,wBsCqHY,StCrHZ,EsCqHkB,MtCrHlB,EsCqH0B,ItCrH1B,EsCqHgC,ItCrHhC,EsCqHkB,MtCxHa,aAG/B,C;G;EsCuH5B,yD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yD;I5CxPwC,iC;I4CiQlC,OtCrII,4BAAkB,wBsCqIY,StCrIZ,EANI,+CsC2Ic,MtC3Id,EsC2IQ,StC3IR,CAMJ,EsCqI0B,ItCrI1B,EsCqIgC,ItCrIhC,EsCqIkB,MtC3I0E,aAM5F,C;G;EsCwI5B,2E;I5CpQwC,iC;I4CgRlC,OtCpJI,4BAAkB,wBsCoJY,StCpJZ,EsCoJkB,MtCpJlB,EsCoJ0B,ItCpJ1B,EsCoJgC,ItCpJhC,EsCoJkB,MtCzIa,aAX/B,CAc8B,gCsCsIQ,gBtCtIR,C;G;EsCwI1D,2E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2E;I5CvRwC,iC;I4CoSlC,OtCxKI,4BAAkB,wBsCwKY,StCxKZ,EAQI,iDsCgKc,MtChKd,EsCgKQ,StChKR,CARJ,EsCwK0B,ItCxK1B,EsCwKgC,ItCxKhC,EsCwKkB,MtChK0E,aAR5F,CAc8B,gCsC0JQ,gBtC1JR,C;G;EsC6J1D,yD;I5CvSwC,iC;I4C+SlC,OtCpJI,4BAAkB,wBsCoJY,StCpJZ,EsCoJkB,MtCpJlB,EsCoJ0B,ItCpJ1B,EsCoJgC,ItCpJhC,EsCoJkB,MtCvJa,aAG/B,C;G;EsCsJ5B,yD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yD;I5CtTwC,iC;IMmJhC,QAAwB,iDsC4Kc,MtC5Kd,EsC4KQ,StC5KR,C;IsC4K1B,OtCpKI,4BAAkB,wBsCoKY,StCpKZ,EAPS,CAOT,EsCoK0B,ItCpK1B,EsCoKgC,ItCpKhC,EsCoKkB,MtC3Ka,aAO/B,C;G;EsCyK5B,+D;I5CpUwC,iC;I4C4UlC,OtClKI,4BAAkB,wBsCkKY,StClKZ,EsCkKkB,MtClKlB,EsCkK0B,ItClK1B,EsCkKgC,ItClKhC,EsCkKsC,ItClKtC,EsCkKkB,MtCrKmB,aAGrC,C;G;EsCoK5B,+D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,+D;I5CnVwC,iC;I4C4VlC,OtClLI,4BAAkB,wBsCkLY,StClLZ,EANI,+CsCwLc,MtCxLd,EsCwLQ,StCxLR,CAMJ,EsCkL0B,ItClL1B,EsCkLgC,ItClLhC,EsCkLsC,ItClLtC,EsCkLkB,MtCxLwF,aAM1G,C;G;EsCqL5B,iF;I5C/VwC,iC;I4C2WlC,OtCjMI,4BAAkB,wBsCiMY,StCjMZ,EsCiMkB,MtCjMlB,EsCiM0B,ItCjM1B,EsCiMgC,ItCjMhC,EsCiMsC,ItCjMtC,EsCiMkB,MtCtLmB,aAXrC,CAcoC,gCsCmLQ,gBtCnLR,C;G;EsCqLhE,iF;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,iF;I5ClXwC,iC;I4C+XlC,OtCrNI,4BAAkB,wBsCqNY,StCrNZ,EAQI,iDsC6Mc,MtC7Md,EsC6MQ,StC7MR,CARJ,EsCqN0B,ItCrN1B,EsCqNgC,ItCrNhC,EsCqNsC,ItCrNtC,EsCqNkB,MtC7MwF,aAR1G,CAcoC,gCsCuMQ,gBtCvMR,C;G;EsC0MhE,+D;I5ClYwC,iC;I4C0YlC,OtCjMI,4BAAkB,wBsCiMY,StCjMZ,EsCiMkB,MtCjMlB,EsCiM0B,ItCjM1B,EsCiMgC,ItCjMhC,EsCiMsC,ItCjMtC,EsCiMkB,MtCpMmB,aAGrC,C;G;EsCmM5B,+D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,+D;I5CjZwC,iC;IMiMhC,QAA4B,iDsCyNU,MtCzNV,EsCyNI,StCzNJ,C;IsCyN9B,OtCjNI,4BAAkB,wBsCiNY,StCjNZ,EAPS,CAOT,EsCiN0B,ItCjN1B,EsCiNgC,ItCjNhC,EsCiNsC,ItCjNtC,EsCiNkB,MtCxNmB,aAOrC,C;G;EsCsN5B,qE;I5C/ZwC,iC;I4CualC,OtC/MI,4BAAkB,wBsC+MY,StC/MZ,EsC+MkB,MtC/MlB,EsC+M0B,ItC/M1B,EsC+MgC,ItC/MhC,EsC+MsC,ItC/MtC,EsC+M4C,ItC/M5C,EsC+MkB,MtClNyB,aAG3C,C;G;EsCiN5B,qE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,qE;I5C9awC,iC;I4CublC,OtC/NI,4BAAkB,wBsC+NY,StC/NZ,EANI,+CsCqOc,MtCrOd,EsCqOQ,StCrOR,CAMJ,EsC+N0B,ItC/N1B,EsC+NgC,ItC/NhC,EsC+NsC,ItC/NtC,EsC+N4C,ItC/N5C,EsC+NkB,MtCrOsG,aAMxH,C;G;EsCkO5B,uF;I5C1bwC,iC;I4CsclC,OtC9OI,4BAAkB,wBsC8OY,StC9OZ,EsC8OkB,MtC9OlB,EsC8O0B,ItC9O1B,EsC8OgC,ItC9OhC,EsC8OsC,ItC9OtC,EsC8O4C,ItC9O5C,EsC8OkB,MtCnOyB,aAX3C,CAc0C,gCsCgOQ,gBtChOR,C;G;EsCkOtE,uF;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,uF;I5C7cwC,iC;I4C0dlC,OtClQI,4BAAkB,wBsCkQY,StClQZ,EAQI,iDsC0Pc,MtC1Pd,EsC0PQ,StC1PR,CARJ,EsCkQ0B,ItClQ1B,EsCkQgC,ItClQhC,EsCkQsC,ItClQtC,EsCkQ4C,ItClQ5C,EsCkQkB,MtC1PsG,aARxH,CAc0C,gCsCoPQ,gBtCpPR,C;G;EsCuPtE,qE;I5C7dwC,iC;I4CqelC,OtC9OI,4BAAkB,wBsC8OY,StC9OZ,EsC8OkB,MtC9OlB,EsC8O0B,ItC9O1B,EsC8OgC,ItC9OhC,EsC8OsC,ItC9OtC,EsC8O4C,ItC9O5C,EsC8OkB,MtCjPyB,aAG3C,C;G;EsCgP5B,qE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,qE;I5C5ewC,iC;IM+OhC,QAAgC,iDsCsQM,MtCtQN,EsCsQA,StCtQA,C;IsCsQlC,OtC9PI,4BAAkB,wBsC8PY,StC9PZ,EAPS,CAOT,EsC8P0B,ItC9P1B,EsC8PgC,ItC9PhC,EsC8PsC,ItC9PtC,EsC8P4C,ItC9P5C,EsC8PkB,MtCrQyB,aAO3C,C;G;EsCmQ5B,2E;I5C1fwC,iC;I4CkgBlC,OtC5PI,4BAAkB,wBsC4PY,StC5PZ,EsC4PkB,MtC5PlB,EsC4P0B,ItC5P1B,EsC4PgC,ItC5PhC,EsC4PsC,ItC5PtC,EsC4P4C,ItC5P5C,EsC4PkD,ItC5PlD,EsC4PkB,MtC/P+B,aAGjD,C;G;EsC8P5B,2E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2E;I5CzgBwC,iC;I4CkhBlC,OtC5QI,4BAAkB,wBsC4QY,StC5QZ,EANI,+CsCkRc,MtClRd,EsCkRQ,StClRR,CAMJ,EsC4Q0B,ItC5Q1B,EsC4QgC,ItC5QhC,EsC4QsC,ItC5QtC,EsC4Q4C,ItC5Q5C,EsC4QkD,ItC5QlD,EsC4QkB,MtClRoH,aAMtI,C;G;EsC+Q5B,6F;I5CrhBwC,iC;I4CiiBlC,OtC3RI,4BAAkB,wBsC2RY,StC3RZ,EsC2RkB,MtC3RlB,EsC2R0B,ItC3R1B,EsC2RgC,ItC3RhC,EsC2RsC,ItC3RtC,EsC2R4C,ItC3R5C,EsC2RkD,ItC3RlD,EsC2RkB,MtChR+B,aAXjD,CAcgD,gCsC6QQ,gBtC7QR,C;G;EsC+Q5E,6F;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,6F;I5CxiBwC,iC;I4CqjBlC,OtC/SI,4BAAkB,wBsC+SY,StC/SZ,EAQI,iDsCuSc,MtCvSd,EsCuSQ,StCvSR,CARJ,EsC+S0B,ItC/S1B,EsC+SgC,ItC/ShC,EsC+SsC,ItC/StC,EsC+S4C,ItC/S5C,EsC+SkD,ItC/SlD,EsC+SkB,MtCvSoH,aARtI,CAcgD,gCsCiSQ,gBtCjSR,C;G;EsCoS5E,2E;I5CxjBwC,iC;I4CgkBlC,OtC3RI,4BAAkB,wBsC2RY,StC3RZ,EsC2RkB,MtC3RlB,EsC2R0B,ItC3R1B,EsC2RgC,ItC3RhC,EsC2RsC,ItC3RtC,EsC2R4C,ItC3R5C,EsC2RkD,ItC3RlD,EsC2RkB,MtC9R+B,aAGjD,C;G;EsC6R5B,2E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2E;I5CvkBwC,iC;IM6RhC,QAAmC,iDsCmTG,MtCnTH,EsCmTH,StCnTG,C;IsCmTrC,OtC3SI,4BAAkB,wBsC2SY,StC3SZ,EAPS,CAOT,EsC2S0B,ItC3S1B,EsC2SgC,ItC3ShC,EsC2SsC,ItC3StC,EsC2S4C,ItC3S5C,EsC2SkD,ItC3SlD,EsC2SkB,MtClT+B,aAOjD,C;G;EuC7T5B,kC;I7C4ByC,kC;I6CrBnC,OtCFE,6BAAmB,yBsCEe,StCFf,C;G;EsCI3B,qC;I7CmByC,kC;I6CZnC,kCtCRE,6BAAmB,4BsCQuC,StCRvC,CsCQrB,C;G;EAEN,yC;IASM,iDAAK,qBAAL,GAAmB,mBAAnB,GAAiC,CAAjC,GAAyC,QAAzC,C;G;EAEN,uC;IAoBM,+CAAK,qBAAL,GAAmB,mBAAnB,GAAiC,CAAjC,GAAuC,MAAvC,C;G;EAEN,uD;IAeM,+CAAK,qBAAL,GAAmB,mBAAnB,GAAiC,CAAjC,GAAyC,sBAAzC,C;G;EAEN,wC;IAaM,+CAAK,qBAAL,GAAmB,mBAAnB,GAAiC,CAAjC,GAAuC,OAAvC,C;G;EAGN,8C;IAUM,6CAAK,qBAAL,GAAqB,mBAArB,GAA+B,kBAA/B,GAA0C,QAA1C,C;G;EAEN,8C;IAUM,2CAAK,qBAAL,GAAqB,mBAArB,GAA+B,kBAA/B,GAAwC,MAAxC,C;G;EAEN,8D;IAeM,6CAAK,qBAAL,GAAqB,mBAArB,GAA+B,kBAA/B,GAA0C,sBAA1C,C;G;EAEN,+C;IAcM,4CAAK,qBAAL,GAAqB,mBAArB,GAA+B,kBAA/B,GAAwC,OAAxC,C;G;EAGN,4C;IASM,kCAAQ,qBAAR,GAAsB,QAAtB,C;G;EAEN,0C;IASM,gCAAQ,qBAAR,GAAoB,MAApB,C;G;EAGN,gD;IAWM,+CAAK,qBAAL,GAAmB,mBAAnB,GAAiC,CAAjC,GAAyC,sBAAzC,C;G;EAGN,iD;IAWM,gCAAQ,qBAAR,GAAsB,sBAAtB,C;G;EAEN,gD;I7CpKyC,kC;I6C+KnC,sCtClKa,6BAAmB,asCkKK,StClKL,EsCkKW,sBtClKX,CsCkKhC,C;G;ECvNN,qC;IAYM,sCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,uC;IAgBM,wCAA2B,KAA3B,EAAkC,SAAlC,EAAwC,yBAAxC,C;G;EAEN,qC;IAYM,sCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,oC;IAiBM,qCAAwB,KAAxB,EAA+B,SAA/B,C;G;EAEN,yC;IAYM,0CAA6B,KAA7B,EAAoC,SAApC,C;G;ECrEN,sC;IAYM,wBAAS,WAAO,QAAP,KAAT,C;G;EAEN,kC;I/CkByC,kC;IOIT,0C;IwCDgB,eAAuB,MAAO,S;IAAxE,iCxCuBE,qCAA2B,0BwCvB8B,SxCuB9B,EAAgC,QAAhC,CwCvB7B,C;G;EAEN,kD;IAeM,wBAAS,YAAQ,sBAAR,KAAT,C;G;EAEN,mC;I/CtByC,kC;IOIT,0C;IwCgCgB,wBAAkC,OAAQ,S;IAApF,iCxCyCE,qCAA2B,qCwCzCyC,SxCyCzC,EAA2C,iBAA3C,CwCzC7B,C;G;EAEN,8C;IAQuB,wCAAsB,SAAtB,C;G;EC9EvB,sC;IAYM,wBAAS,WAAO,QAAP,KAAT,C;G;EAEN,kC;IhDkByC,kC;IOIT,0C;IyCZgB,eAA2B,MAAO,S;IAA5E,iCzC4CE,qCAA2B,8ByC5CkC,SzC4ClC,EAA8B,QAA9B,CyC5C7B,C;G;EAEN,oD;IAaM,wBAAS,YAAQ,sBAAR,KAAT,C;G;EAEN,mC;IhDTyC,kC;IOIT,0C;IyC4BgB,wBAAsC,OAAQ,S;IAAxF,iCzCqDE,qCAA2B,yCyCrD6C,SzCqD7C,EAAyC,iBAAzC,CyCrD7B,C;G;EAEN,8C;IAQuB,0CAAsB,SAAtB,C;G;EC7EvB,sC;IAYM,wBAAS,WAAO,QAAP,KAAT,C;G;EAEN,kC;IjDqByC,kC;IOIT,0C;I0CfgB,eAAwB,MAAO,S;IAAzE,iC1CyDE,qCAA2B,2B0CzD+B,S1CyD/B,EAA2B,QAA3B,C0CzD7B,C;G;EAEN,oD;IAaM,yBAAS,YAAQ,sBAAR,KAAT,C;G;EAEN,oC;IjDNyC,kC;IOIT,0C;I0CmBgB,wBAAmC,OAAQ,S;IAArF,iC1CqEE,qCAA2B,sC0CrE0C,S1CqE1C,EAAsC,iBAAtC,C0CrE7B,C;G;ECvDN,iC;IlDgCyC,kC;IOIT,0C;I2CvBC,aAEzB,aAAa,KAAM,WAAnB,EAA+B,KAAM,YAArC,EAAkD,KAAM,oBAAxD,C;IAHe,iC3C4EJ,qCAA2B,kC2C1EtC,S3C0EsC,EAAkC,MAAlC,C2C5EvB,C;G;EAOvB,mC;IlDayC,kC;IOIT,0C;I2CCC,aAEzB,aAAa,KAAM,WAAnB,EAA+B,KAAM,YAArC,EAAkD,KAAM,oBAAxD,C;IAHe,iC3C+FJ,qCAA2B,6C2C7FtC,S3C6FsC,EAA6C,MAA7C,C2C/FvB,C;G;ECzCvB,mC;InDqCyC,kC;IOIT,0C;IAgEQ,sD;I4ChGlC,O5C0IE,yCAAuB,oB4C1IgC,S5C0IhC,C;G;E4CxI/B,8B;InD0ByC,kC;IOIT,0C;IAgEQ,sD;I4CvFlC,O5CoIE,yCAAuB,wB4CpIoC,S5CoIpC,C;G;E4CjI/B,mC;InDgByC,kC;IOIT,0C;IAgEQ,sD;I4C3ElC,O5C2HE,yCAAuB,iB4C3H6B,S5C2H7B,C;G;E4CzH/B,gC;InDKyC,kC;IOIT,0C;IAgEQ,sD;I4ClElC,O5CqHE,yCAAuB,qB4CrHiC,S5CqHjC,C;G;E4CnH/B,qC;InDJyC,kC;IOIT,0C;IAgEQ,sD;I4CzDlC,O5C+GE,yCAAuB,4B4C/GwC,S5C+GxC,C;G;E4C7G/B,kC;InDbyC,kC;IOIT,0C;IAgEQ,sD;I4ChDlC,O5CyGE,yCAAuB,kC4CzG8C,S5CyG9C,C;G;;;;;;;;;E6C1J/B,iB;IAAA,qB;G;;;;;;;EAAA,6B;IAAA,4B;MAAA,W;;IAAA,qB;G;EAMA,iB;IAAA,qB;G;;;;;;;EAAA,6B;IAAA,4B;MAAA,W;;IAAA,qB;G;EAMA,mB;IAAA,uB;G;;;;;;;EAAA,+B;IAAA,8B;MAAA,a;;IAAA,uB;G;EAKA,kB;IAAA,oB;G;;;;;;;EAAA,4B;IAAA,2B;MAAA,Y;;IAAA,oB;G;EAKA,mB;IAAA,uB;G;;;;;;;EAAA,+B;IAAA,8B;MAAA,a;;IAAA,uB;G;EAKA,iB;IAAA,qB;G;;;;;;;EAAA,6B;IAAA,4B;MAAA,W;;IAAA,qB;G;EAKA,gB;IAAA,oB;G;;;;;;;EAAA,4B;IAAA,2B;MAAA,U;;IAAA,oB;G;EAKA,iB;IAAA,qB;G;;;;;;;EAAA,6B;IAAA,4B;MAAA,W;;IAAA,qB;G;EC9CA,iC;IASM,OrD+B+B,8BqD/Bf,aAAI,SAAJ,EAAU,KAAV,C;G;EAEtB,iC;IAMM,OAAA,qCAAc,gBAAO,SAAP,EAAa,KAAM,MAAnB,C;G;EAGpB,iC;IASM,OrDW+B,8BqDXf,qBAAY,SAAZ,EAAkB,KAAlB,C;G;EAEtB,iC;IASM,OAAA,6CAAsB,gBAAO,SAAP,EAAa,KAAM,MAAnB,C;G;ECpC5B,6C;IAUM,6BAAc,UAAM,YAAN,KAAd,C;G;EAEN,8C;ItD0BoC,6B;IsDjBF,sBAAe,aAAc,S;IAAzD,sCZ+BE,wBAAc,kBY/BqB,SZ+BrB,EAAgB,eAAhB,CY/BhB,C;G;EAEN,yC;IAUM,6BAAS,QAAI,QAAJ,KAAT,C;G;EAEN,0C;ItDGoC,6B;IsDYsD,kBAAnB,SAAU,S;IlDguCtE,kBAAM,eAAa,qCAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,6B;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WAAc,IkDtyCiE,SlDsyC/E,C;;IkDtyCd,sCZSE,wBAAc,wCYT2C,SZS3C,EtC8xCX,WsC9xCW,CYThB,C;G;EAEN,qC;ItDdoC,6B;IsDqB9B,sCZjCE,wBAAc,qBYiCwB,SZjCxB,EYiC8B,GZjC9B,CYiChB,C;G;EAEN,wC;ItDvBoC,6B;IsD8B9B,sCZvCE,wBAAc,wBYuC2B,SZvC3B,EYuCiC,GZvCjC,CYuChB,C;G;EAGN,qC;ItDjCoC,6B;IsD2C9B,OZjBE,wBAAc,qBYiBW,SZjBX,EYiBiB,GZjBjB,C;G;EYmBtB,uC;IAMM,OAAA,oCAAa,gBAAO,SAAP,EAAa,GAAI,IAAjB,C;G;EAEnB,uC;ItDrDoC,6B;IsD8D9B,OZvBE,wBAAc,6BYuBmB,SZvBnB,EYuByB,GZvBzB,C;G;EYyBtB,uC;IASM,OAAA,4CAAqB,gBAAO,SAAP,EAAa,GAAI,IAAjB,C;G;EAG3B,oC;ItD5EoC,6B;IsDoF9B,sCZjCyE,wBAAc,iBYiCnD,SZjCmD,EYiC7C,IZjC6C,CYiCvF,C;G;EAEN,kC;ItDtFoC,6B;IsD6F9B,sCZlGE,wBAAc,iBYkGoB,SZlGpB,CYkGhB,C;G;EAEN,qC;ItD/FoC,6B;IsDsG9B,sCZnGE,wBAAc,oBYmGuB,SZnGvB,CYmGhB,C;G;EAYgC,6B;IAAyB,+DAAS,qB;aAAe,c;KAAxB,E;G;EAE/D,2C;ItDpHoC,6B;IsD8H9B,sCZpEa,wBAAc,cYoEM,SZpEN,EYoEY,gBZpEZ,CYoE3B,C;G;EAWkC,+B;IAAgC,iEAAS,qB;aAAe,gB;KAAxB,E;G;EAExE,6C;ItD3IoC,6B;IsDqJ9B,sCZpFa,wBAAc,gBYoFQ,SZpFR,EYoFc,gBZpFd,CYoF3B,C;G;EAY0C,8B;IAAE,OAAA,EAAG,Q;EAAQ,C;EAV7D,8B;IAUM,OpD1KE,+BAAsB,gBoD0KC,SpD1KD,CoD0KO,oBAAW,gBAAX,C;G;EAErC,kD;IAUM,OAAA,oBAAY,gCAAuB,gBAAvB,C;G;ECvNlB,6C;IvD0CoC,6B;I0C5BqB,kC;IaDjB,UAAiB,YAAa,M;IAA9B,YAAqC,YAAa,O;IAApF,sCCuBa,6BAAmB,oBDvBa,SCuBb,EAAkB,GAAlB,EAAuB,KAAvB,CDvBhC,C;G;EAWoC,4B;IAAoB,8DAAS,qB;aAAiB,a;KAA1B,E;G;EAW1B,8B;IAAoC,8DAAS,qB;aAAiB,a;KAA1B,E;G;EAExE,0C;IvDKoC,6B;I0C5BqB,kC;IakCnD,sCCLa,6BAAmB,aDKM,SCLN,EDKY,gBCLZ,CDKhC,C;G;EAYsC,8B;IAAoB,gEAAS,qB;aAAiB,e;KAA1B,E;G;EAW1B,gC;IAAoC,gEAAS,qB;aAAiB,e;KAA1B,E;G;EAE1E,8C;IvD/BoC,6B;I0C5BqB,kC;IasEnD,sCClCa,6BAAmB,eDkCQ,SClCR,EDkCc,gBClCd,CDkChC,C;G;EE3EiC,8B;IAAoB,gEAAS,qB;aAAY,e;KAArB,E;G;EAW1B,gC;IAAoC,gEAAS,qB;aAAY,e;KAArB,E;G;EAGrE,4C;IzDqBqC,8B;IyDV/B,sCCda,yBAAe,eDcO,SCdP,EDca,gBCdb,CDc5B,C;G;EAYkC,+B;IAAoB,iEAAS,qB;aAAY,gB;KAArB,E;G;EAW1B,iC;IAAoC,iEAAS,qB;aAAY,gB;KAArB,E;G;EAEtE,6C;IzDfqC,8B;IyD0B/B,sCC3Ca,yBAAe,gBD2CQ,SC3CR,ED2Cc,gBC3Cd,CD2C5B,C;G;EE/DU,sC;IAAC,kC;IAA0B,4C;G;;SAA1B,Y;MAAA,8B;K;;;SAA0B,Y;MAAA,mC;K;;;;;;;EAUrB,uC;IAClB,oD;G;2BAEA,Y;IAAuD,cAAO,2BAAP,C;G;;;;;;EAgBlC,wE;IACrB,oD;IACA,kE;G;;SAEsB,Y;MAAQ,kC;K;;;SACH,Y;MAAQ,yC;K;;6BAEnC,Y;IAAuD,OnDhCK,amDgCL,2BnDhCK,EmDgCuB,kCnDhCvB,C;G;;;;;;EmDsChD,sB;IAAC,kB;G;;;;;;+BAHjB,Y;IAGiB,iB;G;iCAHjB,iB;IAAA,iBAGiB,qCAHjB,C;G;6BAAA,Y;IAAA,OAGiB,4CAHjB,M;G;6BAAA,Y;IAAA,c;IAGiB,sD;IAHjB,a;G;2BAAA,iB;IAAA,2IAGiB,sCAHjB,G;G;EAQqB,kB;IAAC,c;G;;;;;;6BAHtB,Y;IAGsB,e;G;6BAHtB,e;IAAA,eAGsB,+BAHtB,C;G;2BAAA,Y;IAAA,OAGsB,sCAHtB,M;G;2BAAA,Y;IAAA,c;IAGsB,oD;IAHtB,a;G;yBAAA,iB;IAAA,2IAGsB,kCAHtB,G;G;EASmC,oD;IAAC,c;IAAY,8D;G;8BAC5C,Y;IAAiD,oBAAO,gCAAP,C;G;gCACjD,Y;IACM,yBAAe,QAAf,iBAAgC,wCAAJ,GAAyC,MAAzC,GAAqD,QAAjF,O;G;;;;;;kCAPV,Y;IAIoC,e;G;kCAJpC,Y;IAIgD,uC;G;oCAJhD,4C;IAAA,oBAIoC,+BAJpC,EAIgD,uGAJhD,C;G;gCAAA,Y;IAAA,c;IAIoC,oD;IAAY,4E;IAJhD,a;G;8BAAA,iB;IAAA,4IAIoC,kCAJpC,IAIgD,kFAJhD,I;G;EAgBoC,6D;IAChC,4B;IACA,8B;IACA,8C;G;;;;;;EAMqB,wC;IACrB,kC;IACA,4C;G;;SADA,Y;MAAA,8B;K;;;SACA,Y;MAAA,mC;K;;;;;;;EAMe,+C;IACf,0BAAwB,O;IACxB,+BAA6B,a;G;;SAD7B,Y;MAAA,8B;K;;;SACA,Y;MAAA,mC;K;;;;;;;EAOmB,yB;IAAC,wB;G;2BACpB,Y;IAAwB,cAAO,aAAP,C;G;;;;;;+BAJ5B,Y;IAGwB,oB;G;+BAHxB,oB;IAAA,iBAGwB,8CAHxB,C;G;6BAAA,Y;IAAA,OAGwB,kDAHxB,M;G;6BAAA,Y;IAAA,c;IAGwB,yD;IAHxB,a;G;2BAAA,iB;IAAA,2IAGwB,4CAHxB,G;G;EAUmB,yC;IACf,kC;IACA,4C;G;;SADA,Y;MAAA,8B;K;;;SACA,Y;MAAA,mC;K;;4BAEA,Y;IAAwB,iBAAO,aAAP,SAAkB,kBAAlB,E;G;;;;;;ECtGoB,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAVlE,kC;IAUM,O1D0BE,+BAAsB,gB0D1BC,S1D0BD,C0D1BO,oBAAW,mBAAX,C;G;0HCPrC,yB;IAAA,gC;I7D8CkC,6G;ISF9B,2K;IoD5CJ,wE;M7D8C0C,mC;MStBZ,yC;MoDZE,yC;MpDsCxB,kCAA0B,coDtCG,SpDsCH,EAA6B,YAA7B,EoDtC2B,gBpDsC3B,C;IoDrClC,C;GAbA,C;EAeA,+B;I7D+B0C,mC;IStBZ,yC;IA+BtB,oCAA0B,uBoD9BY,SpD8BZ,C;EoD7BlC,C;EAEA,8C;IAaiC,kBAA7B,2DAAS,qB;aAAW,iB;KAApB,E;I7DhBgC,6B;I8DTJ,uC;IAA5B,iC7D2CI,wBAAc,mB6D3CoB,W7D2CpB,EAAiB,IAAjB,E4DlBuB,gB5DkBvB,C6D3ClB,C;ED0BJ,C;EAEA,8C;IAgBI,6BAAqB,WAAO,QAAP,KAArB,C;EACJ,C;EAkBY,gD;IAAA,4B;MAAE,sBAAS,cAAT,C;MAAiB,W;IAAA,C;G;EAhB/B,8C;IAgBI,mBAAQ,8BAAR,C;EACJ,C;kIC5EA,yB;IAAA,gC;I9DqB4B,6G;IC4BxB,mJ;I6DjDJ,wD;M9DqBoC,6B;M8DTJ,yB;MAA5B,+B7D2CI,wBAAc,mB6D3CoB,S7D2CpB,EAAiB,IAAjB,E6D3CoC,gB7D2CpC,C6D3ClB,C;IACJ,C;GAbA,C;kHAeA,yB;IAAA,gC;I9DM4B,6G;ICkFxB,iL;I6DxFJ,8D;M9DMoC,6B;MCyDpB,+C;M6DvCsB,+B;M7DoE9B,wCAAgC,a6DpEE,S7DoEF,EAAW,OAAX,E6DpEqB,gB7DoErB,C;I6DnExC,C;GAzBA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;yCVZ0D,mN;;;;"}