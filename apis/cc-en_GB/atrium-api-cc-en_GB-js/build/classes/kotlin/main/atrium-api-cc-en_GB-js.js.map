{"version":3,"file":"atrium-api-cc-en_GB-js.js","sources":["../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/AssertImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/anyAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/ExpectImpl.kt","../../../../../kbox-common/src/main/kotlin/ch/tutteli/kbox/varargToList.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charSequenceAssertionsBuilders.kt","generated/_Collections.kt","text/regex/RegexExtensions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/FeatureAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterableAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/throwableAssertionsBuilders.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/anyAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/arrayAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/charSequenceAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/charSequenceContainsCheckers.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/charSequenceContainsCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/charSequenceContainsSearchBehaviours.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/collectionAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/CollectionAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/comparableAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ComparableAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/AtLeastCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/AtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/ButAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/ExactlyCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/NotCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/NotOrAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/charsequence/contains/builders/impl/nameContainsNotFun.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/AtLeastCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/AtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/ButAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/ExactlyCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/NotCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/NotOrAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/creating/iterable/contains/builders/impl/nameContainsNotFun.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/featureAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/floatingPointAssertions.kt","../../../../src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/FloatingPointAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsCheckers.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsInAnyOrderCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsInAnyOrderOnlyCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsInOrderOnlyCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsInOrderOnlyGroupedCreators.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/iterableContainsSearchBehaviours.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/listAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ListAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/mapAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/mapEntryAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapEntryAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/pairAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/PairAssertionsBuilder.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/parameterObjects.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/sequenceAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/throwableAssertions.kt","../../../../../atrium-api-cc-en_GB-common/src/main/kotlin/ch/tutteli/atrium/api/cc/en_GB/typeTransformationAssertions.kt"],"sourcesContent":["@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.BaseAssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.subjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give users of Atrium a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\")\nobject AssertImpl : AssertImplCommon {\n\n    override inline val builder get() = assertionBuilder\n\n    override inline val collector get() = AssertionCollectorBuilder\n\n    override inline val coreFactory get() = ch.tutteli.atrium.core.coreFactory\n\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    override inline val any get() = AnyAssertionsBuilder\n\n    override inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    override inline val collection get() = CollectionAssertionsBuilder\n\n    override inline val comparable get() = ComparableAssertionsBuilder\n\n    @Suppress(\"DEPRECATION\")\n    override inline val feature get() = FeatureAssertionsBuilder\n\n    override inline val floatingPoint get() = FloatingPointAssertionsBuilder\n\n    override inline val iterable get() = IterableAssertionsBuilder\n\n    override inline val list get() = ListAssertionsBuilder\n\n    override inline val map get() = MapAssertionsBuilder\n\n    override inline val pair get() = PairAssertionsBuilder\n\n    override inline val throwable get() = ThrowableAssertionsBuilder\n}\n\ninterface AssertImplCommon {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    val builder: AssertionBuilder\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    val collector: AssertionCollectorBuilder\n\n    /**\n     * Returns the implementation of [CoreFactory].\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.core.coreFactory]\n     * which in turn delegates to the implementation via [loadSingleService].\n     */\n    val coreFactory: CoreFactory\n\n    /**\n     * Creates a new [AssertionPlant] based on the given [subjectProvider] whereas the [AssertionPlant] delegates\n     * assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlant] but merely want to make feature assertions so that\n     * you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlant<R> = subjectChanger.unreportedToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = subjectChanger.unreported(originalAssertionCreator, transformation)\n\n    /**\n     * Creates a new [AssertionPlantNullable] based on the given [subjectProvider] whereas the [AssertionPlant]\n     * delegates assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlantNullable] but merely want to make feature\n     * assertions so that you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R> changeToNullableSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlantNullable<R> = subjectChanger.unreportedNullableToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeToNullableSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = changeSubject(originalAssertionCreator, transformation)\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    val any: AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    val charSequence: CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    val collection: CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    val comparable: ComparableAssertionsBuilder\n\n    /**\n     * Returns [FeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    @Suppress(\"DEPRECATION\")\n    val feature: FeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    val floatingPoint: FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    val iterable: IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    val list: ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    val map: MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    val pair: PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    val throwable: ThrowableAssertionsBuilder\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\", \"DEPRECATION\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.AnyAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.AnyTypeTransformation\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.AnyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.anyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.FailureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.failureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.anyAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [AnyAssertions].\n * In detail, it implements [AnyAssertions] by delegating to [anyAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject AnyAssertionsBuilder : AnyAssertions {\n\n    override inline fun <T : Any> toBe(subjectProvider: SubjectProvider<T>, expected: T): Assertion =\n        anyAssertions.toBe(subjectProvider, expected)\n\n    override inline fun <T> notToBe(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.notToBe(subjectProvider, expected)\n\n    override inline fun <T> isSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isSame(subjectProvider, expected)\n\n    override inline fun <T> isNotSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isNotSame(subjectProvider, expected)\n\n    override inline fun <T> toBeNull(subjectProvider: SubjectProvider<T>) =\n        anyAssertions.toBeNull(subjectProvider)\n\n    override inline fun <T : Any> toBeNullable(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        expectedOrNull: T?\n    ) = anyAssertions.toBeNullable(assertionContainer, type, expectedOrNull)\n\n    override inline fun <T : Any> toBeNullIfNullGivenElse(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (Expect<T>.() -> Unit)?\n    ) = anyAssertions.toBeNullIfNullGivenElse(assertionContainer, type, assertionCreatorOrNull)\n\n    override inline fun <T, TSub : Any> isA(assertionContainer: Expect<T>, subType: KClass<TSub>) =\n        anyAssertions.isA(assertionContainer, subType)\n\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullable(plant: AssertionPlantNullable<T?>, type: KClass<T>, expectedOrNull: T?) =\n        anyAssertions.isNullable(plant, type, expectedOrNull)\n\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyAssertions.isNotNull(plant, type, assertionCreator)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNullBut(plant: AssertionPlantNullable<T?>, type: KClass<T>, expected: T) =\n        anyAssertions.isNotNullBut(plant, type, expected)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullIfNullGivenElse(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (AssertionPlant<T>.() -> Unit)?\n    ) = anyAssertions.isNullIfNullGivenElse(plant, type, assertionCreatorOrNull)\n\n\n    /**\n     * Returns [AnyTypeTransformationAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyTypeTransformationAssertions].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from `Assert` to `Expect` use `ExpectImpl.changeSubject` or `ExpectImpl.feature.extract` instead; will be removed with 1.0.0\")\n    inline val typeTransformation\n        get() = AnyTypeTransformationAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [AnyTypeTransformationAssertions].\n * In detail, it implements [AnyTypeTransformationAssertions] by delegating to [anyTypeTransformationAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationAssertionsBuilder : AnyTypeTransformationAssertions {\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\n        \"This function will be removed in v.1.0.0 in favour of AssertImpl.any.isNotNull\", ReplaceWith(\n            \"plant.addAssertion(AssertImpl.any.isNotNull(plant, type, assertionCreator))\",\n            \"ch.tutteli.atrium.domain.builders.AssertImpl\"\n        )\n    )\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyTypeTransformationAssertions.isNotNull(plant, type, assertionCreator)\n\n    override inline fun <TSub : Any> isA(\n        plant: AssertionPlant<Any>,\n        subType: KClass<TSub>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit\n    ) = anyTypeTransformationAssertions.isA(plant, subType, assertionCreator)\n\n    override inline fun <T : Any, TSub : T> downCast(\n        description: Translatable,\n        subType: KClass<TSub>,\n        subjectPlant: BaseAssertionPlant<T?, *>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit,\n        failureHandler: AnyTypeTransformation.FailureHandler<T, TSub>\n    ) = anyTypeTransformationAssertions.downCast(description, subType, subjectPlant, assertionCreator, failureHandler)\n\n    override inline fun <S : Any, T : Any> transform(\n        parameterObject: AnyTypeTransformation.ParameterObject<S, T>,\n        noinline canBeTransformed: (S) -> Boolean,\n        noinline transform: (S) -> T,\n        failureHandler: AnyTypeTransformation.FailureHandler<S, T>\n    ) = anyTypeTransformationAssertions.transform(parameterObject, canBeTransformed, transform, failureHandler)\n\n    /**\n     * Returns [AnyTypeTransformationFailureHandlerFactoryBuilder]\n     * which inter alia delegates to the implementation of [FailureHandlerFactory].\n     */\n    inline val failureHandlers get() = AnyTypeTransformationFailureHandlerFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [FailureHandlerFactory].\n * In detail, it implements [FailureHandlerFactory] by delegating to [failureHandlerFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationFailureHandlerFactoryBuilder : FailureHandlerFactory {\n\n    override inline fun <S : Any, T : Any> newExplanatory() = failureHandlerFactory.newExplanatory<S, T>()\n\n    override inline fun <S : Any, T : Any> newExplanatoryWithHint(\n        noinline showHint: () -> Boolean,\n        noinline failureHintFactory: () -> Assertion\n    ) = failureHandlerFactory.newExplanatoryWithHint<S, T>(showHint, failureHintFactory)\n}\n","package ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.changers.SubjectChangerBuilder\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.SubjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give assertion writers (and other consumers of the domain) a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\nobject ExpectImpl {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    inline val builder get() = assertionBuilder\n\n    /**\n     * Returns [SubjectChangerBuilder] - helping you to change the subject of the assertion.\n     * In detail, its an `inline` property which returns [SubjectChangerBuilder]\n     * which inter alia delegates to the implementation of [SubjectChanger].\n     *\n     * In case you want to extract a feature (e.g. get the first element of a `List`) instead of changing the subject\n     * into another representation (e.g. down-cast `Person` to `Student`) then you should use\n     * [feature.extractor][NewFeatureAssertionsBuilder.extractor] instead.\n     */\n    inline fun <T> changeSubject(originalAssertionContainer: Expect<T>) =\n        SubjectChangerBuilder.create(originalAssertionContainer)\n\n    @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    inline fun <T> changeSubject(originalAssertionContainer: SubjectProvider<T>) =\n        SubjectChangerBuilder.create(originalAssertionContainer)\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * In detail, its an `inline` property which returns [AssertionCollectorBuilder]\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    inline val collector get() = AssertionCollectorBuilder\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    inline val any get() = AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    inline val collection get() = CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    inline val comparable get() = ComparableAssertionsBuilder\n\n    /**\n     * Returns [NewFeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    inline val feature get() = NewFeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    inline val floatingPoint get() = FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    inline val iterable get() = IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    val list get() = ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    inline val map get() = MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    inline val pair get() = PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    inline val throwable get() = ThrowableAssertionsBuilder\n}\n","package ch.tutteli.kbox\n\n/**\n * Adds the given [arg] and the [otherArgs] into a new [List] and returns it.\n *\n * This function is intended for API functions which expect `x: T, vararg otherX: T` and want to pass the arguments\n * to another function which expects only one argument of `List<T>`.\n *\n * @return a [List] containing [arg] and [otherArgs].\n */\nfun <T> varargToList(arg: T, otherArgs: Array<out T>): List<T> {\n    val list = ArrayList<T>(otherArgs.size + 1)\n    list.add(arg)\n    list.addAll(otherArgs)\n    return list\n}\n\n/**\n * Delegates to [varargToList] -- adds `this` and the [otherArgs] into a new [List] and returns it.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\ninline infix fun <T> T.glue(otherArgs: Array<out T>): List<T> = varargToList(this, otherArgs)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CharSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.CharSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.charSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.SearchBehaviourFactory\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.searchBehaviourFactory\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceAssertions].\n * In detail, it implements [CharSequenceAssertions] by delegating to [charSequenceAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceAssertionsBuilder : CharSequenceAssertions {\n\n    override inline fun <T : CharSequence> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <T : CharSequence> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun startsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsWith(subjectProvider, expected)\n\n    override inline fun startsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsNotWith(subjectProvider, expected)\n\n    override inline fun endsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsWith(subjectProvider, expected)\n\n    override inline fun endsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsNotWith(subjectProvider, expected)\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun isNotBlank(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotBlank(subjectProvider)\n\n    override inline fun <T : CharSequence> matches(assertionContainer: Expect<T>, expected: Regex) =\n        charSequenceAssertions.matches(assertionContainer, expected)\n\n    override inline fun <T : CharSequence> mismatches(assertionContainer: Expect<T>, expected: Regex) =\n        charSequenceAssertions.mismatches(assertionContainer, expected)\n\n    /**\n     * Returns [CharSequenceContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceContainsAssertions].\n     */\n    inline val contains get() = CharSequenceContainsAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceContainsAssertions].\n * In detail, it implements [CharSequenceContainsAssertions] by delegating to [charSequenceContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceContainsAssertionsBuilder : CharSequenceContainsAssertions {\n\n    override inline fun <T : CharSequence> values(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Any>\n    ) = charSequenceContainsAssertions.values(checkerOption, expected)\n\n    override inline fun <T : CharSequence> valuesIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Any>\n    ) = charSequenceContainsAssertions.valuesIgnoringCase(checkerOption, expected)\n\n    override inline fun <T : CharSequence> defaultTranslationOf(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOf(checkerOption, expected)\n\n    override inline fun <T : CharSequence> defaultTranslationOfIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOfIgnoringCase(checkerOption, expected)\n\n    @JvmName(\"stringRegex\")\n    inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<String>\n    ) = regex(checkerOption, expected.map { it.toRegex() })\n\n    override inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Regex>\n    ) = charSequenceContainsAssertions.regex(checkerOption, expected)\n\n    override inline fun <T : CharSequence> regexIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<String>\n    ) = charSequenceContainsAssertions.regexIgnoringCase(checkerOption, expected)\n\n    /**\n     * Returns [CharSequenceContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = CharSequenceContainsSearchBehaviourFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <T : CharSequence> ignoringCase(\n        containsBuilder: CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    ): CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour> =\n        searchBehaviourFactory.ignoringCase(containsBuilder)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Converts the string into a regular expression [Regex] with the default options.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(): Regex = Regex(this)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified single [option].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(option: RegexOption): Regex = Regex(this, option)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified set of [options].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(options: Set<RegexOption>): Regex = Regex(this, options)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\", \"DEPRECATION\")\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.creating.FeatureAssertions\nimport ch.tutteli.atrium.domain.creating.feature.extract.FeatureExtractor\nimport ch.tutteli.atrium.domain.creating.featureAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\nimport kotlin.reflect.*\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [FeatureAssertions].\n * In detail, it implements [FeatureAssertions] by delegating to [featureAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use then ExpectImpl.feature, NewFeatureAssertionsBuilder respectively; will be removed with 1.0.0\")\nobject FeatureAssertionsBuilder : FeatureAssertions {\n\n    @Suppress(\"DEPRECATION\")\n    inline val extractor: FeatureExtractor.DescriptionOption get() = FeatureExtractor.builder\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>)\n        = property(plant, { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) }, Untranslatable(property.name))\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>)\n        = property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable): AssertionPlant<TProperty>\n        = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable): AssertionPlant<TProperty>\n        = featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit)\n        = property(plant, { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) },  Untranslatable(property.name), assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit)\n        = property(plant, property,  Untranslatable(property.name), assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit): AssertionPlant<TProperty>\n        = property(plant, subjectProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit): AssertionPlant<TProperty>\n        = property(plant, subjectProvider, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>): AssertionPlantNullable<TProperty> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\")  property.invoke(plant.subject) }\n        return property(plant, l, Untranslatable(property.name))\n    }\n\n    inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>)\n        = property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable): AssertionPlantNullable<TProperty>\n        = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable): AssertionPlantNullable<TProperty>\n        = featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    //Arg0\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>): AssertionPlant<R>\n        = returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>): AssertionPlant<R>\n        = returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\") method(plant.subject) }\n        return returnValueOf0(plant, l, l, method.name)\n    }\n\n    inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>): AssertionPlantNullable<R>\n        = returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    //Arg1\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1): AssertionPlant<R>\n        = returnValueOf1(plant, {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }, arg1, method.name)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }, arg1, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1) -> R = {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }\n        return returnValueOf1(plant, l, arg1, method.name)\n    }\n\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n        = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    //Arg2\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n        = returnValueOf2(plant, {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }, arg1, arg2, method.name)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }, arg1, arg2, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2) -> R = {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }\n        return returnValueOf2(plant, l, arg1, arg2, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    //Arg3\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n        = returnValueOf3(plant, {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }, arg1, arg2, arg3, method.name)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }, arg1, arg2, arg3, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2, T3) -> R = {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }\n        return returnValueOf3(plant, l, arg1, arg2, arg3, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    //Arg4\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n        = returnValueOf4(plant, {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }, arg1, arg2, arg3, arg4, method.name)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }, arg1, arg2, arg3, arg4, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2, T3, T4) -> R = {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }\n        return returnValueOf4(plant, l, arg1, arg2, arg3, arg4, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    //Arg5\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n        = returnValueOf5(plant, {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }, arg1, arg2, arg3, arg4, arg5, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1, T2, T3, T4, T5) -> R = {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }\n        return returnValueOf5(plant, l, arg1, arg2, arg3, arg4, arg5, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.IterableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.IterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.iterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.*\nimport ch.tutteli.atrium.domain.creating.iterableAssertions\n\n/**\n * Delegates inter alia to the implementation of [IterableAssertions].\n * In detail, it implements [IterableAssertions] by delegating to [iterableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableAssertionsBuilder : IterableAssertions {\n\n    override inline fun <E, T : Iterable<E>> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <E, T : Iterable<E>> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun <E : Any, T : Iterable<E?>> all(\n        assertionContainer: Expect<T>,\n        noinline assertionCreator: (Expect<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(assertionContainer, assertionCreator)\n\n\n    override inline fun <E, T : Iterable<E>> hasNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNext(expect)\n\n    override inline fun <E, T : Iterable<E>> hasNotNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNotNext(expect)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> min(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, E> =\n        iterableAssertions.min(assertionContainer)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> max(assertionContainer: Expect<T>) =\n        iterableAssertions.max(assertionContainer)\n\n    /**\n     * Returns [IterableContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [IterableContainsAssertions].\n     */\n    inline val contains get() = IterableContainsAssertionsBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any> all(\n        plant: AssertionPlant<Iterable<E?>>,\n        noinline assertionCreator: (AssertionPlant<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(plant, assertionCreator)\n}\n\n/**\n * Delegates inter alia to the implementation of [IterableContainsAssertions].\n * In detail, it implements [IterableContainsAssertions] by delegating to [iterableContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableContainsAssertionsBuilder : IterableContainsAssertions {\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrder(checkerOption, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrder(checkerOption, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrderOnly(\n        builder: IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnly(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnly(\n        builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnly(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<E>>\n    ): Assertion = iterableContainsAssertions.valuesInOrderOnlyGrouped(builder, groups)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(Expect<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGrouped(builder, groups)\n\n\n    /**\n     * Returns [IterableContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = IterableContainsSearchBehaviourFactoryBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderWithAssert(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderWithAssert(checkerOption, assertionCreators)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGroupedWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(AssertionPlant<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGroupedWithAssert(builder, groups)\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <E, T : Iterable<E>> inAnyOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inAnyOrderOnly(builder: IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnly(builder: IterableContains.Builder<E, T, InOrderSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGrouped(builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGrouped(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGroupedWithin(builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGroupedWithin(builder)\n\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.creating.ThrowableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ChangedSubjectPostStep\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.ThrowableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.throwableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.providers.absentThrowableMessageProviderFactory\nimport ch.tutteli.atrium.domain.creating.throwableAssertions\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [ThrowableAssertions].\n * In detail, it implements [ThrowableAssertions] by delegating to [throwableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ThrowableAssertionsBuilder : ThrowableAssertions {\n\n    override inline fun thrownBuilder(\n        assertionVerb: Translatable,\n        noinline act: () -> Unit,\n        reporter: Reporter\n    ): ThrowableThrown.Builder = throwableAssertions.thrownBuilder(assertionVerb, act, reporter)\n\n    /**\n     * Returns [ThrowableThrownAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableThrownAssertions].\n     */\n    inline val thrown get() = ThrowableThrownAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ThrowableThrownAssertions].\n * In detail, it implements [ThrowableThrownAssertions] by delegating to [throwableThrownAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ThrowableThrownAssertionsBuilder : ThrowableThrownAssertions {\n\n    override inline fun <TExpected : Throwable> isA(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>\n    ) = throwableThrownAssertions.isA(throwableThrownBuilder, expectedType)\n\n    override inline fun notThrown(\n        throwableThrownBuilder: ThrowableThrown.Builder\n    ): ChangedSubjectPostStep<Throwable?, Nothing?> = throwableThrownAssertions.notThrown(throwableThrownBuilder)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <TExpected : Throwable> toBe(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>,\n        noinline assertionCreator: AssertionPlant<TExpected>.() -> Unit\n    ) = throwableThrownAssertions.toBe(throwableThrownBuilder, expectedType, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun nothingThrown(throwableThrownBuilder: ThrowableThrown.Builder) =\n        throwableThrownAssertions.nothingThrown(throwableThrownBuilder)\n\n    /**\n     * Returns [AbsentThrowableMessageProviderFactoryBuilder]\n     * which inter alia delegates to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Will be removed with 1.0.0\")\n    inline val providers\n        get() = AbsentThrowableMessageProviderFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n * In detail, it implements [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory] by delegating to [absentThrowableMessageProviderFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Will be removed with 1.0.0\")\nobject AbsentThrowableMessageProviderFactoryBuilder :\n    ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory {\n\n    override inline fun translatableBased(translatable: Translatable): ThrowableThrown.AbsentThrowableMessageProvider =\n        absentThrowableMessageProviderFactory.translatableBased(translatable)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"AnyAssertionsKt\")\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.checking.AssertionChecker\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.reporting.Reporter\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is (equal to) [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).toBe(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().toBe(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBe\"\n    )\n)\nfun <T : Any> Assert<T>.toBe(expected: T) = addAssertion(AssertImpl.any.toBe(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not (equal to) [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).notToBe(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().notToBe(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notToBe\"\n    )\n)\nfun <T : Any> Assert<T>.notToBe(expected: T) = addAssertion(AssertImpl.any.notToBe(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is the same instance as [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).isSameAs(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isSameAs(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isSameAs\"\n    )\n)\nfun <T : Any> Assert<T>.isSameAs(expected: T) = addAssertion(AssertImpl.any.isSame(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not the same instance as [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `assert(1).isNotSameAs(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isNotSameAs(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotSameAs\"\n    )\n)\nfun <T : Any> Assert<T>.isNotSameAs(expected: T) = addAssertion(AssertImpl.any.isNotSame(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is [expected].\n *\n * @return Does not support a fluent API because: what else would you want to assert about `null` anyway?\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().toBe(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBe\"\n    )\n)\ninline fun <reified T : Any> AssertionPlantNullable<T?>.toBe(expected: T?) {\n    addAssertion(AssertImpl.any.isNullable(this, T::class, expected))\n}\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is either `null` if [assertionCreatorOrNull]\n * is `null` or is not `null` and holds all assertions [assertionCreatorOrNull] might create.\n *\n * It is a shortcut for\n * ```kotlin\n * if (assertionCreatorOrNull == null) toBe(null)\n * else notToBeNull(assertionCreatorOrNull)\n * ```\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().toBeNullIfNullGivenElse(assertionCreatorOrNull).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBeNullIfNullGivenElse\"\n    )\n)\ninline fun <reified T : Any> AssertionPlantNullable<T?>.toBeNullIfNullGivenElse(\n    noinline assertionCreatorOrNull: (Assert<T>.() -> Unit)?\n) {\n    addAssertion(AssertImpl.any.isNullIfNullGivenElse(this, T::class, assertionCreatorOrNull))\n}\n\n/**\n * Can be used to separate assertions when using the fluent API.\n *\n * For instance `assert(1).isLessThan(2).and.isGreaterThan(0)` creates\n * two assertions (not one assertion with two sub-assertions) - the first asserts that 1 is less than 2 and a second\n * asserts that 1 is greater than 0. If the first assertion fails, then usually (depending on the configured\n * [AssertionChecker]) the second assertion is not evaluated.\n *\n * @return This plant to support a fluent API.\n */\nval <T : Any> AssertionPlant<T>.and: AssertionPlant<T> get() = this\n\n/**\n * Can be used to create a group of sub assertions when using the fluent API.\n *\n * For instance `assert(1).isLessThan(3).and { isEven(); isGreaterThan(1) }` creates\n * two assertions where the second one consists of two sub-assertions. In case the first assertion holds, then the\n * second one is evaluated as a whole. Meaning, even though 1 is not even, it still evaluates that 1 is greater than 1.\n * Hence the reporting might (depending on the configured [Reporter]) contain both failing sub-assertions.\n *\n * @return This plant to support a fluent API.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().and(assertionCreator).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.and\"\n    )\n)\ninfix fun <T : Any> AssertionPlant<T>.and(assertionCreator: Assert<T>.() -> Unit) =\n    addAssertionsCreatedBy(assertionCreator)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\nimport kotlin.jvm.JvmName\n\n/**\n * Turns `Assert<Array<E>>` into `Assert<Iterable<E>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Array<out E>::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\nfun <E> Assert<Array<out E>>.asIterable(): Assert<Iterable<E>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<Array<E>>` into `Assert<Iterable<E>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Array<out E>::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\nfun <E> Assert<Array<out E>>.asIterable(assertionCreator: Assert<Iterable<E>>.() -> Unit): Assert<Iterable<E>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Byte>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ByteArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [Assert] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"byteArrAsIterable\")\nfun Assert<ByteArray>.asIterable(): Assert<Iterable<Byte>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Byte>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ByteArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [Assert] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"byteArrAsIterable\")\nfun Assert<ByteArray>.asIterable(assertionCreator: Assert<Iterable<Byte>>.() -> Unit): Assert<Iterable<Byte>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Char>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(CharArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"charArrAsIterable\")\nfun Assert<CharArray>.asIterable(): Assert<Iterable<Char>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Char>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(CharArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"charArrAsIterable\")\nfun Assert<CharArray>.asIterable(assertionCreator: Assert<Iterable<Char>>.() -> Unit): Assert<Iterable<Char>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<ShortArray>` into `Assert<Iterable<Short>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ShortArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"shortArrAsIterable\")\nfun Assert<ShortArray>.asIterable(): Assert<Iterable<Short>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<ShortArray>` into `Assert<Iterable<Short>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ShortArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"shortArrAsIterable\")\nfun Assert<ShortArray>.asIterable(assertionCreator: Assert<Iterable<Short>>.() -> Unit): Assert<Iterable<Short>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<IntArray>` into `Assert<Iterable<Int>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(IntArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"intArrAsIterable\")\nfun Assert<IntArray>.asIterable(): Assert<Iterable<Int>> = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<IntArray>` into `Assert<Iterable<Int>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(IntArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"intArrAsIterable\")\nfun Assert<IntArray>.asIterable(assertionCreator: Assert<Iterable<Int>>.() -> Unit): Assert<Iterable<Int>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<LongArray>` into `Assert<Iterable<Double>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(LongArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"longArrAsIterable\")\nfun Assert<LongArray>.asIterable(): Assert<Iterable<Long>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<LongArray>` into `Assert<Iterable<Double>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(LongArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"longArrAsIterable\")\nfun Assert<LongArray>.asIterable(assertionCreator: Assert<Iterable<Long>>.() -> Unit): Assert<Iterable<Long>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<FloatArray>` into `Assert<Iterable<Float>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(FloatArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"floatArrAsIterable\")\nfun Assert<FloatArray>.asIterable(): Assert<Iterable<Float>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<FloatArray>` into `Assert<Iterable<Float>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(FloatArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"floatArrAsIterable\")\nfun Assert<FloatArray>.asIterable(assertionCreator: Assert<Iterable<Float>>.() -> Unit): Assert<Iterable<Float>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<DoubleArray>` into `Assert<Iterable<Double>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(DoubleArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"doubleArrAsIterable\")\nfun Assert<DoubleArray>.asIterable(): Assert<Iterable<Double>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<DoubleArray>` into `Assert<Iterable<Double>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(DoubleArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"doubleArrAsIterable\")\nfun Assert<DoubleArray>.asIterable(assertionCreator: Assert<Iterable<Double>>.() -> Unit): Assert<Iterable<Double>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<BooleanArray>` into `Assert<Iterable<Boolean>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(BooleanArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"boolArrAsIterable\")\nfun Assert<BooleanArray>.asIterable(): Assert<Iterable<Boolean>> =\n    ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<BooleanArray>` into `Assert<Iterable<Boolean>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(BooleanArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\n@JvmName(\"boolArrAsIterable\")\nfun Assert<BooleanArray>.asIterable(assertionCreator: Assert<Iterable<Boolean>>.() -> Unit): Assert<Iterable<Boolean>> =\n    asIterable().addAssertionsCreatedBy(assertionCreator)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NotSearchBehaviour\n\n/**\n * Creates a [CharSequenceContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().contains\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nval <T : CharSequence> Assert<T>.contains: CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    get() = AssertImpl.charSequence.containsBuilder(this)\n\n/**\n * Creates a [CharSequenceContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains not` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsNot\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNot\"\n    )\n)\nval <T : CharSequence> Assert<T>.containsNot: NotCheckerOption<T, NotSearchBehaviour>\n    get() = NotCheckerOptionImpl(AssertImpl.charSequence.containsNotBuilder(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains [expected]'s [toString] representation\n * and the [toString] representation of the [otherExpected] (if given), using a non disjoint search.\n *\n * It is a shortcut for `contains.atLeast(1).values(expected, *otherExpected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use the property `contains` to create a more sophisticated `contains`\n * assertion where you can use options such as [atLeast], [atMost] and [exactly] to control the number of occurrences\n * you expect.\n *\n * Meaning you might want to use:\n *   `contains.exactly(2).value('a')`\n * instead of:\n *   `contains('a', 'a')`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().contains(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <T : CharSequence> Assert<T>.contains(expected: Any, vararg otherExpected: Any): AssertionPlant<T> =\n    contains.atLeast(1).values(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain [expected]'s [toString] representation\n * and neither one of the [otherExpected]'s [toString] representation (if given).\n *\n * It is a shortcut for `containsNot.values(expected, *otherExpected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsNot(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNot\"\n    )\n)\nfun <T : CharSequence> Assert<T>.containsNot(expected: Any, vararg otherExpected: Any) =\n    containsNot.values(expected, *otherExpected)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a sequence which matches the given regular expression\n * [pattern] as well as the [otherPatterns] (if given), using a non disjoint search.\n *\n * It is a shortcut for `contains.atLeast(1).regex(pattern, *otherPatterns)`.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to\n * control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.exactly(2).regex('a(b)?')`\n * instead of:\n *   `contains.atLeast(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsRegex(pattern, *otherPatterns).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsRegex\"\n    )\n)\nfun <T : CharSequence> Assert<T>.containsRegex(pattern: String, vararg otherPatterns: String): AssertionPlant<T> =\n    contains.atLeast(1).regex(pattern, *otherPatterns)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] starts with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().startsWith(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.startsWith\"\n    )\n)\nfun <T : CharSequence> Assert<T>.startsWith(expected: CharSequence) =\n    addAssertion(AssertImpl.charSequence.startsWith(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not start with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().startsNotWith(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.startsNotWith\"\n    )\n)\nfun <T : CharSequence> Assert<T>.startsNotWith(expected: CharSequence) =\n    addAssertion(AssertImpl.charSequence.startsNotWith(this, expected))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] ends with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().endsWith(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.endsWith\"\n    )\n)\nfun <T : CharSequence> Assert<T>.endsWith(expected: CharSequence) =\n    addAssertion(AssertImpl.charSequence.endsWith(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not end with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().endsNotWith(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.endsNotWith\"\n    )\n)\nfun <T : CharSequence> Assert<T>.endsNotWith(expected: CharSequence) =\n    addAssertion(AssertImpl.charSequence.endsNotWith(this, expected))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isEmpty].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isEmpty\"\n    )\n)\nfun <T : CharSequence> Assert<T>.isEmpty() = addAssertion(AssertImpl.charSequence.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isNotEmpty].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isNotEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotEmpty\"\n    )\n)\nfun <T : CharSequence> Assert<T>.isNotEmpty() = addAssertion(AssertImpl.charSequence.isNotEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isNotBlank].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isNotBlank().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotBlank\"\n    )\n)\nfun <T : CharSequence> Assert<T>.isNotBlank() = addAssertion(AssertImpl.charSequence.isNotBlank(this))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.*\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl.*\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we are looking\n * for occurs `at least` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.atLeast(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.atLeast\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.atLeast(times: Int): AtLeastCheckerOption<T, S> =\n    AtLeastCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains at least` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `at most` number of [times] within the search input.\n *\n * The resulting restriction will be a `contains at least but at most` assertion.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] of this `at most` restriction equals to the number of the\n *   `at least` restriction; use the [exactly] restriction instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.butAtMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.butAtMost\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> AtLeastCheckerOption<T, S>.butAtMost(times: Int): ButAtMostCheckerOption<T, S> =\n    ButAtMostCheckerOptionImpl(times, this, containsBuilder)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `exactly` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.exactly(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.exactly\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.exactly(times: Int): ExactlyCheckerOption<T, S> =\n    ExactlyCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `at least` once but `at most` number of [times] within the search input.\n *\n * If you want to use a higher lower bound than one, then use `atLeast(2).butAtMost(3)` instead of `atMost(3)`.\n * And in case you want to state that it is either not contained at all or at most a certain number of times,\n * then use `notOrAstMost(2)` instead.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] equals to one; use [exactly] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.atMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.atMost\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.atMost(times: Int): AtMostCheckerOption<T, S> =\n    AtMostCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `not at all or at most` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the actual number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.notOrAtMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notOrAtMost\"\n    )\n)\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.notOrAtMost(times: Int): NotOrAtMostCheckerOption<T, S> =\n    NotOrAtMostCheckerOptionImpl(times, this)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.kbox.glue\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] object shall be searched,\n * using a non disjoint search.\n *\n * Delegates to `values(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.value(expected: Any): AssertionPlant<T> =\n    values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value as well as\n * the [otherExpected] values shall be searched, using a non disjoint search.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to control\n * the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.exactly(2).value('a')`\n * instead of:\n *   `contains.atLeast(1).values('a', 'a')`\n *\n * @param expected The value which is expected to be contained within the input of the search.\n * @param otherExpected Additional values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.values(\n    expected: Any,\n    vararg otherExpected: Any\n): AssertionPlant<T> = addAssertion(AssertImpl.charSequence.contains.values(this, expected glue otherExpected))\n\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value shall be searched\n * (ignoring case), using a non disjoint search.\n *\n * Delegates to `values(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\n@JvmName(\"valueIgnoringCase\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.value(expected: Any): AssertionPlant<T> =\n    values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value as well as\n * the [otherExpected] values shall be searched (ignoring case), using a non disjoint search.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to control\n * the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.ignoringCase.exactly(2).value('a')`\n * instead of:\n *   `contains.ignoringCase.atLeast(1).values('a', 'a')`\n *\n * @param expected The value which is expected to be contained within the input of the search.\n * @param otherExpected Additional values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\n@JvmName(\"valuesIgnoringCase\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.values(\n    expected: Any,\n    vararg otherExpected: Any\n): AssertionPlant<T> =\n    addAssertion(AssertImpl.charSequence.contains.valuesIgnoringCase(this, expected glue otherExpected))\n\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value shall be searched\n * (ignoring case), using a non disjoint search where it needs to be contained at least once.\n *\n * Delegates to `atLeast(1).values(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.value(expected: Any): AssertionPlant<T> =\n    atLeast(1).value(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value as well as\n * the [otherExpected] values shall be searched (ignoring case), using a non disjoint search\n * where each need to be contained at least once.\n *\n * Delegates to `atLeast(1).values(expected, otherExpected)`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n * @param otherExpected Additional values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.values(\n    expected: Any,\n    vararg otherExpected: Any\n): AssertionPlant<T> = atLeast(1).values(expected, *otherExpected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * as well as the [otherPatterns] are expected to have a match, using a non disjoint search.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to\n * control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.exactly(2).regex('a(b)?')`\n * instead of:\n *   `contains.atLeast(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.regex(pattern, *otherPatterns)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.regex\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.regex(\n    pattern: String,\n    vararg otherPatterns: String\n): AssertionPlant<T> = addAssertion(AssertImpl.charSequence.contains.regex(this, pattern glue otherPatterns))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * as well as the [otherPatterns] are expected to have a match (ignoring case), using a non disjoint search.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly] to\n * control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.ignoringCase.exactly(2).regex('a(b)?')`\n * instead of:\n *   `contains.ignoringCase.atLeast(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@JvmName(\"regexIgnoringCase\")\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.regex(pattern, *otherPatterns)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.regex\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.regex(\n    pattern: String,\n    vararg otherPatterns: String\n): AssertionPlant<T> =\n    addAssertion(AssertImpl.charSequence.contains.regexIgnoringCase(this, pattern glue otherPatterns))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * as well as the [otherPatterns] are expected to to have at least one match (ignoring case),\n * using a non disjoint search.\n *\n * Delegates to `atLeast(1).regex(pattern, otherPatterns)`\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [atLeast], [atMost] and [exactly]\n * to control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.ignoringCase.exactly(2).regex('a(b)?')`\n * instead of:\n *   `contains.ignoringCase.atLeast(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.regex(pattern, *otherPatterns)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.regex\"\n    )\n)\nfun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.regex(\n    pattern: String,\n    vararg otherPatterns: String\n): AssertionPlant<T> = atLeast(1).regex(pattern, *otherPatterns)\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nprivate fun <T : CharSequence, S : CharSequenceContains.SearchBehaviour> CharSequenceContains.CheckerOption<T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NotSearchBehaviour\n\n/**\n * Defines that the v behaviour `ignore case` shall be applied to this sophisticated `contains` assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.ignoringCase\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.ignoringCase\"\n    )\n)\nval <T : CharSequence> CharSequenceContains.Builder<T, NoOpSearchBehaviour>.ignoringCase\n    get() : CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>\n    = AssertImpl.charSequence.contains.searchBehaviours.ignoringCase(this)\n\n/**\n * Defines that the search behaviour `ignore case` shall be applied to this sophisticated `contains not` assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.ignoringCase\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.ignoringCase\"\n    )\n)\nval <T : CharSequence> NotCheckerOption<T, NotSearchBehaviour>.ignoringCase\n    get() : NotCheckerOption<T, IgnoringCaseSearchBehaviour>\n    = NotCheckerOptionImpl(containsBuilder.ignoringCase)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Collection.size] is [size].\n *\n * Shortcut for `size.toBe(expectedSize)` depends on the underlying implementation though.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().hasSize(size).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.hasSize\"\n    )\n)\nfun <T : Collection<*>> Assert<T>.hasSize(size: Int)\n    = addAssertion(AssertImpl.collection.hasSize(this, size))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is an empty [Collection].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isEmpty\"\n    )\n)\nfun <T : Collection<*>> Assert<T>.isEmpty()\n    = addAssertion(AssertImpl.collection.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not an empty [Collection].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isNotEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotEmpty\"\n    )\n)\nfun <T : Collection<*>> Assert<T>.isNotEmpty()\n    = addAssertion(AssertImpl.collection.isNotEmpty(this))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property\n * [size][Collection.size] so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().size\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.size\"\n    )\n)\nval Assert<Collection<*>>.size get(): Assert<Int> = property(Collection<*>::size)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [size][Collection.size]\n * holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().size.asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.size\"\n    )\n)\nfun <E, T: Collection<E>> Assert<T>.size(assertionCreator: Assert<Int>.() -> Unit): Assert<T>\n    = addAssertion(AssertImpl.collection.size(this, assertionCreator))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CollectionAssertions\nimport ch.tutteli.atrium.domain.creating.collectionAssertions\n\n/**\n * Delegates inter alia to the implementation of [CollectionAssertions].\n * In detail, it implements [CollectionAssertions] by delegating to [collectionAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CollectionAssertionsBuilder : CollectionAssertions {\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Collection<*>> size(assertionContainer: Expect<T>) =\n        collectionAssertions.size(assertionContainer)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Collection<*>>, size: Int) =\n        collectionAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun size(plant: AssertionPlant<Collection<*>>, noinline assertionCreator: Assert<Int>.() -> Unit) =\n        collectionAssertions.size(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is less than [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isLessThan(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isLessThan\"\n    )\n)\nfun <T : Comparable<T>> Assert<T>.isLessThan(expected: T)\n    = addAssertion(AssertImpl.comparable.isLessThan(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is less than or equals [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isLessOrEquals(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isLessOrEquals\"\n    )\n)\nfun <T : Comparable<T>> Assert<T>.isLessOrEquals(expected: T)\n    = addAssertion(AssertImpl.comparable.isLessOrEquals(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is greater than [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isGreaterThan(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isGreaterThan\"\n    )\n)\nfun <T : Comparable<T>> Assert<T>.isGreaterThan(expected: T)\n    = addAssertion(AssertImpl.comparable.isGreaterThan(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is greater than or equals [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isGreaterOrEquals(expected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isGreaterOrEquals\"\n    )\n)\nfun <T : Comparable<T>> Assert<T>.isGreaterOrEquals(expected: T)\n    = addAssertion(AssertImpl.comparable.isGreaterOrEquals(this, expected))\n\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.ComparableAssertions\nimport ch.tutteli.atrium.domain.creating.comparableAssertions\n\n/**\n * Delegates inter alia to the implementation of [ComparableAssertions].\n * In detail, it implements [ComparableAssertions] by delegating to [comparableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ComparableAssertionsBuilder : ComparableAssertions {\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessOrEquals(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterOrEquals(subjectProvider, expected)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.AtLeastCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains at least`-check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class AtLeastCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : AtLeastCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::atLeast.name}($it)\" }\n), AtLeastCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.AtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.AtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class AtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : AtMostCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::atMost.name}($it)\" },\n    { \"${containsBuilder::atLeast.name}($it)\" },\n    { \"${containsBuilder::exactly.name}($it)\" }\n), AtMostCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.en_GB.butAtMost\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.ButAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.ButAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied to the input of the search.\n *\n * @constructor Represents the builder of the second step of a `contains at least but at most` check within the\n *   fluent API of a sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class ButAtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    atLeastBuilder: AtLeastCheckerOption<T, S>,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : ButAtMostCheckerOptionBase<T, S>(\n    times,\n    atLeastBuilder,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { l, u -> \"${containsBuilder::atLeast.name}($l).${atLeastBuilder::butAtMost.name}($u)\" },\n    { \"${containsBuilder::atMost.name}($it)\" },\n    { \"${containsBuilder::atLeast.name}($it)\" },\n    { \"${atLeastBuilder::butAtMost.name}($it)\" },\n    { \"${containsBuilder::exactly.name}($it)\" }\n), ButAtMostCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.ExactlyCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.ExactlyCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class ExactlyCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : ExactlyCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::exactly.name}($it)\" }\n), ExactlyCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.NotCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n *  Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class NotCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : NotCheckerOptionBase<T, S>(containsBuilder),\n    NotCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.NotOrAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.notOrAtMost\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.NotOrAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not or at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\ninternal class NotOrAtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : NotOrAtMostCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::notOrAtMost.name}($it)\" }\n), NotOrAtMostCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.containsNot\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport kotlin.reflect.KFunction3\n\ninternal fun nameContainsNotValuesFun(): String {\n    val f: KFunction3<AssertionPlant<CharSequence>, Any, Array<out Any>, AssertionPlant<CharSequence>> = AssertionPlant<CharSequence>::containsNot\n    return f.name\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.AtLeastCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n *   `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class AtLeastCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : AtLeastCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::atLeast.name}($it)\" }\n), AtLeastCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.AtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.AtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class AtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : AtMostCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::atMost.name}($it)\" },\n    { \"${containsBuilder::atLeast.name}($it)\" },\n    { \"${containsBuilder::exactly.name}($it)\" }\n), AtMostCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.atLeast\nimport ch.tutteli.atrium.api.cc.en_GB.atMost\nimport ch.tutteli.atrium.api.cc.en_GB.butAtMost\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.ButAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.ButAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of the second step of a `contains at least but at most` check within the\n *   fluent API of a sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class ButAtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    atLeastBuilder: AtLeastCheckerOption<E, T, S>,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : ButAtMostCheckerOptionBase<E, T, S>(\n    times,\n    atLeastBuilder,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { l, u -> \"${containsBuilder::atLeast.name}($l).${atLeastBuilder::butAtMost.name}($u)\" },\n    { \"${containsBuilder::atMost.name}($it)\" },\n    { \"${containsBuilder::atLeast.name}($it)\" },\n    { \"${atLeastBuilder::butAtMost.name}($it)\" },\n    { \"${containsBuilder::exactly.name}($it)\" }\n), ButAtMostCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.ExactlyCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.exactly\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.ExactlyCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class ExactlyCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : ExactlyCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::exactly.name}($it)\" }\n), ExactlyCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.NotCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n *   `contains not` assertion for [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class NotCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : NotCheckerOptionBase<E, T, S>(containsBuilder),\n    NotCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.NotOrAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.notOrAtMost\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.NotOrAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\ninternal class NotOrAtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : NotOrAtMostCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::notOrAtMost.name}($it)\" }\n), NotOrAtMostCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.en_GB.containsNot\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport kotlin.reflect.KFunction3\n\ninternal fun nameContainsNotValuesFun(): String {\n    val f: KFunction3<AssertionPlant<Iterable<Double>>, Double, Array<out Double>, AssertionPlant<Iterable<Double>>> =\n        AssertionPlant<Iterable<Double>>::containsNot\n    return f.name\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.FeatureAssertionGroupType\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.CollectingAssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.PleaseUseReplacementException\nimport kotlin.reflect.*\nimport kotlin.jvm.JvmName\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlant] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(property) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty0<TProperty>): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>): AssertionPlant<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlant] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(property).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty1<T, TProperty>): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant --\n * starting with a group consisting of the [Assertion]s created by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the given [property].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(property) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty0<TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant --\n * starting with a group consisting of the [Assertion]s created by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the given [property].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(property, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty1<T, TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(property) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any?> Assert<T>.property(property: KProperty0<TProperty>): AssertionPlantNullable<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any?> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>): AssertionPlantNullable<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(property).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, TProperty : Any?> Assert<T>.property(property: KProperty1<T, TProperty>): AssertionPlantNullable<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n\n// Arg 0 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds [AssertionGroup]s\n * with a [FeatureAssertionGroupType], containing the assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction0<R>): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction0<R>): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds [AssertionGroup]s\n * with a [FeatureAssertionGroupType], containing the assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction1<T, R>): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction0<R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction0<R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any> Assert<T>.returnValueOf(method: KFunction1<T, R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any?> Assert<T>.returnValueOf(method: KFunction0<R>): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction0<R>): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, R : Any?> Assert<T>.returnValueOf(method: KFunction1<T, R>): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n\n// Arg 1 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n//    ReplaceWith(\n//        \"this.asExpect().feature(method, arg1).asAssert()\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n//    )\n//)\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction2<T, T1, R>, arg1: T1): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any> Assert<T>.returnValueOf(method: KFunction2<T, T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any?> Assert<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, R : Any?> Assert<T>.returnValueOf(method: KFunction2<T, T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n\n// Arg 2 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1, arg2) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any> Assert<T>.returnValueOf(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1] and [arg2], which\n * eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any?> Assert<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1] and [arg2], which\n * eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, R : Any?> Assert<T>.returnValueOf(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n\n// Arg 3 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1, arg2, arg3, arg4) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.returnValueOf(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any?> Assert<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, R : Any?> Assert<T>.returnValueOf(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n\n// Arg 4 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3, arg4) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1, arg2, arg3, arg4) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.returnValueOf(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3]\n * and [arg4], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3, arg4) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any?> Assert<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3]\n * and [arg4], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, R : Any?> Assert<T>.returnValueOf(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n\n// Arg 5 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3, arg4, arg5) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4, arg5).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created\n * by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature({ f(method, arg1, arg2, arg3, arg4, arg5) }, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> CollectingAssertionPlant<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created\n * by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4, arg5, { asAssert(assertionCreator) }).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.returnValueOf(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3],\n * [arg4] and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the\n * assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature { f(method, arg1, arg2, arg3, arg4, arg5) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> Assert<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> CollectingAssertionPlant<T>.returnValueOf(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3],\n * [arg4] and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the\n * assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@JvmName(\"safeReturnValueOf\")\n@Deprecated(\n    \"Switch from Assert to Expect and use feature instead; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().feature(method, arg1, arg2, arg3, arg4, arg5).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.feature\"\n    )\n)\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> Assert<T>.returnValueOf(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"FloatingPointAssertionsKt\")\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is equal to [expected] with an error [tolerance]\n * (range including bounds).\n *\n * It effectively compares the absolute difference between [Assert.subject][SubjectProvider.subject] and [expected] and compares it with\n * the [tolerance]. As long as it is less than or equal the [tolerance] the assertion holds; otherwise it fails.\n * A more mathematical way of expressing the assertion is the following inequality:\n *\n * | [Assert.subject][SubjectProvider.subject] - [expected] | \u2264 [tolerance]\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().toBeWithErrorTolerance(expected, tolerance).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBeWithErrorTolerance\"\n    )\n)\nfun Assert<Float>.toBeWithErrorTolerance(expected: Float, tolerance: Float)\n    = addAssertion(AssertImpl.floatingPoint.toBeWithErrorTolerance(this, expected, tolerance))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is equal to [expected] with an error [tolerance]\n * (range including bounds).\n *\n * It effectively compares the absolute difference between [Assert.subject][SubjectProvider.subject] and [expected] and compares it with\n * the [tolerance]. As long as it is less than or equal the [tolerance] the assertion holds; otherwise it fails.\n * A more mathematical way of expressing the assertion is the following inequality:\n *\n * | [Assert.subject][SubjectProvider.subject] - [expected] | \u2264 [tolerance]\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().toBeWithErrorTolerance(expected, tolerance).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toBeWithErrorTolerance\"\n    )\n)\nfun Assert<Double>.toBeWithErrorTolerance(expected: Double, tolerance: Double)\n    = addAssertion(AssertImpl.floatingPoint.toBeWithErrorTolerance(this, expected, tolerance))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.FloatingPointAssertions\nimport ch.tutteli.atrium.domain.creating.floatingPointAssertions\n\n/**\n * Delegates inter alia to the implementation of [FloatingPointAssertions].\n * In detail, it implements [FloatingPointAssertions] by delegating to [floatingPointAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nactual object FloatingPointAssertionsBuilder : FloatingPointAssertions {\n\n    override inline fun toBeWithErrorTolerance(\n        subjectProvider: SubjectProvider<Float>,\n        expected: Float,\n        tolerance: Float\n    ) = floatingPointAssertions.toBeWithErrorTolerance(subjectProvider, expected, tolerance)\n\n    override inline fun toBeWithErrorTolerance(\n        subjectProvider: SubjectProvider<Double>,\n        expected: Double,\n        tolerance: Double\n    ) = floatingPointAssertions.toBeWithErrorTolerance(subjectProvider, expected, tolerance)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NotSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Creates an [IterableContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().contains\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nval <E, T : Iterable<E>> Assert<T>.contains: IterableContains.Builder<E, T, NoOpSearchBehaviour>\n    get() = AssertImpl.iterable.containsBuilder(this)\n\n/**\n * Creates an [IterableContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains not` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsNot\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNot\"\n    )\n)\nval <E, T : Iterable<E>> Assert<T>.containsNot: NotCheckerOption<E, T, NotSearchBehaviour>\n    get() = NotCheckerOptionImpl(AssertImpl.iterable.containsNotBuilder(this))\n\n\n/**c\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the\n * [expected] value and the [otherExpected] values (if given).\n *\n * It is a shortcut for `contains.inAnyOrder.atLeast(1).values(expected, *otherExpected)`\n *\n * Notice, that it does not search for unique matches. Meaning, if the iterable is `setOf('a', 'b')` and [expected] is\n * defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same entry. Use an option such as [atLeast], [atMost] and [exactly] to control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.inAnyOrder.exactly(2).value('a')`\n * instead of:\n *   `contains('a', 'a')`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().contains(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <E, T: Iterable<E>> Assert<T>.contains(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = contains.inAnyOrder.atLeast(1).values(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding the\n * assertions created by [assertionCreatorOrNull] or an entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * It is a shortcut for `contains.inAnyOrder.atLeast(1).entry(assertionCreatorOrNull)`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().contains(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <E: Any, T: Iterable<E?>> Assert<T>.contains(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inAnyOrder.atLeast(1).entry(assertionCreatorOrNull)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding the\n * assertions created by [assertionCreatorOrNull] or an entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null` -- likewise an entry (can be the same) is searched for each\n * of the [otherAssertionCreatorsOrNulls].\n *\n * It is a shortcut for `contains.inAnyOrder.atLeast(1).entries(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().contains(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it)}.toTypedArray()\\n\" +\n            \").asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <E: Any, T: Iterable<E?>> Assert<T>.contains(assertionCreatorOrNull: (Assert<E>.() -> Unit)?, vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inAnyOrder.atLeast(1).entries(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only\n * the [expected] value and the [otherExpected] values (if given) in the defined order.\n *\n * It is a shortcut for `contains.inOrder.only.values(expected, *otherExpected)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsExactly(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsExactly\"\n    )\n)\nfun <E, T : Iterable<E>> Assert<T>.containsExactly(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = contains.inOrder.only.values(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only an entry holding\n * the assertions created by [assertionCreatorOrNull] or only one entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * It is a shortcut for `contains.inOrder.only.entry(assertionCreatorOrNull)`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsExactly(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsExactly\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.containsExactly(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inOrder.only.entry(assertionCreatorOrNull)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only an entry holding\n * the assertions created by [assertionCreatorOrNull] or `null` in case [assertionCreatorOrNull] is defined as `null`\n * and likewise an additional entry for each [otherAssertionCreatorsOrNulls] (if given)\n * whereas the entries have to appear in the defined order.\n *\n * It is a shortcut for `contains.inOrder.only.entries(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)`\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsExactly(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it) }.toTypedArray()\\n\" +\n            \").asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsExactly\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.containsExactly(assertionCreatorOrNull: (Assert<E>.() -> Unit)?, vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inOrder.only.entries(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the [expected] value\n * and neither one of the [otherExpected] values (if given).\n *\n *  It is a shortcut for `containsNot.values(expected, *otherExpected)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsNot(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNot\"\n    )\n)\nfun <E, T : Iterable<E>> Assert<T>.containsNot(expected: E, vararg otherExpected: E)\n    = containsNot.values(expected, *otherExpected)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding\n * the assertions created by [assertionCreatorOrNull] or an entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * It is a shortcut for `contains.inAnyOrder.atLeast(1).entry(assertionCreatorOrNull)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().any(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.any\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.any(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = contains.inAnyOrder.atLeast(1).entry(assertionCreatorOrNull)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain a single entry\n * which holds all assertions created by [assertionCreatorOrNull] or does not contain a single entry which is `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n *  It is a shortcut for `containsNot.entry(assertionCreatorOrNull)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().none(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.none\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.none(assertionCreatorOrNull: (Assert<E>.() -> Unit)?)\n    = containsNot.entry(assertionCreatorOrNull)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] has at least one element and\n * that every element holds all assertions created by the [assertionCreatorOrNull] or that all elements are `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().all(asSubExpect(assertionCreatorOrNull)).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.all\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> Assert<T>.all(assertionCreatorOrNull: (Assert<E>.() -> Unit)?)\n    = addAssertion(AssertImpl.iterable.all(this, assertionCreatorOrNull))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.*\nimport ch.tutteli.atrium.api.cc.en_GB.creating.iterable.contains.builders.impl.*\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we are looking\n * for occurs `at least` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.atLeast(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.atLeast\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.atLeast(times: Int): AtLeastCheckerOption<E, T, S>\n    = AtLeastCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains at least` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `at most` number of [times] within the [Iterable].\n *\n * The resulting restriction will be a `contains at least but at most` assertion.\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] of this `at most` restriction equals to the number of the\n *   `at least` restriction; use the [exactly] restriction instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.butAtMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.butAtMost\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> AtLeastCheckerOption<E, T, S>.butAtMost(times: Int): ButAtMostCheckerOption<E, T, S>\n    = ButAtMostCheckerOptionImpl(times, this, containsBuilder)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `exactly` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.exactly(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.exactly\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.exactly(times: Int): ExactlyCheckerOption<E, T, S>\n    = ExactlyCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `at least` once but `at most` number of [times] within the [Iterable].\n *\n * If you want to use a higher lower bound than one, then use `atLeast(2).butAtMost(3)` instead of `atMost(3)`.\n * And in case you want to state that it is either not contained at all or at most a certain number of times,\n * then use `notOrAstMost(2)` instead.\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n * @throws IllegalArgumentException In case [times] equals to one; use [exactly] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.atMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.atMost\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.atMost(times: Int): AtMostCheckerOption<E, T, S>\n    = AtMostCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `not at all or at most` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [containsNot] instead.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.notOrAtMost(times)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notOrAtMost\"\n    )\n)\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.notOrAtMost(times: Int): NotOrAtMostCheckerOption<E, T, S>\n    = NotOrAtMostCheckerOptionImpl(times, this)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInAnyOrderCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.kbox.glue\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\n\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value shall be searched within the [Iterable].\n *\n * Delegates to `values(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <E, T : Iterable<E>> IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>.value(expected: E): AssertionPlant<T>\n    = values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value as well as the [otherExpected] values (if given) shall be searched within the [Iterable].\n *\n * Notice, that it does not search for unique matches. Meaning, if the iterable is `setOf('a', 'b')` and\n * [expected] is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match,\n * even though they match the same entry. Use an option such as [atLeast], [atMost] and [exactly] to control the\n * number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `contains.inAnyOrder.exactly(2).values('a')`\n * instead of:\n *   `contains.inAnyOrder.atLeast(1).values('a', 'a')`\n *\n * @param expected The object which is expected to be contained within the [Iterable].\n * @param otherExpected Additional objects which are expected to be contained within [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <E, T : Iterable<E>> IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>.values(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInAnyOrder(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry shall be searched which either\n * holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * Delegates to `entries(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.entry(asSubExpect(assertionCreatorOrNull))\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entry\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>.entry(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = entries(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry shall be searched which either\n * holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case\n * [assertionCreatorOrNull] is defined as `null` -- likewise an entry (can be the same) is searched for each\n * of the [otherAssertionCreatorsOrNulls].\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.entries(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it) }.toTypedArray()\\n\" +\n            \")\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entries\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>.entries(\n    assertionCreatorOrNull: (Assert<E>.() -> Unit)?,\n    vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?\n): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInAnyOrderWithAssert(this, assertionCreatorOrNull glue otherAssertionCreatorsOrNulls))\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\nprivate fun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.CheckerOption<E, T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInAnyOrderOnlyCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.kbox.glue\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderOnlySearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value.\n *\n * Delegates to `values(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>.value(expected: E): AssertionPlant<T>\n    = values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value as well as the [otherExpected] values (if given) need to be\n * contained in [Iterable] where it does not matter in which order but only as\n * many entries should be returned by the [Iterable] as values defined.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n * @param otherExpected Additional values which are expected to be contained within [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>.values(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInAnyOrderOnly(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only one\n * entry which holds all assertions created by the given [assertionCreatorOrNull] or is `null` in case\n * [assertionCreatorOrNull] is defined as `null`.\n *\n * Delegates to `entries(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.entry(asSubExpect(assertionCreatorOrNull))\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entry\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>.entry(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = entries(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry needs to be contained in the\n * [Iterable] which holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case\n * [assertionCreatorOrNull] is defined as `null` -- likewise an entry for each\n * [otherAssertionCreatorsOrNulls] needs to be contained in the [Iterable] where it does not matter in which order the\n * entries appear but only as many entries should be returned by the [Iterable] as assertion creators are defined.\n *\n * Notice, that a first-wins strategy applies which means your assertion creator lambdas -- which kind of serve as\n * identification lambdas -- should be ordered in such a way that the most specific identification lambda appears\n * first, not that a less specific lambda wins. For instance, given a `setOf(1, 2)` you should not search for\n * `entries({ isGreaterThan(0) }, { toBe(1) })` but for\n * `entries({ toBe(1) }, { isGreaterThan(0) })` otherwise\n * `isGreaterThan(0)` matches `1` before `toBe(1)` would match it. As a consequence `toBe(1)` could only match the\n * entry which is left -- in this case `2` -- and of course this would fail.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking for\n *   has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.entries(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it) }.toTypedArray()\\n\" +\n            \")\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entries\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>.entries(\n    assertionCreatorOrNull: (Assert<E>.() -> Unit)?,\n    vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?\n): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInAnyOrderOnlyWithAssert(this, assertionCreatorOrNull glue otherAssertionCreatorsOrNulls))\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\ninternal fun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.Builder<E, T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInOrderOnlyCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlySearchBehaviour\nimport ch.tutteli.kbox.glue\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value.\n *\n * Delegates to `values(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.value(expected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.value(expected: E): AssertionPlant<T>\n    = values(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value as well as the [otherExpected] values\n * (if given) in the specified order.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n * @param otherExpected Additional values which are expected to be contained within [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.values(expected, *otherExpected)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.values(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInOrderOnly(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only a\n * single entry which holds all assertions created by the given [assertionCreatorOrNull] or needs to be `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n * Delegates to `entries(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.entry(asSubExpect(assertionCreatorOrNull))\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entry\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>.entry(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = entries(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only an\n * entry which holds all assertions [assertionCreatorOrNull] might create or is `null` in case [assertionCreatorOrNull]\n * is defined as `null` and likewise a further entry for each\n * [otherAssertionCreatorsOrNulls] (if given) whereas the entries have to appear in the specified order.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking\n *   for has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.entries(\\n\" +\n            \"asSubExpect(assertionCreatorOrNull),\\n\" +\n            \"*otherAssertionCreatorsOrNulls.map { asSubExpect(it) }.toTypedArray()\\n\" +\n            \")\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asSubExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.entries\"\n    )\n)\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>.entries(\n    assertionCreatorOrNull: (Assert<E>.() -> Unit)?,\n    vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?\n): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInOrderOnlyWithAssert(this, assertionCreatorOrNull glue otherAssertionCreatorsOrNulls))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInOrderOnlyGroupedCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.utils.Group\nimport ch.tutteli.atrium.domain.builders.utils.groupsToList\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlyGroupedWithinSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [firstGroup] as well as\n * the [secondGroup] and optionally [otherExpectedGroups] of values need to be contained in [Iterable]\n * as only elements and in the specified order whereas the values within the groups can occur in any order.\n *\n * This function will be renamed on a JVM level to `inAnyOrder` with v1.0.0\n *\n * @param firstGroup A group of values which have to appear at first within the [Iterable].\n * @param secondGroup A group of values which have to appear after the values of the [firstGroup] within the [Iterable].\n * @param otherExpectedGroups Additional groups of values which are expected to appear after the [secondGroup] within\n *   [Iterable] whereas the groups have to appear in the given order.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.inAnyOrder(firstGroup, secondGroup, *otherExpectedGroups)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.inAnyOrder\"\n    )\n)\n@JvmName(\"inAnyOrderNullableValues\")\nfun <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlyGroupedWithinSearchBehaviour>.inAnyOrder(\n    firstGroup: Group<E>,\n    secondGroup: Group<E>,\n    vararg otherExpectedGroups: Group<E>\n): AssertionPlant<T> = addAssertion(\n    AssertImpl.iterable.contains.valuesInOrderOnlyGrouped(\n        this,\n        groupsToList(firstGroup, secondGroup, otherExpectedGroups)\n    )\n)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [firstGroup] as well as\n * the [secondGroup] and optionally [otherExpectedGroups] of identification lambdas, identifying an entry,\n * need to be contained in [Iterable] as only elements and in the specified order whereas\n * the identification lambdas within the groups can occur in any order.\n *\n * An identification lambda can also be defined as `null` in which case it matches an entry which is `null` as well.\n * Have a look at [entries] for more information about identification lambdas.\n *\n * This function will be renamed on a JVM level to `inAnyOrderEntries` with v1.0.0\n *\n * @param firstGroup A group of identification lambdas which have to appear at first within the [Iterable].\n * @param secondGroup A group of identification lambdas which have to appear after the values of the [firstGroup] within the [Iterable].\n * @param otherExpectedGroups Additional groups of values which are expected to appear after the [secondGroup] within\n *   [Iterable] whereas the groups have to appear in the given order.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.inAnyOrder(firstGroup /* might need further adaptions, check if overload with Group<(Expect<E>.() -> Unit)?> is chosen */, secondGroup, *otherExpectedGroups)\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.inAnyOrder\"\n    )\n)\n@JvmName(\"inAnyOrderNullableEntries\")\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlyGroupedWithinSearchBehaviour>.inAnyOrder(\n    firstGroup: Group<(Assert<E>.() -> Unit)?>,\n    secondGroup: Group<(Assert<E>.() -> Unit)?>,\n    vararg otherExpectedGroups: Group<(Assert<E>.() -> Unit)?>\n): AssertionPlant<T> = addAssertion(\n    AssertImpl.iterable.contains.entriesInOrderOnlyGroupedWithAssert(\n        this,\n        groupsToList(firstGroup, secondGroup, otherExpectedGroups)\n    )\n)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.*\nimport kotlin.jvm.JvmName\n\n/**\n * Defines that the search behaviour \"find entries `in any order` in the [Iterable]\" shall be applied to this\n * sophisticated `contains` in [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.inAnyOrder\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, NoOpSearchBehaviour>.inAnyOrder\n    get() = AssertImpl.iterable.contains.searchBehaviours.inAnyOrder(this)\n\n/**\n * Defines that the constraint \"`only` the specified entries exist in the [Iterable]\" shall be applied to this\n * sophisticated `contains` [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.only\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>.only\n    @JvmName(\"butOnly\")\n    get() = AssertImpl.iterable.contains.searchBehaviours.inAnyOrderOnly(this)\n\n\n/**\n * Defines that the search behaviour \"find entries `in order` in the [Iterable]\" shall be applied to this\n * sophisticated `contains` in [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.inOrder\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, NoOpSearchBehaviour>.inOrder\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrder(this)\n\n/**\n * Defines that the constraint \"`only` the specified entries exist in the [Iterable]\" shall be applied to this\n * sophisticated `contains in order` [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n//    ReplaceWith(\n//        \"this.inAnyOrder\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.only\"\n//    )\n//)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderSearchBehaviour>.only\n    @JvmName(\"andOnly\")\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrderOnly(this)\n\n/**\n * Defines that the [Iterable] contains `in order only` groups of entries\n * whereas the order within the group is specified as next step.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.grouped\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.grouped\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrderOnlyGrouped(this)\n\n/**\n * A filler word to emphasis that the next step defines the order within expected groups of values.\n *\n * @return The newly created builder.\n */\n@Deprecated(\n    \"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.inAnyOrder\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.within\"\n    )\n)\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>.within\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrderOnlyGroupedWithin(this)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject],\n * creates a feature assertion plant for the corresponding element and returns the newly created plant.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the given [index] is out of bound.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().get(index).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.get\"\n    )\n)\nfun <E: Any, T: List<E>> Assert<T>.get(index: Int): Assert<E>\n    = AssertImpl.list.get(this, index)\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject] and that\n * the corresponding element holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().apply { get(index).assAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.get\"\n    )\n)\nfun <E: Any, T: List<E>> Assert<T>.get(index: Int, assertionCreator: Assert<E>.() -> Unit)\n    = addAssertion(AssertImpl.list.get(this, index, assertionCreator))\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject],\n * creates a feature assertion plant for the corresponding nullable element and returns the newly created plant.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the given [index] is out of bound.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().get(index).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.get\"\n    )\n)\nfun <E, T: List<E>> Assert<T>.get(index: Int): AssertionPlantNullable<E>\n    = AssertImpl.list.getNullable(this, index)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.ListAssertions\nimport ch.tutteli.atrium.domain.creating.listAssertions\n\n/**\n * Delegates inter alia to the implementation of [ListAssertions].\n * In detail, it implements [ListAssertions] by delegating to [listAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ListAssertionsBuilder : ListAssertions {\n\n    override inline fun <E, T : List<E>> get(\n        assertionContainer: Expect<T>,\n        index: Int\n    ) = listAssertions.get(assertionContainer, index)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T : Any> get(plant: AssertionPlant<List<T>>, index: Int): AssertionPlant<T> =\n        listAssertions.get(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T : Any> get(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = listAssertions.get(plant, index, assertionCreator)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T> getNullable(plant: AssertionPlant<List<T>>, index: Int): AssertionPlantNullable<T> =\n        listAssertions.getNullable(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T> getNullable(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlantNullable<T>.() -> Unit\n    ) = listAssertions.getNullable(plant, index, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\nimport ch.tutteli.kbox.glue\nimport kotlin.js.JsName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a key as defined by [keyValuePair]'s [Pair.first]\n * with a corresponding value as defined by [keyValuePair]'s [Pair.second] -- optionally the same assertions\n * are created for the [otherPairs].\n *\n * Notice, that it does not search for unique matches. Meaning, if the map is `mapOf('a' to 1)` and [keyValuePair] is\n * defined as `'a' to 1` and one of the [otherPairs] is defined as `'a' to 1` as well, then both match,\n * even though they match the same entry.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().contains(keyValuePair, *otherPairs).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <K, V, T: Map<out K, V>> Assert<T>.contains(keyValuePair: Pair<K, V>, vararg otherPairs: Pair<K, V>)\n    = addAssertion(AssertImpl.map.contains(this, keyValuePair glue otherPairs))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a key as defined by [keyValue]'s [KeyValue.key]\n * with a corresponding value which either holds all assertions [keyValue]'s\n * [KeyValue.valueAssertionCreatorOrNull] might create or needs to be `null` in case\n * [KeyValue.valueAssertionCreatorOrNull] is defined as `null`\n * -- optionally the same assertions are created for the [otherKeyValues].\n *\n * Notice, that it does not search for unique matches. Meaning, if the map is `mapOf('a' to 1)` and [keyValue] is\n * defined as `Key('a') { isGreaterThan(0) }` and one of the [otherKeyValues] is defined as `Key('a') { isLessThan(2) }`\n * , then both match, even though they match the same entry.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().contains(keyValue, *otherKeyValues).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.contains\"\n    )\n)\nfun <K, V : Any, T: Map<out K, V?>> Assert<T>.contains(\n    keyValue: KeyValue<K, V>,\n    vararg otherKeyValues: KeyValue<K, V>\n) = addAssertion(AssertImpl.map.containsKeyWithValueAssertions(this, (keyValue glue otherKeyValues).map { it.toPair() }))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsKey(key).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsKey\"\n    )\n)\nfun <K> Assert<Map<out K, *>>.containsKey(key: K)\n    = addAssertion(AssertImpl.map.containsKey(this, key))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the given [key].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().containsNotKey(key).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.containsNotKey\"\n    )\n)\nfun <K> Assert<Map<out K, *>>.containsNotKey(key: K)\n    = addAssertion(AssertImpl.map.containsNotKey(this, key))\n\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key], creates a feature\n * assertion plant for the corresponding value and returns the newly created plant.\n *\n * @return The newly created plant for the feature\n * @throws AssertionError Might throw an [AssertionError] if the given [key] does not exist.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().getExisting(key).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.getExisting\"\n    )\n)\n@JsName(\"getExisting\")\nfun <K, V: Any, T: Map<out K, V>> Assert<T>.getExisting(key: K): Assert<V>\n    = AssertImpl.map.getExisting(this, key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key] and that\n * the corresponding value holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().apply { getExisting(key).asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.getExisting\"\n    )\n)\nfun <K, V: Any, T: Map<out K, V>> Assert<T>.getExisting(key: K, assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.map.getExisting(this, key, assertionCreator))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key], creates a feature\n * assertion plant for the corresponding nullable value and returns the newly created plant.\n *\n * @return The newly created plant for the feature\n * @throws AssertionError Might throw an [AssertionError] if the given [key] does not exist.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().getExisting(key).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.getExisting\"\n    )\n)\nfun <K, V: Any, T: Map<out K, V?>> Assert<T>.getExisting(key: K): AssertionPlantNullable<V?>\n    = AssertImpl.map.getExistingNullable(this, key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Map.size] is [size].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().hasSize(size).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.hasSize\"\n    )\n)\nfun <T : Map<*, *>> Assert<T>.hasSize(size: Int)\n    = addAssertion(AssertImpl.map.hasSize(this, size))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is an empty [Map].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isEmpty\"\n    )\n)\nfun <T : Map<*, *>> Assert<T>.isEmpty()\n    = addAssertion(AssertImpl.map.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not an empty [Map].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isNotEmpty().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isNotEmpty\"\n    )\n)\nfun <T : Map<*, *>> Assert<T>.isNotEmpty()\n    = addAssertion(AssertImpl.map.isNotEmpty(this))\n\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [keys][Map.keys] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().keys\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.keys\"\n    )\n)\nval <K> Assert<Map<K, *>>.keys get() : Assert<Set<K>> = property(Map<K, *>::keys)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [keys][Map.keys] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().apply { keys.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.keys\"\n    )\n)\nfun <K, V, T: Map<K, V>> Assert<T>.keys(assertionCreator: Assert<Set<K>>.() -> Unit)\n    = addAssertion(AssertImpl.map.keys(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [values][Map.values] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().values\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nval <V> Assert<Map<*, V>>.values get() : Assert<Collection<V>> = property(Map<*, V>::values)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [values][Map.values] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().apply { values.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.values\"\n    )\n)\nfun <K, V, T: Map<K, V>> Assert<T>.values(assertionCreator: Assert<Collection<V>>.() -> Unit)\n    = addAssertion(AssertImpl.map.values(this, assertionCreator))\n\n/**\n * Turns `Assert<Map<K, V>>` into `Assert<Set<Map.Entry<K, V>>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `property(subject::entries)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asEntries().asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asEntries\"\n    )\n)\nfun <K, V> Assert<Map<out K, V>>.asEntries(): Assert<Set<Map.Entry<K, V>>>\n    = ExpectImpl.changeSubject(this).unreported { it.entries }\n\n/**\n * Turns `Assert<Map<K, V>>` into `Assert<Set<Map.Entry<K, V>>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `property(subject::entries)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().apply { asEntries().asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asEntries\"\n    )\n)\nfun <K, V> Assert<Map<out K, V>>.asEntries(assertionCreator: Assert<Set<Map.Entry<K, V>>>.() -> Unit): Assert<Set<Map.Entry<K, V>>>\n    = asEntries().addAssertionsCreatedBy(assertionCreator)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.MapAssertions\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.mapAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapAssertions].\n * In detail, it implements [MapAssertions] by delegating to [mapAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject MapAssertionsBuilder : MapAssertions {\n\n    /**\n     * Returns [MapEntryAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapEntryAssertions].\n     */\n    inline val entry get() : MapEntryAssertionsBuilder = MapEntryAssertionsBuilder\n\n    override inline fun <K, V : Any, T : Map<out K, V?>> contains(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValuePairs: List<Pair<K, V?>>\n    ) = mapAssertions.contains(assertionContainer, valueType, keyValuePairs)\n\n    override inline fun <K, V : Any, T : Map<out K, V?>> containsKeyWithValueAssertions(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValues: List<Pair<K, (Expect<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(assertionContainer, valueType, keyValues)\n\n\n    override inline fun <K> containsKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsKey(subjectProvider, key)\n\n    override inline fun <K> containsNotKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsNotKey(subjectProvider, key)\n\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isEmpty(subjectProvider)\n\n    override inline fun <K, V, T : Map<out K, V>> getExisting(\n        assertionContainer: Expect<T>,\n        key: K\n    ): ExtractedFeaturePostStep<T, V> = mapAssertions.getExisting(assertionContainer, key)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Map<*, *>> size(assertionContainer: Expect<T>) = mapAssertions.size(assertionContainer)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> contains(\n        plant: AssertionPlant<Map<out K, V>>,\n        keyValuePairs: List<Pair<K, V>>\n    ) = mapAssertions.contains(plant, keyValuePairs)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> containsKeyWithValueAssertions(\n        plant: AssertionPlant<Map<out K, V?>>,\n        keyValues: List<Pair<K, (Assert<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(plant, keyValues)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExisting(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ) = mapAssertions.getExisting(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExistingNullable(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ) = mapAssertions.getExistingNullable(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Map<*, *>>, size: Int) = mapAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> keys(\n        plant: AssertionPlant<Map<out K, *>>,\n        noinline assertionCreator: AssertionPlant<Set<K>>.() -> Unit\n    ): Assertion = mapAssertions.keys(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> values(\n        plant: AssertionPlant<Map<*, V>>,\n        noinline assertionCreator: AssertionPlant<Collection<V>>.() -> Unit\n    ): Assertion = mapAssertions.values(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Map.Entry.key] is (equal to) the given [key] and\n * [Map.Entry.value] is [value].\n *\n * Kind of a shortcut for `key { toBe(key) }.and.value { toBe(value) }` but should be evaluated in\n * an assertion group block -- which has the effect that the assertion about the value is still evaluated even\n * if the assertion about the key fails. Moreover, it might be that reporting differs compared to using the long form.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isKeyValue(key, value).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isKeyValue\"\n    )\n)\nfun <K : Any, V : Any> Assert<Map.Entry<K, V>>.isKeyValue(key: K, value: V): Assert<Map.Entry<K, V>>\n    = addAssertion(AssertImpl.map.entry.isKeyValue(this, key, value))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().key\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.key\"\n    )\n)\nval <K : Any> Assert<Map.Entry<K, *>>.key get() : Assert<K> = property(Map.Entry<K, *>::key)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] (which could be `null`)\n * so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n//    ReplaceWith(\n//        \"this.asExpect().key\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.key\"\n//    )\n//)\nval <K> Assert<Map.Entry<K, *>>.key get() : AssertionPlantNullable<K> = property(Map.Entry<K, *>::key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().apply { key.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.key\"\n    )\n)\nfun <K : Any, V> Assert<Map.Entry<K, V>>.key(assertionCreator: Assert<K>.() -> Unit)\n    = addAssertion(AssertImpl.map.entry.key(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().value\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nval <V : Any> Assert<Map.Entry<*, V>>.value get() : Assert<V> = property(Map.Entry<*, V>::value)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value]\n * (which could be `null`) so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n//    ReplaceWith(\n//        \"this.asExpect().value\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n//    )\n//)\nval <V> Assert<Map.Entry<*, V>>.value get() : AssertionPlantNullable<V> = property(Map.Entry<*, V>::value)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().apply { value.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.value\"\n    )\n)\nfun <K, V: Any> Assert<Map.Entry<K, V>>.value(assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.map.entry.value(this, assertionCreator))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.mapEntryAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapEntryAssertions].\n * In detail, it implements [MapEntryAssertions] by delegating to [mapEntryAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject MapEntryAssertionsBuilder : MapEntryAssertions {\n    override inline fun <K : Any, V : Any, T : Map.Entry<K, V>> isKeyValue(\n        assertionContainer: Expect<T>,\n        key: K,\n        value: V\n    ) = mapEntryAssertions.isKeyValue(assertionContainer, key, value)\n\n    override inline fun <K : Any, V : Any, T : Map.Entry<K?, V?>> isKeyValue(\n        assertionContainer: Expect<T>,\n        key: K?,\n        value: V?,\n        keyType: KClass<K>,\n        valueType: KClass<V>\n    ) = mapEntryAssertions.isKeyValue(assertionContainer, key, value, keyType, valueType)\n\n    override inline fun <K, T : Map.Entry<K, *>> key(assertionContainer: Expect<T>) =\n        mapEntryAssertions.key(assertionContainer)\n\n    override inline fun <V, T : Map.Entry<*, V>> value(assertionContainer: Expect<T>) =\n        mapEntryAssertions.value(assertionContainer)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any, V : Any> isKeyValue(\n        plant: AssertionPlant<Map.Entry<K, V>>,\n        key: K,\n        value: V\n    ): Assertion = mapEntryAssertions.isKeyValue(plant, key, value)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> key(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.key(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> value(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.value(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableKey(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableKey(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableValue(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableValue(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().first\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.first\"\n    )\n)\nval <K : Any> Assert<Pair<K, *>>.first get() : Assert<K> = property(Pair<K, *>::first)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] (which could be `null`)\n * so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n//    ReplaceWith(\n//        \"this.asExpect().first\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.first\"\n//    )\n//)\nval <K> Assert<Pair<K, *>>.first get() : AssertionPlantNullable<K> = property(Pair<K, *>::first)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().apply { first.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.first\"\n    )\n)\nfun <K : Any, V> Assert<Pair<K, V>>.first(assertionCreator: Assert<K>.() -> Unit)\n    = addAssertion(AssertImpl.pair.first(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().second\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.second\"\n    )\n)\nval <V : Any> Assert<Pair<*, V>>.second get() : Assert<V> = property(Pair<*, V>::second)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second]\n * (which could be `null`) so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\n//    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n//    ReplaceWith(\n//        \"this.asExpect().second\",\n//        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n//        \"ch.tutteli.atrium.api.fluent.en_GB.second\"\n//    )\n//)\nval <V> Assert<Pair<*, V>>.second get() : AssertionPlantNullable<V> = property(Pair<*, V>::second)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().apply { second.asAssert(assertionCreator) }.asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.second\"\n    )\n)\nfun <K, V: Any> Assert<Pair<K, V>>.second(assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.pair.second(this, assertionCreator))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.PairAssertions\nimport ch.tutteli.atrium.domain.creating.pairAssertions\n\n/**\n * Delegates inter alia to the implementation of [PairAssertions].\n * In detail, it implements [PairAssertions] by delegating to [pairAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject PairAssertionsBuilder : PairAssertions {\n\n    override inline fun <K, T : Pair<K, *>> first(assertionContainer: Expect<T>) =\n        pairAssertions.first(assertionContainer)\n\n    override inline fun <V, T : Pair<*, V>> second(assertionContainer: Expect<T>) =\n        pairAssertions.second(assertionContainer)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> first(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = pairAssertions.first(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> second(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = pairAssertions.second(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableFirst(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = pairAssertions.nullableFirst(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableSecond(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = pairAssertions.nullableSecond(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.utils.Group\nimport ch.tutteli.atrium.domain.builders.utils.GroupWithNullableEntries\nimport ch.tutteli.atrium.domain.builders.utils.GroupWithoutNullableEntries\nimport ch.tutteli.atrium.domain.builders.utils.VarArgHelper\nimport ch.tutteli.kbox.glue\n\n/**\n * Parameter object to express a [Group] with a single identification lambda.\n *\nIn case `null` is used for the identification lambda then it is expected that the corresponding entry\n * is `null` as well.\n *\n * @param assertionCreatorOrNull The identification lambda identifying the entry where an entry is considered\n *   to be identified if it holds all [Assertion]s the lambda might create.\n *   In case it is defined as `null`, then an entry is identified if it is `null` as well.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\")\nclass Entry<in T: Any>(\n    val assertionCreatorOrNull: (Assert<T>.() -> Unit)?\n): GroupWithoutNullableEntries<(Assert<T>.() -> Unit)?>, GroupWithNullableEntries<(Assert<T>.() -> Unit)?> {\n    override fun toList(): List<(Assert<T>.() -> Unit)?> = listOf(assertionCreatorOrNull)\n}\n\n/**\n * Parameter object to express a [Group] of identification lambdas.\n *\n * In case `null` is used for an identification lambda then it is expected that the corresponding entry\n * is `null` as well.\n *\n * @param assertionCreatorOrNull The identification lambda identifying the entry where an entry is considered\n *   to be identified if it holds all [Assertion]s the lambda might create.\n *   In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls A variable amount of additional identification lambdas or `null`s.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\")\nclass Entries<in T : Any>(\n    val assertionCreatorOrNull: (Assert<T>.() -> Unit)?,\n    vararg val otherAssertionCreatorsOrNulls: (Assert<T>.() -> Unit)?\n) : GroupWithoutNullableEntries<(Assert<T>.() -> Unit)?>, GroupWithNullableEntries<(Assert<T>.() -> Unit)?>, VarArgHelper<(Assert<T>.() -> Unit)?> {\n    override val expected get() = assertionCreatorOrNull\n    override val otherExpected get() = otherAssertionCreatorsOrNulls\n\n    override fun toList(): List<(Assert<T>.() -> Unit)?> = assertionCreatorOrNull glue otherAssertionCreatorsOrNulls\n}\n\n\n/**\n * Parameter object to express a key/value [Pair] whose value type is a nullable lambda with an\n * [Assert][AssertionPlant] receiver, which means one can either pass a lambda or `null`.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\")\ndata class KeyValue<out K, V : Any>(val key: K, val valueAssertionCreatorOrNull: (Assert<V>.() -> Unit)?) {\n    fun toPair(): Pair<K, (Assert<V>.() -> Unit)?> = key to valueAssertionCreatorOrNull\n    override fun toString(): String\n        = \"KeyValue(key=$key, value=${if (valueAssertionCreatorOrNull == null) \"null\" else \"lambda\"})\"\n}\n\n/**\n * Represents a [Group] with a single value.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\")\ndata class Value<out T>(val expected: T) : GroupWithNullableEntries<T>, GroupWithoutNullableEntries<T> {\n    override fun toList() = listOf(expected)\n}\n\n/**\n * Represents a [Group] of multiple values.\n */\n@Deprecated(\"Switch from api-cc-en_GB to api-fluent-en_GB; will be removed with 1.0.0\")\nclass Values<out T>(\n    override val expected: T,\n    override vararg val otherExpected: T\n) : GroupWithoutNullableEntries<T>, GroupWithNullableEntries<T>, VarArgHelper<T>  {\n    override fun toList() = listOf(expected, *otherExpected)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\n\n/**\n * Turns `Assert<Sequence<E>>` into `Assert<Iterable<E>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Sequence::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().asIterable()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.asIterable\"\n    )\n)\nfun <E> Assert<Sequence<E>>.asIterable(): Assert<Iterable<E>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\n\n/**\n *  Makes the assertion that the thrown [Throwable] is of type [TExpected] and holds all assertions the\n * [assertionCreator] might create in addition.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion (a [Throwable] was thrown) holds or not.\n * Define subsequent assertions via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.toThrow<TExpected>().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.toThrow\"\n    )\n)\ninline fun <reified TExpected : Throwable> ThrowableThrown.Builder.toThrow(noinline assertionCreator: Assert<TExpected>.() -> Unit) {\n        AssertImpl.throwable.thrown.toBe(this, TExpected::class, assertionCreator)\n}\n\n/**\n * Makes the assertion that no [Throwable] is thrown at all.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because we assume nothing happens,\n *   so there is nothing we could make assertions on in addition.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.notToThrow()\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notToThrow\"\n    )\n)\nfun ThrowableThrown.Builder.notToThrow(){\n        AssertImpl.throwable.thrown.nothingThrown(this)\n}\n\n/**\n * Creates an [AssertionPlantNullable] for the [message][Throwable.message] of the plant's\n * [subject][SubjectProvider.subject] (which is a [Throwable]) and makes the assertion that message [notToBeNull]\n * and uses [assertionCreator] which might create further [Assertion]s which are lazily evaluated at the end.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion [message][Throwable.message] is not null) holds or not.\n * Define subsequent assertions via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] in case [message][Throwable.message] is `null`\n *   or if an additionally created [Assertion]s (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().message.asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.message\"\n    )\n)\nfun <T : Throwable> Assert<T>.message(assertionCreator: Assert<String>.() -> Unit) {\n    property(Throwable::message).notToBeNull(assertionCreator)\n}\n\n/**\n * Creates the assertion that the [Throwable]'s [message][Throwable.message] is not null (see [message]) contains\n * [expected]'s [toString] representation and the [toString] representation of the [otherExpected] (if given),\n * using a non disjoint search.\n *\n * It is a shortcut for `message { contains.atLeast(1).values(expected, otherExpected) }`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed\n * (this function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion [message][Throwable.message] is not null) holds or not.\n *\n * @throws AssertionError Might throw an [AssertionError] in case [message][Throwable.message] is `null`\n *   or does not contain [expected] or [otherExpected].\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().messageContains(expected, *otherExpected).asAssert()\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.messageContains\"\n    )\n)\nfun <T : Throwable> Assert<T>.messageContains(expected: Any, vararg otherExpected: Any) {\n    message { contains(expected, *otherExpected) }\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"TypeTransformationAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.en_GB\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that [AssertionPlantNullable.subject][SubjectProvider.subject] is not null and if so, uses [assertionCreator]\n * which could create further assertions which are added as a group.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion ([Assert.subject][SubjectProvider.subject] is not null) holds or not. Define subsequent assertions\n *   via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().notToBeNull().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.notToBeNull\"\n    )\n)\ninline fun <reified T : Any> AssertionPlantNullable<T?>.notToBeNull(noinline assertionCreator: Assert<T>.() -> Unit) {\n    addAssertion(AssertImpl.any.isNotNull(this, T::class, assertionCreator))\n}\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] *is a* [TSub] (the same type or a sub-type) and if so,\n * uses [assertionCreator] which could create further assertions which are added as a group.\n *\n * Notice, that asserting a function type is [flawed](https://youtrack.jetbrains.com/issue/KT-27846).\n * The actual types are ignored as function types erase to Function0,\n * Function1 etc. on byte code level, which means the assertion holds as long as the [Assert.subject][SubjectProvider.subject] is a\n * function and has the same amount of arguments regardless if the types differ. For instance\n * `assert({x: Int -> \"hello\"}).isA<String -> Unit>{}` holds, even though `(Int) -> String` is clearly not\n * a `(String) -> Unit`.\n *\n * More generally speaking, the [flaw](https://youtrack.jetbrains.com/issue/KT-27826) applies to all generic types.\n * For instance `isA<List<String>>` would only check if the [Assert.subject][SubjectProvider.subject] is a `List` without checking if\n * the element type is actually `String`. Or in other words\n * `assert(listOf(1, 2)).isA<List<String>>{}` holds, even though `List<Int>` is clearly not a `List<String>`.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion ([Assert.subject][SubjectProvider.subject] *is a* [TSub]) holds or not. Define subsequent assertions\n *   via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\n    \"Switch from Assert to Expect; will be removed with 1.0.0\",\n    ReplaceWith(\n        \"this.asExpect().isA<TSub>().asAssert(assertionCreator)\",\n        \"ch.tutteli.atrium.domain.builders.migration.asExpect\",\n        \"ch.tutteli.atrium.domain.builders.migration.asAssert\",\n        \"ch.tutteli.atrium.api.fluent.en_GB.isA\"\n    )\n)\ninline fun <reified TSub : Any> Assert<Any>.isA(noinline assertionCreator: AssertionPlant<TSub>.() -> Unit) {\n        AssertImpl.any.typeTransformation.isA(this, TSub::class, assertionCreator)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;iBAmC4B,4E;mBCXxB,gH;;;;;;;;;;8BCgBA,2G;;qBCvBJ,oD;iBCwDI,+I;gCCgtCJ,yD;uBAAA,gD;mBC/wCA,qC;yBFiHI,uJ;;;;;;;;;;;;;;;;;;;;;;4BG/FA,mI;mBC2CA,2I;;;2BAsFA,mJ;;;;;;;;;;mBC/FA,0I;;;;;;;;;;;;;;;;;;;;;;;;;EC9CJ,mC;IVmBoC,6B;IUDQ,sCTTpC,wBAAc,cSSuD,STTvD,ESS6D,QTT7D,CSSsB,C;G;EAE5C,sC;IVDoC,6B;IUmBW,sCT1BvC,wBAAc,iBS0B6D,ST1B7D,ES0BmE,QT1BnE,CS0ByB,C;G;EAE/C,uC;IVrBoC,6B;IUuCY,sCT3CxC,wBAAc,gBS2C6D,ST3C7D,ES2CmE,QT3CnE,CS2C0B,C;G;EAEhD,0C;IVzCoC,6B;IU2De,sCT5D3C,wBAAc,mBS4DmE,ST5DnE,ES4DyE,QT5DzE,CS4D6B,C;G;0GAEnD,yB;IAAA,gC;IV7D4B,6G;ICsBxB,mJ;ISuCJ,gD;MV7DoC,6B;MU8EJ,yB;MAA5B,+BTrDI,wBAAc,oBSqDqB,STrDrB,EAAkB,IAAlB,ESqDqC,QTrDrC,CSqDlB,C;IACJ,C;GAlBA,C;8IAoBA,yB;IAAA,gC;IVjF4B,6G;ICyCxB,mJ;ISwCJ,8D;MVjFoC,6B;MU0GJ,yB;MAA5B,+BT3DI,wBAAc,+BS2DgC,ST3DhC,EAA6B,IAA7B,ES2DgD,sBT3DhD,CS2DlB,C;IACJ,C;GA1BA,C;EAsCuD,4B;IAAQ,gB;G;EAE/D,0C;IAoBI,gDAAuB,gBAAvB,C;G;ECtJ0C,+B;IAAE,OAAG,WAAH,EAAG,C;EAAa,C;EAlBhE,iC;IAkBI,OTiBI,+BAAsB,gBSjBD,STiBC,CSjBK,oBAAW,iBAAX,C;G;EAEnC,oD;IAmBI,OAAA,uBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OT1BI,+BAAsB,gBS0BD,ST1BC,CS0BK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OTtEI,+BAAsB,gBSsED,STtEC,CSsEK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OTlHI,+BAAsB,gBSkHD,STlHC,CSkHK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAqBoF,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAlBvH,kC;IAkB2D,OT7JnD,+BAAsB,gBS6JsD,ST7JtD,CS6J4D,oBAAW,mBAAX,C;G;EAE1F,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OTzMI,+BAAsB,gBSyMD,STzMC,CSyMK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OTrPI,+BAAsB,gBSqPD,STrPC,CSqPK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OTjSI,+BAAsB,gBSiSD,STjSC,CSiSK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAsB6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAnBhE,kC;IAmBI,OT7UI,+BAAsB,gBS6UD,ST7UC,CS6UK,oBAAW,mBAAX,C;G;EAEnC,oD;IAoBI,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EClXb,iC;IZSyC,sC;IYTjC,ORDJ,iCAAuB,yBQCqB,SRDrB,C;G;EQkB3B,oC;IZRyC,sC;IYQjC,gCRfJ,iCAAuB,4BQe6C,SRf7C,CQenB,C;G;EAEZ,sD;IAoCI,OAAoB,OAAX,QAAT,uBAAS,EAAQ,CAAR,CAAW,EAAO,QAAP,EAAkB,aAAlB,S;G;EAExB,yD;IAsBI,OAAY,OAAZ,0BAAY,EAAO,QAAP,EAAkB,aAAlB,S;G;EAGhB,0D;IAiCI,OAAoB,MAAX,QAAT,uBAAS,EAAQ,CAAR,CAAW,EAAM,OAAN,EAAgB,aAAhB,S;G;EAExB,yC;IZ5G6C,sC;IY4HzC,sCRhII,iCAAuB,oBQgIqB,SRhIrB,EQgI2B,QRhI3B,CQgI3B,C;G;EAEJ,4C;IZ9H6C,sC;IY8IzC,sCR/II,iCAAuB,uBQ+IwB,SR/IxB,EQ+I8B,QR/I9B,CQ+I3B,C;G;EAGJ,uC;IZjJ6C,sC;IYiKzC,sCR/JI,iCAAuB,kBQ+JmB,SR/JnB,EQ+JyB,QR/JzB,CQ+J3B,C;G;EAEJ,0C;IZnK6C,sC;IYmLzC,sCR9KI,iCAAuB,qBQ8KsB,SR9KtB,EQ8K4B,QR9K5B,CQ8K3B,C;G;EAGJ,4B;IZtL6C,sC;IYqMA,sCR7LrC,iCAAuB,iBQ6L2D,SR7L3D,CQ6Lc,C;G;EAE7C,+B;IZvM6C,sC;IYsNG,sCR3MxC,iCAAuB,oBQ2MiE,SR3MjE,CQ2MiB,C;G;EAEhD,+B;IZxN6C,sC;IYuOG,sCRzNxC,iCAAuB,oBQyNiE,SRzNjE,CQyNiB,C;G;ECnQhD,mC;IAmBI,oCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEJ,qC;IAuBI,sCAA2B,KAA3B,EAAkC,SAAlC,EAAwC,yBAAxC,C;G;EAEJ,mC;IAmBI,oCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEJ,kC;IAwBI,mCAAwB,KAAxB,EAA+B,SAA/B,C;G;EAEJ,uC;IAmBI,wCAA6B,KAA7B,EAAoC,SAApC,C;G;ET5BA,yDAIsC,yB;IEvF1C,sD;WFuF0C,c;MAAE,OEnFA,WFmFA,EEnFA,C;K;GFmFF,C;EUnF1C,oC;IA0BI,yBAAO,QAAP,K;G;EAEJ,oD;IdL6C,sC;II0Bb,8C;IUgBqC,iBX1DL,aW0DkB,QX1DlB,EW0DgC,aX1DhC,C;IW0DzC,+BVHf,uCAA+B,gBUGqC,SVHrC,EAAsB,UAAtB,CUGhB,C;G;EAGvB,sC;IA0BI,2BAAO,QAAP,K;G;EAEJ,sD;IdzE6C,sC;II0Bb,8C;IUqFkB,iBX/Hc,aW+HW,QX/HX,EW+HyB,aX/HzB,C;IW+H5D,+BVnEI,uCAA+B,4BUmE8B,SVnE9B,EAAkC,UAAlC,CUmEnC,C;G;EAGJ,sC;IAyBI,OAAW,QAAX,mBAAQ,CAAR,CAAW,EAAM,QAAN,C;G;EAEf,sD;IAiCuB,OAAW,SAAX,mBAAQ,CAAR,CAAW,EAAO,QAAP,EAAkB,aAAlB,S;G;EAElC,kD;IdhL6C,sC;II0Bb,8C;IUqLqC,eX/NL,aW+NiB,OX/NjB,EW+N8B,aX/N9B,C;IE2wCrD,kBAAM,eAAa,wBD/rCD,QC+rCC,EAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,ODpwCY,QCowCZ,W;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WCx1CwB,WDw1CV,ICx1CU,CDw1CxB,C;;ISlnCG,+BV9If,uCAA+B,eU8IoC,SV9IpC,ECiwC5B,WDjwC4B,CU8IhB,C;G;EAEvB,oD;IdjN6C,sC;II0Bb,8C;IUwNkB,eXlQc,aWkQU,OXlQV,EWkQuB,aXlQvB,C;IWkQ5D,+BV5KI,uCAA+B,2BU4K6B,SV5K7B,EAAiC,QAAjC,CU4KnC,C;G;EAEJ,oD;IAkCuB,OAAW,QAAX,mBAAQ,CAAR,CAAW,EAAM,OAAN,EAAgB,aAAhB,S;G;EAElC,4C;IAQuB,wCAAsB,SAAtB,C;G;EC7SnB,qC;IfayC,sC;II0Bb,8C;IAkDQ,0D;IWxFlC,OXqGE,uCAAuB,sBWrGsC,SXqGtC,C;G;EWtF3B,uC;IACE,gCAAqC,iBAAhB,yBAAgB,CAArC,C;G;EChCN,kC;IhB8B2C,oC;IgBZrC,sCCME,+BAAqB,iBDNoB,SCMpB,EDN0B,ICM1B,CDNvB,C;G;EAEN,8B;IhBU2C,oC;IgBMrC,sCCzBE,+BAAqB,iBDyBoB,SCzBpB,CDyBvB,C;G;EAEN,iC;IhBR2C,oC;IgBwBrC,sCCxCE,+BAAqB,oBDwCuB,SCxCvB,CDwCvB,C;G;EAmByB,6B;IAAqB,+DAAS,qB;aAAe,c;KAAxB,E;G;EAEpD,2C;IhB7C2C,oC;IgBgErC,sCCjEE,+BAAqB,cDiEiB,SCjEjB,EDiEuB,gBCjEvB,CDiEvB,C;G;EEhGN,yC;IlBkC2C,oC;IkBlBrC,sCCJE,+BAAqB,mBDIuB,SCJvB,EDI6B,QCJ7B,CDIvB,C;G;EAEN,6C;IlBgB2C,oC;IkBArC,sCCjBE,+BAAqB,uBDiB2B,SCjB3B,EDiBiC,QCjBjC,CDiBvB,C;G;EAEN,4C;IlBF2C,oC;IkBkBrC,sCC9BE,+BAAqB,sBD8B0B,SC9B1B,ED8BgC,QC9BhC,CD8BvB,C;G;EAEN,gD;IlBpB2C,oC;IkBoCrC,sCC3CE,+BAAqB,0BD2C8B,SC3C9B,ED2CoC,QC3CpC,CD2CvB,C;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EExDqG,0D;IAGvG,oCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,qDAJA,C;G;EAIA,uE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECL4D,yD;IAGtG,mCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,oDAJA,EAKA,sDALA,EAMA,sDANA,C;G;EAIA,sE;IAAA,qB;MAAE,OAA2B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA3B,SAAkC,EAAlC,M;IAAuC,C;G;EACzC,wE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,wE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECP+D,4E;IAIzG,sCACA,KADA,EAEA,cAFA,EAGA,eAHA,EAIA,0BAJA,EAKA,uEALA,EAMA,yDANA,EAOA,yDAPA,EAQA,wDARA,EASA,yDATA,C;G;EAKA,iG;IAAA,uB;MAAU,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,CAAnC,UAAkE,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAAlE,SAAyE,CAAzE,M;IAA6E,C;G;EACvF,2E;IAAA,qB;MAAE,OAA2B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA3B,SAAkC,EAAlC,M;IAAuC,C;G;EACzC,2E;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,0E;IAAA,qB;MAAE,OAA6B,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;EAC3C,2E;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECjB6D,0D;IAGvG,oCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,qDAJA,C;G;EAIA,uE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECVyD,+C;IAEnG,gCAA2B,eAA3B,C;G;;;;;;ECC2G,8D;IAG3G,wCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,yDAJA,C;G;EAIA,2E;IAAA,qB;MAAE,OAAgC,8BAA7B,4B;;OAA6B,YAA7B,uBAA6B,eAAhC,SAAuC,EAAvC,M;IAA4C,C;G;;;;;;ECrBlD,oC;IACI,sCAAqG,8C;;KAArG,C;IACA,OAAO,CAAE,a;EACb,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECWsG,4D;IAGlG,sCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,uDAJA,C;G;EAIA,yE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECLuD,2D;IAGjG,qCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,sDAJA,EAKA,sDALA,EAMA,sDANA,C;G;EAIA,wE;IAAA,qB;MAAE,OAA2B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA3B,SAAkC,EAAlC,M;IAAuC,C;G;EACzC,wE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,wE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECP0D,8E;IAIpG,wCACA,KADA,EAEA,cAFA,EAGA,eAHA,EAIA,4BAJA,EAKA,yEALA,EAMA,yDANA,EAOA,yDAPA,EAQA,wDARA,EASA,yDATA,C;G;EAKA,mG;IAAA,uB;MAAU,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,CAAnC,UAAkE,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAAlE,SAAyE,CAAzE,M;IAA6E,C;G;EACvF,2E;IAAA,qB;MAAE,OAA2B,yBAAxB,4B;;OAAwB,YAAxB,uBAAwB,eAA3B,SAAkC,EAAlC,M;IAAuC,C;G;EACzC,2E;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;EAC1C,0E;IAAA,qB;MAAE,OAA6B,4BAA1B,4B;;OAA0B,YAA1B,sBAA0B,eAA7B,SAAoC,EAApC,M;IAAyC,C;G;EAC3C,2E;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECjBwD,4D;IAGlG,sCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,uDAJA,C;G;EAIA,yE;IAAA,qB;MAAE,OAA4B,0BAAzB,4B;;OAAyB,YAAzB,uBAAyB,eAA5B,SAAmC,EAAnC,M;IAAwC,C;G;;;;;;ECToD,iD;IAE9F,kCAA8B,eAA9B,C;G;;;;;;ECAsG,gE;IAGtG,0CACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,2DAJA,C;G;EAIA,6E;IAAA,qB;MAAE,OAAgC,8BAA7B,4B;;OAA6B,YAA7B,uBAA6B,eAAhC,SAAuC,EAAvC,M;IAA4C,C;G;;;;;;ECrBlD,sC;IACI,sCACI,8C;;KADJ,C;IAEA,OAAO,CAAE,a;EACb,C;E1Be0B,mF;IAAA,mB;MAAE,OAAyB,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAapC,qF;IAAA,mB;MAAE,OAAyB,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAc9C,qF;IAAA,mB;MAAE,OAA0B,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAiBrB,uF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAc3B,yF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAe3C,yF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAiBX,uF;IAAA,qB;MAAO,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAchC,yF;IAAA,qB;MAAO,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAerC,yF;IAAA,qB;MAAO,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAiB3B,uF;IAAA,yB;MAAW,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAcpC,yF;IAAA,yB;MAAW,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAepC,yF;IAAA,yB;MAAW,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAiBpC,uF;IAAA,6B;MAAe,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAcxC,yF;IAAA,6B;MAAe,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAepC,yF;IAAA,6B;MAAe,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAiB5C,uF;IAAA,iC;MAAmB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAc5C,yF;IAAA,iC;MAAmB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAepC,yF;IAAA,iC;MAAmB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAiBpD,uF;IAAA,qC;MAAuB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;EAchD,yF;IAAA,qC;MAAuB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;EAerC,yF;IAAA,qC;MAAuB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;E2B1T3F,uC;IlC6BwC,iC;IkCblC,O3BCI,4BAAkB,kB2BDM,S3BCN,E2BDY,Q3BCZ,EAHQ,wB2BEI,Q3BFoB,aAAxB,CAGR,C;G;E2BC5B,yC;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yC;IlCMwC,iC;IkCUlC,O3BtBI,4BAAkB,kB2BsBM,S3BtBN,EANF,yC2B4Bc,Q3B5Bd,E2B4BQ,S3B5BR,CAME,EAN2D,wB2B4B/C,Q3B5BuE,aAAxB,CAM3D,C;G;E2ByB5B,2D;IlCbwC,iC;IkCiClC,O3B7CI,4BAAkB,kB2B6CM,S3B7CN,E2B6CY,Q3B7CZ,EAUS,wB2BmCG,Q3BnCqB,aAAxB,CAVT,CAaqB,gC2BgCC,gB3BhCD,C;G;E2BkCjD,2D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2D;IlCxCwC,iC;IkC4DlC,O3BxEI,4BAAkB,kB2BwEM,S3BxEN,EAOF,2C2BiEc,Q3BjEd,E2BiEQ,S3BjER,CAPE,EAO4D,wB2BiEhD,Q3BjEwE,aAAxB,CAP5D,CAaqB,gC2B2DC,gB3B3DD,C;G;E2B8DjD,yC;IlC/DwC,iC;IkC+ElC,O3B9DI,4BAAkB,kB2B8DM,S3B9DN,E2B8DY,Q3B9DZ,EAHQ,wB2BiEI,Q3BjEoB,aAAxB,CAGR,C;G;E2BgE5B,yC;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yC;IlCtFwC,iC;IOShC,QAAQ,2C2B6FwB,Q3B7FxB,E2B6FkB,S3B7FlB,C;I2B6FV,O3BrFI,4BAAkB,kB2BqFM,S3BrFN,EAPG,CAOH,EAPM,wB2B4FM,Q3B5FkB,aAAxB,CAON,C;G;E2B0F5B,0C;IlC3GwC,iC;IkC2HlC,O3B3FI,4BAAkB,wB2B2FY,S3B3FZ,E2B2FkB,M3B3FlB,E2B2FkB,M3B9FC,aAGnB,C;G;E2B6F5B,4C;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,4C;IlClIwC,iC;IkCmJlC,O3BnHI,4BAAkB,wB2BmHY,S3BnHZ,EANI,+C2ByHc,M3BzHd,E2ByHQ,S3BzHR,CAMJ,E2BmHkB,M3BzH6C,aAM/D,C;G;E2BsH5B,8D;IlCtJwC,iC;IkC2KlC,O3B3II,4BAAkB,wB2B2IY,S3B3IZ,E2B2IkB,M3B3IlB,E2B2IkB,M3BhIC,aAXnB,CAckB,gC2B6HQ,gB3B7HR,C;G;E2B+H9C,8D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,8D;IlClLwC,iC;IkCwMlC,O3BxKI,4BAAkB,wB2BwKY,S3BxKZ,EAQI,iD2BgKc,M3BhKd,E2BgKQ,S3BhKR,CARJ,E2BwKkB,M3BhK6C,aAR/D,CAckB,gC2B0JQ,gB3B1JR,C;G;E2B6J9C,4C;IlC3MwC,iC;IkC4NlC,O3B7JI,4BAAkB,wB2B6JY,S3B7JZ,E2B6JkB,M3B7JlB,E2B6JkB,M3BhKC,aAGnB,C;G;E2B+J5B,4C;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,4C;IlCnOwC,iC;IOuDhC,QAAQ,iD2B8L8B,M3B9L9B,E2B8LwB,S3B9LxB,C;I2B8LV,O3BnLI,4BAAkB,wB2BmLY,S3BnLZ,EAVS,CAUT,EAVY,CAUZ,E2BmLkB,M3B7LI,aAUtB,C;G;E2BwL5B,kD;IlC1PwC,iC;IkC2QlC,O3B7LI,4BAAkB,wB2B6LY,S3B7LZ,E2B6LkB,M3B7LlB,E2B6L0B,I3B7L1B,E2B6LkB,M3BhMO,aAGzB,C;G;E2B+L5B,kD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,mD;IlClRwC,iC;IkCqSlC,O3BvNI,4BAAkB,wB2BuNY,S3BvNZ,EANI,+C2B6Nc,M3B7Nd,E2B6NQ,S3B7NR,CAMJ,E2BuN0B,I3BvN1B,E2BuNkB,M3B7N4D,aAM9E,C;G;E2B0N5B,qE;IlCxSwC,iC;IkC6TlC,O3B/OI,4BAAkB,wB2B+OY,S3B/OZ,E2B+OkB,M3B/OlB,E2B+O0B,I3B/O1B,E2B+OkB,M3BpOO,aAXzB,CAcwB,gC2BiOQ,gB3BjOR,C;G;E2BmOpD,qE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,qE;IlCpUwC,iC;IkC0VlC,O3B5QI,4BAAkB,wB2B4QY,S3B5QZ,EAQI,iD2BoQc,M3BpQd,E2BoQQ,S3BpQR,CARJ,E2B4Q0B,I3B5Q1B,E2B4QkB,M3BpQ4D,aAR9E,CAcwB,gC2B8PQ,gB3B9PR,C;G;E2BiQpD,mD;IlC7VwC,iC;IkC8WlC,O3BjQI,4BAAkB,wB2BiQY,S3BjQZ,E2BiQkB,M3BjQlB,E2BiQ0B,I3BjQ1B,E2BiQkB,M3BpQO,aAGzB,C;G;E2BmQ5B,mD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,mD;IlCrXwC,iC;IOqGhC,QAAmB,iD2BkSmB,M3BlSnB,E2BkSa,S3BlSb,C;I2BkSrB,O3B1RI,4BAAkB,wB2B0RY,S3B1RZ,EAPS,CAOT,E2B0R0B,I3B1R1B,E2B0RkB,M3BjSO,aAOzB,C;G;E2B+R5B,yD;IlC5YwC,iC;IkC6ZlC,O3BjSI,4BAAkB,wB2BiSY,S3BjSZ,E2BiSkB,M3BjSlB,E2BiS0B,I3BjS1B,E2BiSgC,I3BjShC,E2BiSkB,M3BpSa,aAG/B,C;G;E2BmS5B,yD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yD;IlCpawC,iC;IkCsblC,O3B1TI,4BAAkB,wB2B0TY,S3B1TZ,EANI,+C2BgUc,M3BhUd,E2BgUQ,S3BhUR,CAMJ,E2B0T0B,I3B1T1B,E2B0TgC,I3B1ThC,E2B0TkB,M3BhU0E,aAM5F,C;G;E2B6T5B,2E;IlCzbwC,iC;IkC8clC,O3BlVI,4BAAkB,wB2BkVY,S3BlVZ,E2BkVkB,M3BlVlB,E2BkV0B,I3BlV1B,E2BkVgC,I3BlVhC,E2BkVkB,M3BvUa,aAX/B,CAc8B,gC2BoUQ,gB3BpUR,C;G;E2BsU1D,2E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2E;IlCrdwC,iC;IkC2elC,O3B/WI,4BAAkB,wB2B+WY,S3B/WZ,EAQI,iD2BuWc,M3BvWd,E2BuWQ,S3BvWR,CARJ,E2B+W0B,I3B/W1B,E2B+WgC,I3B/WhC,E2B+WkB,M3BvW0E,aAR5F,CAc8B,gC2BiWQ,gB3BjWR,C;G;E2BoW1D,yD;IlC9ewC,iC;IkC+flC,O3BpWI,4BAAkB,wB2BoWY,S3BpWZ,E2BoWkB,M3BpWlB,E2BoW0B,I3BpW1B,E2BoWgC,I3BpWhC,E2BoWkB,M3BvWa,aAG/B,C;G;E2BsW5B,yD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yD;IlCtgBwC,iC;IOmJhC,QAAwB,iD2BqYc,M3BrYd,E2BqYQ,S3BrYR,C;I2BqY1B,O3B7XI,4BAAkB,wB2B6XY,S3B7XZ,EAPS,CAOT,E2B6X0B,I3B7X1B,E2B6XgC,I3B7XhC,E2B6XkB,M3BpYa,aAO/B,C;G;E2BkY5B,+D;IlC7hBwC,iC;IkC8iBlC,O3BpYI,4BAAkB,wB2BoYY,S3BpYZ,E2BoYkB,M3BpYlB,E2BoY0B,I3BpY1B,E2BoYgC,I3BpYhC,E2BoYsC,I3BpYtC,E2BoYkB,M3BvYmB,aAGrC,C;G;E2BsY5B,+D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,+D;IlCrjBwC,iC;IkCukBlC,O3B7ZI,4BAAkB,wB2B6ZY,S3B7ZZ,EANI,+C2Bmac,M3Bnad,E2BmaQ,S3BnaR,CAMJ,E2B6Z0B,I3B7Z1B,E2B6ZgC,I3B7ZhC,E2B6ZsC,I3B7ZtC,E2B6ZkB,M3BnawF,aAM1G,C;G;E2Bga5B,iF;IlC1kBwC,iC;IkC+lBlC,O3BrbI,4BAAkB,wB2BqbY,S3BrbZ,E2BqbkB,M3BrblB,E2Bqb0B,I3Brb1B,E2BqbgC,I3BrbhC,E2BqbsC,I3BrbtC,E2BqbkB,M3B1amB,aAXrC,CAcoC,gC2BuaQ,gB3BvaR,C;G;E2ByahE,iF;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,iF;IlCtmBwC,iC;IkC4nBlC,O3BldI,4BAAkB,wB2BkdY,S3BldZ,EAQI,iD2B0cc,M3B1cd,E2B0cQ,S3B1cR,CARJ,E2Bkd0B,I3Bld1B,E2BkdgC,I3BldhC,E2BkdsC,I3BldtC,E2BkdkB,M3B1cwF,aAR1G,CAcoC,gC2BocQ,gB3BpcR,C;G;E2BuchE,+D;IlC/nBwC,iC;IkCgpBlC,O3BvcI,4BAAkB,wB2BucY,S3BvcZ,E2BuckB,M3BvclB,E2Buc0B,I3Bvc1B,E2BucgC,I3BvchC,E2BucsC,I3BvctC,E2BuckB,M3B1cmB,aAGrC,C;G;E2Byc5B,+D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,+D;IlCvpBwC,iC;IOiMhC,QAA4B,iD2BweU,M3BxeV,E2BweI,S3BxeJ,C;I2Bwe9B,O3BheI,4BAAkB,wB2BgeY,S3BheZ,EAPS,CAOT,E2Bge0B,I3Bhe1B,E2BgegC,I3BhehC,E2BgesC,I3BhetC,E2BgekB,M3BvemB,aAOrC,C;G;E2Bqe5B,qE;IlC9qBwC,iC;IkC+rBlC,O3BveI,4BAAkB,wB2BueY,S3BveZ,E2BuekB,M3BvelB,E2Bue0B,I3Bve1B,E2BuegC,I3BvehC,E2BuesC,I3BvetC,E2Bue4C,I3Bve5C,E2BuekB,M3B1eyB,aAG3C,C;G;E2Bye5B,qE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,qE;IlCtsBwC,iC;IkCwtBlC,O3BhgBI,4BAAkB,wB2BggBY,S3BhgBZ,EANI,+C2BsgBc,M3BtgBd,E2BsgBQ,S3BtgBR,CAMJ,E2BggB0B,I3BhgB1B,E2BggBgC,I3BhgBhC,E2BggBsC,I3BhgBtC,E2BggB4C,I3BhgB5C,E2BggBkB,M3BtgBsG,aAMxH,C;G;E2BmgB5B,uF;IlC3tBwC,iC;IkCgvBlC,O3BxhBI,4BAAkB,wB2BwhBY,S3BxhBZ,E2BwhBkB,M3BxhBlB,E2BwhB0B,I3BxhB1B,E2BwhBgC,I3BxhBhC,E2BwhBsC,I3BxhBtC,E2BwhB4C,I3BxhB5C,E2BwhBkB,M3B7gByB,aAX3C,CAc0C,gC2B0gBQ,gB3B1gBR,C;G;E2B4gBtE,uF;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,uF;IlCvvBwC,iC;IkC6wBlC,O3BrjBI,4BAAkB,wB2BqjBY,S3BrjBZ,EAQI,iD2B6iBc,M3B7iBd,E2B6iBQ,S3B7iBR,CARJ,E2BqjB0B,I3BrjB1B,E2BqjBgC,I3BrjBhC,E2BqjBsC,I3BrjBtC,E2BqjB4C,I3BrjB5C,E2BqjBkB,M3B7iBsG,aARxH,CAc0C,gC2BuiBQ,gB3BviBR,C;G;E2B0iBtE,qE;IlChxBwC,iC;IkCiyBlC,O3B1iBI,4BAAkB,wB2B0iBY,S3B1iBZ,E2B0iBkB,M3B1iBlB,E2B0iB0B,I3B1iB1B,E2B0iBgC,I3B1iBhC,E2B0iBsC,I3B1iBtC,E2B0iB4C,I3B1iB5C,E2B0iBkB,M3B7iByB,aAG3C,C;G;E2B4iB5B,qE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,qE;IlCxyBwC,iC;IO+OhC,QAAgC,iD2B2kBM,M3B3kBN,E2B2kBA,S3B3kBA,C;I2B2kBlC,O3BnkBI,4BAAkB,wB2BmkBY,S3BnkBZ,EAPS,CAOT,E2BmkB0B,I3BnkB1B,E2BmkBgC,I3BnkBhC,E2BmkBsC,I3BnkBtC,E2BmkB4C,I3BnkB5C,E2BmkBkB,M3B1kByB,aAO3C,C;G;E2BwkB5B,2E;IlC/zBwC,iC;IkCg1BlC,O3B1kBI,4BAAkB,wB2B0kBY,S3B1kBZ,E2B0kBkB,M3B1kBlB,E2B0kB0B,I3B1kB1B,E2B0kBgC,I3B1kBhC,E2B0kBsC,I3B1kBtC,E2B0kB4C,I3B1kB5C,E2B0kBkD,I3B1kBlD,E2B0kBkB,M3B7kB+B,aAGjD,C;G;E2B4kB5B,2E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2E;IlCv1BwC,iC;IkCy2BlC,O3BnmBI,4BAAkB,wB2BmmBY,S3BnmBZ,EANI,+C2BymBc,M3BzmBd,E2BymBQ,S3BzmBR,CAMJ,E2BmmB0B,I3BnmB1B,E2BmmBgC,I3BnmBhC,E2BmmBsC,I3BnmBtC,E2BmmB4C,I3BnmB5C,E2BmmBkD,I3BnmBlD,E2BmmBkB,M3BzmBoH,aAMtI,C;G;E2BsmB5B,6F;IlC52BwC,iC;IkCi4BlC,O3B3nBI,4BAAkB,wB2B2nBY,S3B3nBZ,E2B2nBkB,M3B3nBlB,E2B2nB0B,I3B3nB1B,E2B2nBgC,I3B3nBhC,E2B2nBsC,I3B3nBtC,E2B2nB4C,I3B3nB5C,E2B2nBkD,I3B3nBlD,E2B2nBkB,M3BhnB+B,aAXjD,CAcgD,gC2B6mBQ,gB3B7mBR,C;G;E2B+mB5E,6F;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,6F;IlCx4BwC,iC;IkC85BlC,O3BxpBI,4BAAkB,wB2BwpBY,S3BxpBZ,EAQI,iD2BgpBc,M3BhpBd,E2BgpBQ,S3BhpBR,CARJ,E2BwpB0B,I3BxpB1B,E2BwpBgC,I3BxpBhC,E2BwpBsC,I3BxpBtC,E2BwpB4C,I3BxpB5C,E2BwpBkD,I3BxpBlD,E2BwpBkB,M3BhpBoH,aARtI,CAcgD,gC2B0oBQ,gB3B1oBR,C;G;E2B6oB5E,2E;IlCj6BwC,iC;IkCk7BlC,O3B7oBI,4BAAkB,wB2B6oBY,S3B7oBZ,E2B6oBkB,M3B7oBlB,E2B6oB0B,I3B7oB1B,E2B6oBgC,I3B7oBhC,E2B6oBsC,I3B7oBtC,E2B6oB4C,I3B7oB5C,E2B6oBkD,I3B7oBlD,E2B6oBkB,M3BhpB+B,aAGjD,C;G;E2B+oB5B,2E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2E;IlCz7BwC,iC;IO6RhC,QAAmC,iD2B8qBG,M3B9qBH,E2B8qBH,S3B9qBG,C;I2B8qBrC,O3BtqBI,4BAAkB,wB2BsqBY,S3BtqBZ,EAPS,CAOT,E2BsqB0B,I3BtqB1B,E2BsqBgC,I3BtqBhC,E2BsqBsC,I3BtqBtC,E2BsqB4C,I3BtqB5C,E2BsqBkD,I3BtqBlD,E2BsqBkB,M3B7qB+B,aAOjD,C;G;E4BrU5B,gE;InCkC8C,uC;ImCXxC,sCCfE,kCAAwB,gCDemC,SCfnC,EDeyC,QCfzC,EDemD,SCfnD,CDe1B,C;G;EAEN,kE;InCS8C,uC;ImCcxC,sCClCE,kCAAwB,gCDkCmC,SClCnC,EDkCyC,QClCzC,EDkCmD,SClCnD,CDkC1B,C;G;EE5BF,mC;IrCgBqC,kC;IqChB7B,O7BPJ,6BAAmB,yB6BOqB,S7BPrB,C;G;E6BwBvB,sC;IrCDqC,kC;IqCC7B,kC7BrBJ,6BAAmB,4B6BqB6C,S7BrB7C,C6BqBf,C;G;EAGZ,wD;IA4BM,OAA+B,SAAX,UAAX,eAAT,yBAAS,CAAW,EAAQ,CAAR,CAAW,EAAO,QAAP,EAAkB,aAAlB,S;G;EAErC,uD;IAyBM,OAA+B,MAAX,UAAX,eAAT,yBAAS,CAAW,EAAQ,CAAR,CAAW,EAAM,sBAAN,C;G;EAErC,sF;IA+BM,OAA+B,QAAX,UAAX,eAAT,yBAAS,CAAW,EAAQ,CAAR,CAAW,EAAQ,sBAAR,EAAiC,6BAAjC,S;G;EAErC,6D;IAmBM,OAAsB,SAAL,WAAR,YAAT,yBAAS,CAAQ,CAAK,EAAO,QAAP,EAAkB,aAAlB,S;G;EAE5B,8D;IAyBM,OAAsB,QAAL,WAAR,YAAT,yBAAS,CAAQ,CAAK,EAAM,sBAAN,C;G;EAE5B,6F;IA+BM,OAAsB,UAAL,WAAR,YAAT,yBAAS,CAAQ,CAAK,EAAQ,sBAAR,EAAiC,6BAAjC,S;G;EAG5B,2D;IAmBM,OAAY,SAAZ,4BAAY,EAAO,QAAP,EAAkB,aAAlB,S;G;EAGlB,gD;IAqBM,OAA+B,MAAX,UAAX,eAAT,yBAAS,CAAW,EAAQ,CAAR,CAAW,EAAM,sBAAN,C;G;EAGrC,iD;IAqBM,OAAY,MAAZ,4BAAY,EAAM,sBAAN,C;G;EAGlB,gD;IrCtPyC,kC;IqCyQnC,sC7B5Pa,6BAAmB,a6B4PK,S7B5PL,E6B4PW,sB7B5PX,C6B4PhC,C;G;ECjTN,qC;IAmBM,sCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,uC;IAuBM,wCAA2B,KAA3B,EAAkC,SAAlC,EAAwC,yBAAxC,C;G;EAEN,qC;IAmBM,sCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,oC;IAwBM,qCAAwB,KAAxB,EAA+B,SAA/B,C;G;EAEN,yC;IAmBM,0CAA6B,KAA7B,EAAoC,SAApC,C;G;ECtGN,sC;IAmBM,2BAAO,QAAP,K;G;EAEN,sD;IvCSyC,kC;IQIT,0C;I+BegB,iBpC9CgB,aoC8CO,QpC9CP,EoC8CqB,apC9CrB,C;IoC8C1D,iC/BOE,qCAA2B,0B+BP8B,S/BO9B,EAAgC,UAAhC,C+BP7B,C;G;EAEN,kD;IAwBM,0BAAQ,sBAAR,K;G;EAEN,mF;IvC/CyC,kC;IQIT,0C;I+B0EgB,wBpCzGgB,aoCyGkB,sBpCzGlB,EoCyG8C,6BpCzG9C,C;IoCyG1D,iC/BDE,qCAA2B,qC+BCyC,S/BDzC,EAA2C,iBAA3C,C+BC7B,C;G;EAEN,8C;IAQuB,wCAAsB,SAAtB,C;G;ECtHvB,sC;IAmBM,2BAAO,QAAP,K;G;EAEN,sD;IxCSyC,kC;IQIT,0C;IgCOgB,iBrCtCgB,aqCsCW,QrCtCX,EqCsCyB,arCtCzB,C;IqCsC1D,iChCyBE,qCAA2B,8BgCzBkC,ShCyBlC,EAA8B,UAA9B,CgCzB7B,C;G;EAEN,oD;IAwBM,4BAAQ,sBAAR,K;G;EAEN,qF;IxCvCyC,kC;IQIT,0C;IgC2EgB,wBrC1GgB,aqC0GsB,sBrC1GtB,EqC0GkD,6BrC1GlD,C;IqC0G1D,iChCME,qCAA2B,yCgCN6C,ShCM7C,EAAyC,iBAAzC,CgCN7B,C;G;EAEN,8C;IAQuB,0CAAsB,SAAtB,C;G;EC3HvB,sC;IAmBM,2BAAO,QAAP,K;G;EAEN,sD;IzCayC,kC;IQIT,0C;IiCEgB,iBtCjCgB,asCiCQ,QtCjCR,EsCiCsB,atCjCtB,C;IsCiC1D,iCjCwCE,qCAA2B,2BiCxC+B,SjCwC/B,EAA2B,UAA3B,CiCxC7B,C;G;EAEN,oD;IAwBM,4BAAQ,sBAAR,K;G;EAEN,qF;IzClCyC,kC;IQIT,0C;IiC6DgB,wBtC5FgB,asC4FmB,sBtC5FnB,EsC4F+C,6BtC5F/C,C;IsC4F1D,iCjC2BE,qCAA2B,sCiC3B0C,SjC2B1C,EAAsC,iBAAtC,CiC3B7B,C;G;EClGN,6E;I1CiCyC,kC;IQIT,0C;IkCTC,aAEzB,aAAa,UAAb,EAAyB,WAAzB,EAAsC,mBAAtC,C;IAHe,iClC8DJ,qCAA2B,kCkC5DtC,SlC4DsC,EAAkC,MAAlC,CkC9DvB,C;G;EAOvB,+E;I1CDyC,kC;IQIT,0C;IkC6BC,aAEzB,aAAa,UAAb,EAAyB,WAAzB,EAAsC,mBAAtC,C;IAHe,iClCmEJ,qCAA2B,6CkCjEtC,SlCiEsC,EAA6C,MAA7C,CkCnEvB,C;G;EC1DnB,mC;I3C0BqC,kC;IQIT,0C;IAgEQ,sD;ImC9F5B,OnCwIJ,yCAAuB,oBmCxIsC,SnCwItC,C;G;EmCxH3B,6B;I3CUqC,kC;IQIT,0C;IAgEQ,sD;ImC7E5B,OnC0HJ,yCAAuB,wBmC1H0C,SnC0H1C,C;G;EmCzG3B,gC;I3CRqC,kC;IQIT,0C;IAgEQ,sD;ImC5D5B,OnC4GJ,yCAAuB,iBmC5GmC,SnC4GnC,C;G;EmC3F3B,+B;I3CzBqC,kC;IQIT,0C;IAgEQ,sD;ImC1C5B,OnC6FJ,yCAAuB,qBmC7FuC,SnC6FvC,C;G;EmC7E3B,gC;I3C1CqC,kC;IQIT,0C;IAgEQ,sD;ImC1B5B,OnCgFJ,yCAAuB,4BmChF8C,SnCgF9C,C;G;EmCjE3B,+B;I3CzDqC,kC;IQIT,0C;IAgEQ,sD;ImCX5B,OnCoEJ,yCAAuB,kCmCpEoD,SnCoEpD,C;G;EoCpK/B,+B;IAiBM,O5CwB+B,8B4CxBf,aAAI,SAAJ,EAAU,KAAV,C;G;EAEtB,mD;I5CsBqC,8B;I4CH/B,sCCXE,yBAAe,aDWgB,SCXhB,EDWsB,KCXtB,EDW6B,gBCX7B,CDWjB,C;G;EAEN,iC;IAiBM,O5ChB+B,8B4CgBf,qBAAY,SAAZ,EAAkB,KAAlB,C;G;EErDtB,yD;I9CuCoC,6B;I8CjBF,oB3Cd8B,a2Ccf,Y3Cde,E2CcG,U3CdH,C;I2Cc1D,sCC+BE,wBAAc,kBD/BqB,SC+BrB,EAAgB,aAAhB,CD/BhB,C;G;EAEN,yD;I9CeoC,6B;I8CWgE,kB3C1CpC,a2C0CM,Q3C1CN,E2C0CoB,c3C1CpB,C;IE2wCrD,kBAAM,eAAa,qCAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,6B;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WAAc,IyCvyC2E,SzCuyCzF,C;;IyCvyChB,sCCUI,wBAAc,wCDVyC,SCUzC,E1C8xCX,W0C9xCW,CDVlB,C;G;EAEJ,qC;I9CboC,6B;I8C6B9B,sCCzCE,wBAAc,qBDyCwB,SCzCxB,EDyC8B,GCzC9B,CDyChB,C;G;EAEN,wC;I9C/BoC,6B;I8C+C9B,sCCxDE,wBAAc,wBDwD2B,SCxD3B,EDwDiC,GCxDjC,CDwDhB,C;G;EAIN,qC;I9CnDoC,6B;I8CqE9B,OC3CE,wBAAc,qBD2CW,SC3CX,ED2CiB,GC3CjB,C;G;ED6CtB,yD;I9CvEoC,6B;I8C0F9B,sCCxDE,wBAAc,qBDwDwB,SCxDxB,EDwD8B,GCxD9B,EDwDmC,gBCxDnC,CDwDhB,C;G;EAGN,qC;I9C7FoC,6B;I8C8G9B,OCvEE,wBAAc,6BDuEmB,SCvEnB,EDuEyB,GCvEzB,C;G;EDyEtB,oC;I9ChHoC,6B;I8CgI9B,sCC7EyE,wBAAc,iBD6EnD,SC7EmD,ED6E7C,IC7E6C,CD6EvF,C;G;EAEN,8B;I9ClIoC,6B;I8CkJ9B,sCCvJE,wBAAc,iBDuJoB,SCvJpB,CDuJhB,C;G;EAEN,iC;I9CpJoC,6B;I8CoK9B,sCCjKE,wBAAc,oBDiKuB,SCjKvB,CDiKhB,C;G;EAoByB,6B;IAAyB,+DAAS,qB;aAAW,c;KAApB,E;G;EAExD,2C;I9C1LoC,6B;I8C6M9B,sCCnJa,wBAAc,cDmJM,SCnJN,EDmJY,gBCnJZ,CDmJ3B,C;G;EAmB2B,+B;IAAgC,iEAAS,qB;aAAW,gB;KAApB,E;G;EAEjE,+C;I9ClOoC,6B;I8CqP9B,sCCpLa,wBAAc,gBDoLQ,SCpLR,EDoLc,gBCpLd,CDoL3B,C;G;EAoB0C,8B;IAAE,OAAA,EAAG,Q;EAAQ,C;EAlB7D,8B;IAkBM,O5ClRE,+BAAsB,gB4CkRC,S5ClRD,C4CkRO,oBAAW,gBAAX,C;G;EAErC,kD;IAmBM,OAAA,oBAAY,gCAAuB,gBAAvB,C;G;EExUlB,2C;IhD0CoC,6B;I+C5BqB,kC;ICOnD,sCCea,6BAAmB,oBDfa,SCeb,EDfmB,GCenB,EDfwB,KCexB,CDfhC,C;G;EAmBoC,4B;IAAoB,8DAAS,qB;aAAiB,a;KAA1B,E;G;EAoB1B,8B;IAAoC,8DAAS,qB;aAAiB,a;KAA1B,E;G;EAExE,0C;IhDpBoC,6B;I+C5BqB,kC;ICmEnD,sCCtCa,6BAAmB,aDsCM,SCtCN,EDsCY,gBCtCZ,CDsChC,C;G;EAmBsC,8B;IAAoB,gEAAS,qB;aAAiB,e;KAA1B,E;G;EAoB1B,gC;IAAoC,gEAAS,qB;aAAiB,e;KAA1B,E;G;EAE1E,8C;IhDhFoC,6B;I+C5BqB,kC;IC+HnD,sCC3Fa,6BAAmB,eD2FQ,SC3FR,ED2Fc,gBC3Fd,CD2FhC,C;G;EE5HiC,8B;IAAoB,gEAAS,qB;aAAY,e;KAArB,E;G;EAoB1B,gC;IAAoC,gEAAS,qB;aAAY,e;KAArB,E;G;EAGrE,4C;IlDIqC,8B;IkDe/B,sCCvCa,yBAAe,eDuCO,SCvCP,EDuCa,gBCvCb,CDuC5B,C;G;EAmBkC,+B;IAAoB,iEAAS,qB;aAAY,gB;KAArB,E;G;EAoB1B,iC;IAAoC,iEAAS,qB;aAAY,gB;KAArB,E;G;EAGtE,6C;IlDzDqC,8B;IkD4E/B,sCC7Fa,yBAAe,gBD6FQ,SC7FR,ED6Fc,gBC7Fd,CD6F5B,C;G;EE1GgB,uC;IAClB,oD;G;2BAEA,Y;IAAuD,cAAO,2BAAP,C;G;;;;;;EAelC,wE;IACrB,oD;IACA,kE;G;;SAEsB,Y;MAAQ,kC;K;;;SACH,Y;MAAQ,yC;K;;6BAEnC,Y;IAAuD,OjD5BK,aiD4BL,2BjD5BK,EiD4BuB,kCjD5BvB,C;G;;;;;;EiDqC7B,oD;IAAC,c;IAAY,8D;G;8BAC5C,Y;IAAiD,oBAAO,gCAAP,C;G;gCACjD,Y;IACM,yBAAe,QAAf,iBAAgC,wCAAJ,GAAyC,MAAzC,GAAqD,QAAjF,O;G;;;;;;kCARV,Y;IAKoC,e;G;kCALpC,Y;IAKgD,uC;G;oCALhD,4C;IAAA,oBAKoC,+BALpC,EAKgD,uGALhD,C;G;gCAAA,Y;IAAA,c;IAKoC,oD;IAAY,4E;IALhD,a;G;8BAAA,iB;IAAA,4IAKoC,kCALpC,IAKgD,kFALhD,I;G;EAeuB,yB;IAAC,wB;G;2BACpB,Y;IAAwB,cAAO,aAAP,C;G;;;;;;+BAL5B,Y;IAIwB,oB;G;+BAJxB,oB;IAAA,iBAIwB,8CAJxB,C;G;6BAAA,Y;IAAA,OAIwB,kDAJxB,M;G;6BAAA,Y;IAAA,c;IAIwB,yD;IAJxB,a;G;2BAAA,iB;IAAA,2IAIwB,4CAJxB,G;G;EAYmB,yC;IACf,kC;IACA,4C;G;;SADA,Y;MAAA,8B;K;;;SACA,Y;MAAA,mC;K;;4BAEA,Y;IAAwB,iBAAO,aAAP,SAAkB,kBAAlB,E;G;;;;;;ECxDoB,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAjBlE,kC;IAiBM,OnDmBE,+BAAsB,gBmDnBC,SnDmBD,CmDnBO,oBAAW,mBAAX,C;G;8GCdrC,yB;IAAA,gC;ItD8CkC,6G;ISF9B,2K;I6C5CJ,wE;MtD8C0C,mC;MStBZ,yC;M6CLM,yC;M7C+B5B,kCAA0B,c6C/BO,S7C+BP,EAA6B,YAA7B,E6C/B+B,gB7C+B/B,C;I6C9BlC,C;GApBA,C;EAsBA,+B;ItDwB0C,mC;IStBZ,yC;IA+BtB,oCAA0B,uB6CjBgB,S7CiBhB,C;E6ChBlC,C;EAEA,8C;IAqBiC,kBAA7B,2DAAS,qB;aAAW,iB;KAApB,E;ItDrCgC,6B;IuDFJ,uC;IAA5B,iCtDoCI,wBAAc,mBsDpCoB,WtDoCpB,EAAiB,IAAjB,EqDGuB,gBrDHvB,CsDpClB,C;EDwCJ,C;EA4BY,yE;IAAA,4B;MAAE,oBAAS,gBAAT,EAAoB,qBAApB,S;MAAmC,W;IAAA,C;G;EA1BjD,6D;IA0BI,mBAAQ,+CAAR,C;EACJ,C;sHCzFA,yB;IAAA,gC;IvDsB4B,6G;IC4BxB,mJ;IsDlDJ,wD;MvDsBoC,6B;MuDFJ,yB;MAA5B,+BtDoCI,wBAAc,mBsDpCoB,StDoCpB,EAAiB,IAAjB,EsDpCoC,gBtDoCpC,CsDpClB,C;IACJ,C;GArBA,C;sGAuBA,yB;IAAA,gC;IvDD4B,6G;ICkFxB,iL;IsDjFJ,8D;MvDDoC,6B;MCyDpB,+C;MsDxB0B,+B;MtDqDlC,wCAAgC,asDrDM,StDqDN,EAAW,OAAX,EsDrDyB,gBtDqDzB,C;IsDpDxC,C;GAjCA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}