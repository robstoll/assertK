{"version":3,"file":"atrium-api-cc-de_CH-js.js","sources":["../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/AssertImpl.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/anyAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/ExpectImpl.kt","../../../../../kbox-common/src/main/kotlin/ch/tutteli/kbox/varargToList.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/charSequenceAssertionsBuilders.kt","generated/_Collections.kt","text/regex/RegexExtensions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/FeatureAssertionsBuilder.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/iterableAssertionsBuilders.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/throwableAssertionsBuilders.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/anyAssertions.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/arrayAssertions.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/charSequenceAssertions.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/charSequenceContainsCheckers.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/charSequenceContainsCreators.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/charSequenceContainsDecorators.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/collectionAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/CollectionAssertionsBuilder.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/comparableAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ComparableAssertionsBuilder.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/charsequence/contains/builders/impl/AtLeastCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/charsequence/contains/builders/impl/AtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/charsequence/contains/builders/impl/ButAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/charsequence/contains/builders/impl/ExactlyCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/charsequence/contains/builders/impl/NotCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/charsequence/contains/builders/impl/NotOrAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/charsequence/contains/builders/impl/nameContainsNotFun.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/iterable/contains/builders/impl/AtLeastCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/iterable/contains/builders/impl/AtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/iterable/contains/builders/impl/ButAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/iterable/contains/builders/impl/ExactlyCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/iterable/contains/builders/impl/NotCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/iterable/contains/builders/impl/NotOrAtMostCheckerOptionImpl.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/creating/iterable/contains/builders/impl/nameContainsNotFun.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/featureAssertions.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/floatingPointAssertions.kt","../../../../src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/FloatingPointAssertionsBuilder.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/iterableAssertions.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/iterableContainsCheckers.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/iterableContainsDecorators.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/iterableContainsInAnyOrderCreators.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/iterableContainsInAnyOrderOnlyCreators.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/iterableContainsInOrderOnlyCreators.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/iterableContainsInOrderOnlyGroupedCreators.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/listAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/ListAssertionsBuilder.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/mapAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapAssertionsBuilder.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/mapEntryAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/MapEntryAssertionsBuilder.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/pairAssertions.kt","../../../../../atrium-domain-builders-common/src/main/kotlin/ch/tutteli/atrium/domain/builders/creating/PairAssertionsBuilder.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/parameterObjects.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/sequenceAssertions.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/throwableAssertions.kt","../../../../../atrium-api-cc-de_CH-common/src/main/kotlin/ch/tutteli/atrium/api/cc/de_CH/typeTransformationAssertions.kt"],"sourcesContent":["@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n\npackage ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.core.CoreFactory\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.BaseAssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.subjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give users of Atrium a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\")\nobject AssertImpl : AssertImplCommon {\n\n    override inline val builder get() = assertionBuilder\n\n    override inline val collector get() = AssertionCollectorBuilder\n\n    override inline val coreFactory get() = ch.tutteli.atrium.core.coreFactory\n\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    override inline val any get() = AnyAssertionsBuilder\n\n    override inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    override inline val collection get() = CollectionAssertionsBuilder\n\n    override inline val comparable get() = ComparableAssertionsBuilder\n\n    @Suppress(\"DEPRECATION\")\n    override inline val feature get() = FeatureAssertionsBuilder\n\n    override inline val floatingPoint get() = FloatingPointAssertionsBuilder\n\n    override inline val iterable get() = IterableAssertionsBuilder\n\n    override inline val list get() = ListAssertionsBuilder\n\n    override inline val map get() = MapAssertionsBuilder\n\n    override inline val pair get() = PairAssertionsBuilder\n\n    override inline val throwable get() = ThrowableAssertionsBuilder\n}\n\ninterface AssertImplCommon {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    val builder: AssertionBuilder\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    val collector: AssertionCollectorBuilder\n\n    /**\n     * Returns the implementation of [CoreFactory].\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.core.coreFactory]\n     * which in turn delegates to the implementation via [loadSingleService].\n     */\n    val coreFactory: CoreFactory\n\n    /**\n     * Creates a new [AssertionPlant] based on the given [subjectProvider] whereas the [AssertionPlant] delegates\n     * assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlant] but merely want to make feature assertions so that\n     * you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlant<R> = subjectChanger.unreportedToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = subjectChanger.unreported(originalAssertionCreator, transformation)\n\n    /**\n     * Creates a new [AssertionPlantNullable] based on the given [subjectProvider] whereas the [AssertionPlant]\n     * delegates assertion checking to the given [originalPlant].\n     *\n     * This method is useful if you want to make feature assertion(s) but you do not want that the feature is shown up\n     * in reporting. For instance, if a class can behave as another class (e.g. `Sequence::asIterable`) or you want to\n     * hide a conversion (e.g. `Int::toChar`) then you can use this function.\n     *\n     * Notice, if you do not require the resulting [AssertionPlantNullable] but merely want to make feature\n     * assertions so that you can use them as part of a bigger assertion, then use [collector] instead.\n     */\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported; will be removed with 1.0.0 - moreover we advice you to switch to Expect and no longer use Assert\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalPlant, subjectProvider).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R> changeToNullableSubject(\n        originalPlant: BaseAssertionPlant<T, *>,\n        subjectProvider: () -> R\n    ): AssertionPlantNullable<R> = subjectChanger.unreportedNullableToAssert(originalPlant) { subjectProvider() }\n\n    @Deprecated(\n        \"Use ExpectImpl.changeSubject.unreported - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\",\n        ReplaceWith(\n            \"ExpectImpl.changeSubject(originalAssertionCreator, transformation).unreported\",\n            \"import ch.tutteli.atrium.domain.builders.ExpectImpl\"\n        )\n    )\n    fun <T, R : Any> changeToNullableSubject(\n        originalAssertionCreator: Expect<T>,\n        transformation: (T) -> R\n    ): Expect<R> = changeSubject(originalAssertionCreator, transformation)\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    val any: AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    val charSequence: CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    val collection: CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    val comparable: ComparableAssertionsBuilder\n\n    /**\n     * Returns [FeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    @Suppress(\"DEPRECATION\")\n    val feature: FeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    val floatingPoint: FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    val iterable: IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    val list: ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    val map: MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    val pair: PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    val throwable: ThrowableAssertionsBuilder\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\", \"DEPRECATION\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.AnyAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.AnyTypeTransformation\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.AnyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.creators.anyTypeTransformationAssertions\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.FailureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.any.typetransformation.failurehandlers.failureHandlerFactory\nimport ch.tutteli.atrium.domain.creating.anyAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [AnyAssertions].\n * In detail, it implements [AnyAssertions] by delegating to [anyAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject AnyAssertionsBuilder : AnyAssertions {\n\n    override inline fun <T : Any> toBe(subjectProvider: SubjectProvider<T>, expected: T): Assertion =\n        anyAssertions.toBe(subjectProvider, expected)\n\n    override inline fun <T> notToBe(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.notToBe(subjectProvider, expected)\n\n    override inline fun <T> isSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isSame(subjectProvider, expected)\n\n    override inline fun <T> isNotSame(subjectProvider: SubjectProvider<T>, expected: T) =\n        anyAssertions.isNotSame(subjectProvider, expected)\n\n    override inline fun <T> toBeNull(subjectProvider: SubjectProvider<T>) =\n        anyAssertions.toBeNull(subjectProvider)\n\n    override inline fun <T : Any> toBeNullable(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        expectedOrNull: T?\n    ) = anyAssertions.toBeNullable(assertionContainer, type, expectedOrNull)\n\n    override inline fun <T : Any> toBeNullIfNullGivenElse(\n        assertionContainer: Expect<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (Expect<T>.() -> Unit)?\n    ) = anyAssertions.toBeNullIfNullGivenElse(assertionContainer, type, assertionCreatorOrNull)\n\n    override inline fun <T, TSub : Any> isA(assertionContainer: Expect<T>, subType: KClass<TSub>) =\n        anyAssertions.isA(assertionContainer, subType)\n\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullable(plant: AssertionPlantNullable<T?>, type: KClass<T>, expectedOrNull: T?) =\n        anyAssertions.isNullable(plant, type, expectedOrNull)\n\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyAssertions.isNotNull(plant, type, assertionCreator)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNotNullBut(plant: AssertionPlantNullable<T?>, type: KClass<T>, expected: T) =\n        anyAssertions.isNotNullBut(plant, type, expected)\n\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect and use toBeNullable; will be removed with 1.0.0\")\n    override inline fun <T : Any> isNullIfNullGivenElse(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreatorOrNull: (AssertionPlant<T>.() -> Unit)?\n    ) = anyAssertions.isNullIfNullGivenElse(plant, type, assertionCreatorOrNull)\n\n\n    /**\n     * Returns [AnyTypeTransformationAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyTypeTransformationAssertions].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from `Assert` to `Expect` use `ExpectImpl.changeSubject` or `ExpectImpl.feature.extract` instead; will be removed with 1.0.0\")\n    inline val typeTransformation\n        get() = AnyTypeTransformationAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [AnyTypeTransformationAssertions].\n * In detail, it implements [AnyTypeTransformationAssertions] by delegating to [anyTypeTransformationAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationAssertionsBuilder : AnyTypeTransformationAssertions {\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\n        \"This function will be removed in v.1.0.0 in favour of AssertImpl.any.isNotNull\", ReplaceWith(\n            \"plant.addAssertion(AssertImpl.any.isNotNull(plant, type, assertionCreator))\",\n            \"ch.tutteli.atrium.domain.builders.AssertImpl\"\n        )\n    )\n    override inline fun <T : Any> isNotNull(\n        plant: AssertionPlantNullable<T?>,\n        type: KClass<T>,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = anyTypeTransformationAssertions.isNotNull(plant, type, assertionCreator)\n\n    override inline fun <TSub : Any> isA(\n        plant: AssertionPlant<Any>,\n        subType: KClass<TSub>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit\n    ) = anyTypeTransformationAssertions.isA(plant, subType, assertionCreator)\n\n    override inline fun <T : Any, TSub : T> downCast(\n        description: Translatable,\n        subType: KClass<TSub>,\n        subjectPlant: BaseAssertionPlant<T?, *>,\n        noinline assertionCreator: AssertionPlant<TSub>.() -> Unit,\n        failureHandler: AnyTypeTransformation.FailureHandler<T, TSub>\n    ) = anyTypeTransformationAssertions.downCast(description, subType, subjectPlant, assertionCreator, failureHandler)\n\n    override inline fun <S : Any, T : Any> transform(\n        parameterObject: AnyTypeTransformation.ParameterObject<S, T>,\n        noinline canBeTransformed: (S) -> Boolean,\n        noinline transform: (S) -> T,\n        failureHandler: AnyTypeTransformation.FailureHandler<S, T>\n    ) = anyTypeTransformationAssertions.transform(parameterObject, canBeTransformed, transform, failureHandler)\n\n    /**\n     * Returns [AnyTypeTransformationFailureHandlerFactoryBuilder]\n     * which inter alia delegates to the implementation of [FailureHandlerFactory].\n     */\n    inline val failureHandlers get() = AnyTypeTransformationFailureHandlerFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [FailureHandlerFactory].\n * In detail, it implements [FailureHandlerFactory] by delegating to [failureHandlerFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Switch from `Assert` to `Expect` and use `ExpectImpl` instead; will be removed with 1.0.0\")\nobject AnyTypeTransformationFailureHandlerFactoryBuilder : FailureHandlerFactory {\n\n    override inline fun <S : Any, T : Any> newExplanatory() = failureHandlerFactory.newExplanatory<S, T>()\n\n    override inline fun <S : Any, T : Any> newExplanatoryWithHint(\n        noinline showHint: () -> Boolean,\n        noinline failureHintFactory: () -> Assertion\n    ) = failureHandlerFactory.newExplanatoryWithHint<S, T>(showHint, failureHintFactory)\n}\n","package ch.tutteli.atrium.domain.builders\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.builders.AssertionBuilder\nimport ch.tutteli.atrium.assertions.builders.assertionBuilder\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.creating.*\nimport ch.tutteli.atrium.domain.builders.creating.changers.SubjectChangerBuilder\nimport ch.tutteli.atrium.domain.builders.creating.collectors.AssertionCollectorBuilder\nimport ch.tutteli.atrium.domain.creating.*\nimport ch.tutteli.atrium.domain.creating.changers.SubjectChanger\nimport ch.tutteli.atrium.domain.creating.collectors.AssertionCollector\n\n/**\n * Bundles different domain objects which are defined by the module atrium-domain-api\n * to give assertion writers (and other consumers of the domain) a fluent API as well.\n */\n@Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\nobject ExpectImpl {\n\n    /**\n     * Returns [AssertionBuilder] - helping you creating [Assertion]s.\n     * In detail, its an `inline` property which returns [ch.tutteli.atrium.assertions.builders.assertionBuilder]\n     * which in turn returns an implementation of [AssertionBuilder].\n     */\n    inline val builder get() = assertionBuilder\n\n    /**\n     * Returns [SubjectChangerBuilder] - helping you to change the subject of the assertion.\n     * In detail, its an `inline` property which returns [SubjectChangerBuilder]\n     * which inter alia delegates to the implementation of [SubjectChanger].\n     *\n     * In case you want to extract a feature (e.g. get the first element of a `List`) instead of changing the subject\n     * into another representation (e.g. down-cast `Person` to `Student`) then you should use\n     * [feature.extractor][NewFeatureAssertionsBuilder.extractor] instead.\n     */\n    inline fun <T> changeSubject(originalAssertionContainer: Expect<T>) =\n        SubjectChangerBuilder.create(originalAssertionContainer)\n\n    @Deprecated(\"Do no longer use Assert, use Expect instead - this method was introduced in 0.9.0 to ease the migration from Assert to Expect; will be removed with 1.0.0\")\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    inline fun <T> changeSubject(originalAssertionContainer: SubjectProvider<T>) =\n        SubjectChangerBuilder.create(originalAssertionContainer)\n\n    /**\n     * Returns [AssertionCollectorBuilder] - helping you to collect feature assertions.\n     * In detail, its an `inline` property which returns [AssertionCollectorBuilder]\n     * which inter alia delegates to the implementation of [AssertionCollector].\n     */\n    inline val collector get() = AssertionCollectorBuilder\n\n    //--- assertions ---------------------------------------------------------------------------\n\n    /**\n     * Returns [AnyAssertionsBuilder]\n     * which inter alia delegates to the implementation of [AnyAssertions].\n     */\n    inline val any get() = AnyAssertionsBuilder\n\n    /**\n     * Returns [CharSequenceAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceAssertions].\n     */\n    inline val charSequence get() = CharSequenceAssertionsBuilder\n\n    /**\n     * Returns [CollectionAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CollectionAssertions].\n     */\n    inline val collection get() = CollectionAssertionsBuilder\n\n    /**\n     * Returns [ComparableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ComparableAssertions].\n     */\n    inline val comparable get() = ComparableAssertionsBuilder\n\n    /**\n     * Returns [NewFeatureAssertionsBuilder]\n     * which inter alia delegates to the implementation of [FeatureAssertions].\n     */\n    inline val feature get() = NewFeatureAssertionsBuilder\n\n    /**\n     * Returns [FloatingPointAssertionsBuilder] - [Assertion]s applicable to [Float], [Double]\n     * and maybe more - which inter alia delegates to the implementation of [FloatingPointAssertions].\n     */\n    inline val floatingPoint get() = FloatingPointAssertionsBuilder\n\n    /**\n     * Returns [IterableAssertionsBuilder].\n     * which inter alia delegates to the implementation of [IterableAssertions].\n     */\n    inline val iterable get() = IterableAssertionsBuilder\n\n    /**\n     * Returns [ListAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ListAssertions].\n     */\n    val list get() = ListAssertionsBuilder\n\n    /**\n     * Returns [MapAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapAssertions].\n     */\n    inline val map get() = MapAssertionsBuilder\n\n    /**\n     * Returns [PairAssertionsBuilder]\n     * which inter alia delegates to the implementation of [PairAssertions].\n     */\n    inline val pair get() = PairAssertionsBuilder\n\n    /**\n     * Returns [ThrowableAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableAssertions].\n     */\n    inline val throwable get() = ThrowableAssertionsBuilder\n}\n","package ch.tutteli.kbox\n\n/**\n * Adds the given [arg] and the [otherArgs] into a new [List] and returns it.\n *\n * This function is intended for API functions which expect `x: T, vararg otherX: T` and want to pass the arguments\n * to another function which expects only one argument of `List<T>`.\n *\n * @return a [List] containing [arg] and [otherArgs].\n */\nfun <T> varargToList(arg: T, otherArgs: Array<out T>): List<T> {\n    val list = ArrayList<T>(otherArgs.size + 1)\n    list.add(arg)\n    list.addAll(otherArgs)\n    return list\n}\n\n/**\n * Delegates to [varargToList] -- adds `this` and the [otherArgs] into a new [List] and returns it.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\ninline infix fun <T> T.glue(otherArgs: Array<out T>): List<T> = varargToList(this, otherArgs)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CharSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charSequenceAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.CharSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.creators.charSequenceContainsAssertions\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.SearchBehaviourFactory\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.searchBehaviourFactory\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceAssertions].\n * In detail, it implements [CharSequenceAssertions] by delegating to [charSequenceAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceAssertionsBuilder : CharSequenceAssertions {\n\n    override inline fun <T : CharSequence> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <T : CharSequence> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        charSequenceAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun startsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsWith(subjectProvider, expected)\n\n    override inline fun startsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.startsNotWith(subjectProvider, expected)\n\n    override inline fun endsWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsWith(subjectProvider, expected)\n\n    override inline fun endsNotWith(subjectProvider: SubjectProvider<CharSequence>, expected: CharSequence) =\n        charSequenceAssertions.endsNotWith(subjectProvider, expected)\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun isNotBlank(subjectProvider: SubjectProvider<CharSequence>) =\n        charSequenceAssertions.isNotBlank(subjectProvider)\n\n    override inline fun <T : CharSequence> matches(assertionContainer: Expect<T>, expected: Regex) =\n        charSequenceAssertions.matches(assertionContainer, expected)\n\n    override inline fun <T : CharSequence> mismatches(assertionContainer: Expect<T>, expected: Regex) =\n        charSequenceAssertions.mismatches(assertionContainer, expected)\n\n    /**\n     * Returns [CharSequenceContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [CharSequenceContainsAssertions].\n     */\n    inline val contains get() = CharSequenceContainsAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [CharSequenceContainsAssertions].\n * In detail, it implements [CharSequenceContainsAssertions] by delegating to [charSequenceContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceContainsAssertionsBuilder : CharSequenceContainsAssertions {\n\n    override inline fun <T : CharSequence> values(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Any>\n    ) = charSequenceContainsAssertions.values(checkerOption, expected)\n\n    override inline fun <T : CharSequence> valuesIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Any>\n    ) = charSequenceContainsAssertions.valuesIgnoringCase(checkerOption, expected)\n\n    override inline fun <T : CharSequence> defaultTranslationOf(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOf(checkerOption, expected)\n\n    override inline fun <T : CharSequence> defaultTranslationOfIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<Translatable>\n    ) = charSequenceContainsAssertions.defaultTranslationOfIgnoringCase(checkerOption, expected)\n\n    @JvmName(\"stringRegex\")\n    inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<String>\n    ) = regex(checkerOption, expected.map { it.toRegex() })\n\n    override inline fun <T : CharSequence> regex(\n        checkerOption: CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>,\n        expected: List<Regex>\n    ) = charSequenceContainsAssertions.regex(checkerOption, expected)\n\n    override inline fun <T : CharSequence> regexIgnoringCase(\n        checkerOption: CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>,\n        expected: List<String>\n    ) = charSequenceContainsAssertions.regexIgnoringCase(checkerOption, expected)\n\n    /**\n     * Returns [CharSequenceContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = CharSequenceContainsSearchBehaviourFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CharSequenceContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <T : CharSequence> ignoringCase(\n        containsBuilder: CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    ): CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour> =\n        searchBehaviourFactory.ignoringCase(containsBuilder)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Converts the string into a regular expression [Regex] with the default options.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(): Regex = Regex(this)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified single [option].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(option: RegexOption): Regex = Regex(this, option)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified set of [options].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(options: Set<RegexOption>): Regex = Regex(this, options)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\", \"DEPRECATION\")\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.creating.FeatureAssertions\nimport ch.tutteli.atrium.domain.creating.feature.extract.FeatureExtractor\nimport ch.tutteli.atrium.domain.creating.featureAssertions\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport ch.tutteli.atrium.reporting.translating.Untranslatable\nimport kotlin.reflect.*\nimport kotlin.jvm.JvmName\n\n/**\n * Delegates inter alia to the implementation of [FeatureAssertions].\n * In detail, it implements [FeatureAssertions] by delegating to [featureAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Deprecated(\"Switch from `Assert` to `Expect` and use then ExpectImpl.feature, NewFeatureAssertionsBuilder respectively; will be removed with 1.0.0\")\nobject FeatureAssertionsBuilder : FeatureAssertions {\n\n    @Suppress(\"DEPRECATION\")\n    inline val extractor: FeatureExtractor.DescriptionOption get() = FeatureExtractor.builder\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>)\n        = property(plant, { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) }, Untranslatable(property.name))\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>)\n        = property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable): AssertionPlant<TProperty>\n        = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable): AssertionPlant<TProperty>\n        = featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit)\n        = property(plant, { @Suppress(\"DEPRECATION\") property.invoke(plant.subject) },  Untranslatable(property.name), assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit)\n        = property(plant, property,  Untranslatable(property.name), assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit): AssertionPlant<TProperty>\n        = property(plant, subjectProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, TProperty : Any> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable, noinline assertionCreator: AssertionPlant<TProperty>.() -> Unit): AssertionPlant<TProperty>\n        = property(plant, subjectProvider, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, property: KProperty1<T, TProperty>): AssertionPlantNullable<TProperty> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\")  property.invoke(plant.subject) }\n        return property(plant, l, Untranslatable(property.name))\n    }\n\n    inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, property: KProperty0<TProperty>)\n        = property(plant, property, Untranslatable(property.name))\n\n    override inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, name: Translatable): AssertionPlantNullable<TProperty>\n        = featureAssertions.property(plant, subjectProvider, name)\n\n    override inline fun <T : Any, TProperty : Any?> property(plant: AssertionPlant<T>, noinline subjectProvider: () -> TProperty, noinline representationProvider: () -> Any?, name: Translatable): AssertionPlantNullable<TProperty>\n        = featureAssertions.property(plant, subjectProvider, representationProvider, name)\n\n\n    //Arg0\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>): AssertionPlant<R>\n        = returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>): AssertionPlant<R>\n        = returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, { @Suppress(\"DEPRECATION\") method(plant.subject) }, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, method.name, assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, R : Any> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf0(plant, method, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf0\")\n    inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: KFunction1<T, R>): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l = { @Suppress(\"DEPRECATION\") method(plant.subject) }\n        return returnValueOf0(plant, l, l, method.name)\n    }\n\n    inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, method: KFunction0<R>): AssertionPlantNullable<R>\n        = returnValueOf0(plant, method, method.name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf0(plant, method, name)\n\n    override inline fun <T : Any, R : Any?> returnValueOf0(plant: AssertionPlant<T>, noinline method: () -> R, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf0(plant, method, representationProvider, name)\n\n\n    //Arg1\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1): AssertionPlant<R>\n        = returnValueOf1(plant, {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }, arg1, method.name)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }, arg1, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, R : Any> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf1(plant, method, arg1, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf1\")\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: KFunction2<T, T1, R>, arg1: T1): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1) -> R = {a1 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1) }\n        return returnValueOf1(plant, l, arg1, method.name)\n    }\n\n    inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n        = returnValueOf1(plant, method, arg1, method.name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, name)\n\n    override inline fun <T : Any, T1, R : Any?> returnValueOf1(plant: AssertionPlant<T>, noinline method: (T1) -> R, arg1: T1, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf1(plant, method, arg1, representationProvider, name)\n\n\n    //Arg2\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n        = returnValueOf2(plant, {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }, arg1, arg2, method.name)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }, arg1, arg2, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, R : Any> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf2(plant, method, arg1, arg2, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf2\")\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2) -> R = {a1, a2 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2) }\n        return returnValueOf2(plant, l, arg1, arg2, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n        = returnValueOf2(plant, method, arg1, arg2, method.name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, name)\n\n    override inline fun <T : Any, T1, T2, R : Any?> returnValueOf2(plant: AssertionPlant<T>, noinline method: (T1, T2) -> R, arg1: T1, arg2: T2, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf2(plant, method, arg1, arg2, representationProvider, name)\n\n\n    //Arg3\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n        = returnValueOf3(plant, {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }, arg1, arg2, arg3, method.name)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }, arg1, arg2, arg3, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, R : Any> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf3\")\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2, T3) -> R = {a1, a2, a3 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3) }\n        return returnValueOf3(plant, l, arg1, arg2, arg3, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n        = returnValueOf3(plant, method, arg1, arg2, arg3, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, name)\n\n    override inline fun <T : Any, T1, T2, T3, R : Any?> returnValueOf3(plant: AssertionPlant<T>, noinline method: (T1, T2, T3) -> R, arg1: T1, arg2: T2, arg3: T3, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf3(plant, method, arg1, arg2, arg3, representationProvider, name)\n\n\n    //Arg4\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n        = returnValueOf4(plant, {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }, arg1, arg2, arg3, arg4, method.name)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }, arg1, arg2, arg3, arg4, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf4\")\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l : (T1, T2, T3, T4) -> R = {a1, a2, a3, a4 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4) }\n        return returnValueOf4(plant, l, arg1, arg2, arg3, arg4, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n        = returnValueOf4(plant, method, arg1, arg2, arg3, arg4, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, R : Any?> returnValueOf4(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf4(plant, method, arg1, arg2, arg3, arg4, representationProvider, name)\n\n\n    //Arg5\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n        = returnValueOf5(plant, {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String): AssertionPlant<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }, arg1, arg2, arg3, arg4, arg5, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name, assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name).addAssertionsCreatedBy(assertionCreator)\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String, noinline assertionCreator: AssertionPlant<R>.() -> Unit): AssertionPlant<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name).addAssertionsCreatedBy(assertionCreator)\n\n\n    @JvmName(\"safeReturnValueOf5\")\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R> {\n        //TODO get rid of l if https://youtrack.jetbrains.com/issue/KT-23768 is fixed\n        val l: (T1, T2, T3, T4, T5) -> R = {a1, a2, a3, a4, a5 -> @Suppress(\"DEPRECATION\") method(plant.subject, a1, a2, a3, a4, a5) }\n        return returnValueOf5(plant, l, arg1, arg2, arg3, arg4, arg5, method.name)\n    }\n\n    inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n        = returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, method.name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, name)\n\n    override inline fun <T : Any, T1, T2, T3, T4, T5, R : Any?> returnValueOf5(plant: AssertionPlant<T>, noinline method: (T1, T2, T3, T4, T5) -> R, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, noinline representationProvider: () -> Any?, name: String): AssertionPlantNullable<R>\n        = featureAssertions.returnValueOf5(plant, method, arg1, arg2, arg3, arg4, arg5, representationProvider, name)\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.IterableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.IterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.creators.iterableContainsAssertions\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.*\nimport ch.tutteli.atrium.domain.creating.iterableAssertions\n\n/**\n * Delegates inter alia to the implementation of [IterableAssertions].\n * In detail, it implements [IterableAssertions] by delegating to [iterableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableAssertionsBuilder : IterableAssertions {\n\n    override inline fun <E, T : Iterable<E>> containsBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsBuilder(subjectProvider)\n\n    override inline fun <E, T : Iterable<E>> containsNotBuilder(subjectProvider: SubjectProvider<T>) =\n        iterableAssertions.containsNotBuilder(subjectProvider)\n\n    override inline fun <E : Any, T : Iterable<E?>> all(\n        assertionContainer: Expect<T>,\n        noinline assertionCreator: (Expect<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(assertionContainer, assertionCreator)\n\n\n    override inline fun <E, T : Iterable<E>> hasNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNext(expect)\n\n    override inline fun <E, T : Iterable<E>> hasNotNext(expect: Expect<T>): Assertion =\n        iterableAssertions.hasNotNext(expect)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> min(assertionContainer: Expect<T>): ExtractedFeaturePostStep<T, E> =\n        iterableAssertions.min(assertionContainer)\n\n    override inline fun <E : Comparable<E>, T : Iterable<E>> max(assertionContainer: Expect<T>) =\n        iterableAssertions.max(assertionContainer)\n\n    /**\n     * Returns [IterableContainsAssertionsBuilder]\n     * which inter alia delegates to the implementation of [IterableContainsAssertions].\n     */\n    inline val contains get() = IterableContainsAssertionsBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any> all(\n        plant: AssertionPlant<Iterable<E?>>,\n        noinline assertionCreator: (AssertionPlant<E>.() -> Unit)?\n    ): Assertion = iterableAssertions.all(plant, assertionCreator)\n}\n\n/**\n * Delegates inter alia to the implementation of [IterableContainsAssertions].\n * In detail, it implements [IterableContainsAssertions] by delegating to [iterableContainsAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableContainsAssertionsBuilder : IterableContainsAssertions {\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrder(checkerOption, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrder(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrder(checkerOption, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInAnyOrderOnly(\n        builder: IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInAnyOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnly(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnly(\n        builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>,\n        expected: List<E>\n    ) = iterableContainsAssertions.valuesInOrderOnly(builder, expected)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnly(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(Expect<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnly(builder, assertionCreators)\n\n    override inline fun <E, T : Iterable<E>> valuesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<E>>\n    ): Assertion = iterableContainsAssertions.valuesInOrderOnlyGrouped(builder, groups)\n\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGrouped(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(Expect<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGrouped(builder, groups)\n\n\n    /**\n     * Returns [IterableContainsSearchBehaviourFactoryBuilder]\n     * which inter alia delegates to the implementation of [SearchBehaviourFactory].\n     */\n    inline val searchBehaviours get() = IterableContainsSearchBehaviourFactoryBuilder\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderWithAssert(\n        checkerOption: IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderWithAssert(checkerOption, assertionCreators)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInAnyOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInAnyOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>,\n        assertionCreators: List<(AssertionPlant<E>.() -> Unit)?>\n    ) = iterableContainsAssertions.entriesInOrderOnlyWithAssert(builder, assertionCreators)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <E : Any, T : Iterable<E?>> entriesInOrderOnlyGroupedWithAssert(\n        builder: IterableContains.Builder<E?, T, InOrderOnlyGroupedSearchBehaviour>,\n        groups: List<List<(AssertionPlant<E>.() -> Unit)?>>\n    ): Assertion = iterableContainsAssertions.entriesInOrderOnlyGroupedWithAssert(builder, groups)\n}\n\n/**\n * Delegates inter alia to the implementation of [SearchBehaviourFactory].\n * In detail, it implements [SearchBehaviourFactory] by delegating to [searchBehaviourFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject IterableContainsSearchBehaviourFactoryBuilder : SearchBehaviourFactory {\n\n    override inline fun <E, T : Iterable<E>> inAnyOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inAnyOrderOnly(builder: IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>) =\n        searchBehaviourFactory.inAnyOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrder(builder: IterableContains.Builder<E, T, NoOpSearchBehaviour>) =\n        searchBehaviourFactory.inOrder(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnly(builder: IterableContains.Builder<E, T, InOrderSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnly(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGrouped(builder: IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGrouped(builder)\n\n    override inline fun <E, T : Iterable<E>> inOrderOnlyGroupedWithin(builder: IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>) =\n        searchBehaviourFactory.inOrderOnlyGroupedWithin(builder)\n\n}\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.creating.ThrowableAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ChangedSubjectPostStep\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.ThrowableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.creators.throwableThrownAssertions\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.providers.absentThrowableMessageProviderFactory\nimport ch.tutteli.atrium.domain.creating.throwableAssertions\nimport ch.tutteli.atrium.reporting.Reporter\nimport ch.tutteli.atrium.reporting.translating.Translatable\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [ThrowableAssertions].\n * In detail, it implements [ThrowableAssertions] by delegating to [throwableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ThrowableAssertionsBuilder : ThrowableAssertions {\n\n    override inline fun thrownBuilder(\n        assertionVerb: Translatable,\n        noinline act: () -> Unit,\n        reporter: Reporter\n    ): ThrowableThrown.Builder = throwableAssertions.thrownBuilder(assertionVerb, act, reporter)\n\n    /**\n     * Returns [ThrowableThrownAssertionsBuilder]\n     * which inter alia delegates to the implementation of [ThrowableThrownAssertions].\n     */\n    inline val thrown get() = ThrowableThrownAssertionsBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ThrowableThrownAssertions].\n * In detail, it implements [ThrowableThrownAssertions] by delegating to [throwableThrownAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ThrowableThrownAssertionsBuilder : ThrowableThrownAssertions {\n\n    override inline fun <TExpected : Throwable> isA(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>\n    ) = throwableThrownAssertions.isA(throwableThrownBuilder, expectedType)\n\n    override inline fun notThrown(\n        throwableThrownBuilder: ThrowableThrown.Builder\n    ): ChangedSubjectPostStep<Throwable?, Nothing?> = throwableThrownAssertions.notThrown(throwableThrownBuilder)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <TExpected : Throwable> toBe(\n        throwableThrownBuilder: ThrowableThrown.Builder,\n        expectedType: KClass<TExpected>,\n        noinline assertionCreator: AssertionPlant<TExpected>.() -> Unit\n    ) = throwableThrownAssertions.toBe(throwableThrownBuilder, expectedType, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun nothingThrown(throwableThrownBuilder: ThrowableThrown.Builder) =\n        throwableThrownAssertions.nothingThrown(throwableThrownBuilder)\n\n    /**\n     * Returns [AbsentThrowableMessageProviderFactoryBuilder]\n     * which inter alia delegates to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n     */\n    @Suppress(\"DeprecatedCallableAddReplaceWith\", \"DEPRECATION\")\n    @Deprecated(\"Will be removed with 1.0.0\")\n    inline val providers\n        get() = AbsentThrowableMessageProviderFactoryBuilder\n}\n\n/**\n * Delegates inter alia to the implementation of [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory].\n * In detail, it implements [ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory] by delegating to [absentThrowableMessageProviderFactory]\n * which in turn delegates to the implementation via [loadSingleService].\n */\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Will be removed with 1.0.0\")\nobject AbsentThrowableMessageProviderFactoryBuilder :\n    ch.tutteli.atrium.domain.creating.throwable.thrown.providers.AbsentThrowableMessageProviderFactory {\n\n    override inline fun translatableBased(translatable: Translatable): ThrowableThrown.AbsentThrowableMessageProvider =\n        absentThrowableMessageProviderFactory.translatableBased(translatable)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"AnyAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.checking.AssertionChecker\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.reporting.Reporter\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is (equal to) [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `esGilt(1).ist(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any> Assert<T>.ist(expected: T)\n    = addAssertion(AssertImpl.any.toBe(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not (equal to) [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `esGilt(1).istNicht(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any> Assert<T>.istNicht(expected: T)\n    = addAssertion(AssertImpl.any.notToBe(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is the same instance as [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `esGilt(1).istSelbeInstanzWie(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any> Assert<T>.istSelbeInstanzWie(expected: T)\n    = addAssertion(AssertImpl.any.isSame(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not the same instance as [expected].\n *\n * This method might enforce in the future, that [expected] has to be the same type as [Assert.subject][SubjectProvider.subject].\n * Currently the following is possible: `esGilt(1).istNichtSelbeInstanzWie(1.0)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any> Assert<T>.istNichtSelbeInstanzWie(expected: T)\n    = addAssertion(AssertImpl.any.isNotSame(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is [expected].\n *\n * @return Does not support a fluent API because: what else would you want to assert about `null` anyway?\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\ninline fun <reified T : Any> AssertionPlantNullable<T?>.ist(expected: T?) {\n    addAssertion(AssertImpl.any.isNullable(this, T::class, expected))\n}\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is either `null` if [assertionCreatorOrNull]\n * is null or is not `null` and holds all assertions [assertionCreatorOrNull] might create.\n *\n * It is a shortcut for\n * ```kotlin\n * if(nullOrExpected == null) ist(null)\n * else istNichtNull(assertionCreatorOrNull)\n * ```\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\ninline fun <reified T : Any> AssertionPlantNullable<T?>.istNullWennNullGegebenSonst(noinline assertionCreatorOrNull: (Assert<T>.() -> Unit)?) {\n    addAssertion(AssertImpl.any.isNullIfNullGivenElse(this, T::class, assertionCreatorOrNull))\n}\n\n/**\n * Can be used to separate assertions when using the fluent API.\n *\n * For instance `esGilt(1).istKleinerAls(2).und.istGroesserAls(0)` creates\n * two assertions (not one assertion with two sub-assertions) - the first asserts that 1 is less than 2 and a second\n * asserts that 1 is greater than 0. If the first assertion fails, then usually (depending on the configured\n * [AssertionChecker]) the second assertion is not evaluated.\n *\n * @return This plant to support a fluent API.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <T : Any> Assert<T>.und: Assert<T> get() = this\n\n/**\n * Can be used to create a group of sub assertions when using the fluent API.\n *\n * For instance `esGilt(1).istKleinerAls(3).und { istGerade(); istKleinerAls(1) }` creates\n * two assertions where the second one consists of two sub-assertions. In case the first assertion holds, then the\n * second one is evaluated as a whole. Meaning, even though 1 is not even, it still evaluates that 1 is greater than 1.\n * Hence the reporting might (depending on the configured [Reporter]) contain both failing sub-assertions.\n *\n * @return This plant to support a fluent API.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\ninfix fun <T : Any> AssertionPlant<T>.und(assertionCreator: Assert<T>.() -> Unit)\n    = addAssertionsCreatedBy(assertionCreator)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\nimport kotlin.jvm.JvmName\n\n/**\n * Turns `Assert<Array<E>>` into `Assert<Iterable<E>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Array<out E>::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <E> Assert<Array<out E>>.asIterable(): Assert<Iterable<E>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<Array<E>>` into `Assert<Iterable<E>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Array<out E>::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E> Assert<Array<out E>>.asIterable(assertionCreator: Assert<Iterable<E>>.() -> Unit): Assert<Iterable<E>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Byte>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ByteArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [Assert] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\n@JvmName(\"byteArrAsIterable\")\nfun Assert<ByteArray>.asIterable(): Assert<Iterable<Byte>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Byte>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ByteArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [Assert] for the transformed subject.\n */\n@JvmName(\"byteArrAsIterable\")\nfun Assert<ByteArray>.asIterable(assertionCreator: Assert<Iterable<Byte>>.() -> Unit): Assert<Iterable<Byte>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Char>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(CharArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Suppress(\"DEPRECATION\")\n@JvmName(\"charArrAsIterable\")\nfun Assert<CharArray>.asIterable(): Assert<Iterable<Char>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<CharArray>` into `Assert<Iterable<Char>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(CharArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"charArrAsIterable\")\nfun Assert<CharArray>.asIterable(assertionCreator: Assert<Iterable<Char>>.() -> Unit): Assert<Iterable<Char>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<ShortArray>` into `Assert<Iterable<Short>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ShortArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\n@JvmName(\"shortArrAsIterable\")\nfun Assert<ShortArray>.asIterable(): Assert<Iterable<Short>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<ShortArray>` into `Assert<Iterable<Short>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(ShortArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"shortArrAsIterable\")\nfun Assert<ShortArray>.asIterable(assertionCreator: Assert<Iterable<Short>>.() -> Unit): Assert<Iterable<Short>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<IntArray>` into `Assert<Iterable<Int>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(IntArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\n@JvmName(\"intArrAsIterable\")\nfun Assert<IntArray>.asIterable(): Assert<Iterable<Int>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<IntArray>` into `Assert<Iterable<Int>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(IntArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"intArrAsIterable\")\nfun Assert<IntArray>.asIterable(assertionCreator: Assert<Iterable<Int>>.() -> Unit): Assert<Iterable<Int>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<LongArray>` into `Assert<Iterable<Double>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(LongArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\n@JvmName(\"longArrAsIterable\")\nfun Assert<LongArray>.asIterable(): Assert<Iterable<Long>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<LongArray>` into `Assert<Iterable<Double>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(LongArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"longArrAsIterable\")\nfun Assert<LongArray>.asIterable(assertionCreator: Assert<Iterable<Long>>.() -> Unit): Assert<Iterable<Long>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<FloatArray>` into `Assert<Iterable<Float>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(FloatArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\n@JvmName(\"floatArrAsIterable\")\nfun Assert<FloatArray>.asIterable(): Assert<Iterable<Float>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<FloatArray>` into `Assert<Iterable<Float>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(FloatArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"floatArrAsIterable\")\nfun Assert<FloatArray>.asIterable(assertionCreator: Assert<Iterable<Float>>.() -> Unit): Assert<Iterable<Float>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<DoubleArray>` into `Assert<Iterable<Double>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(DoubleArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\n@JvmName(\"doubleArrAsIterable\")\nfun Assert<DoubleArray>.asIterable(): Assert<Iterable<Double>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<DoubleArray>` into `Assert<Iterable<Double>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(DoubleArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"doubleArrAsIterable\")\nfun Assert<DoubleArray>.asIterable(assertionCreator: Assert<Iterable<Double>>.() -> Unit): Assert<Iterable<Double>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n\n\n/**\n * Turns `Assert<BooleanArray>` into `Assert<Iterable<Boolean>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(BooleanArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\n@JvmName(\"boolArrAsIterable\")\nfun Assert<BooleanArray>.asIterable(): Assert<Iterable<Boolean>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n\n/**\n * Turns `Assert<BooleanArray>` into `Assert<Iterable<Boolean>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(BooleanArray::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"boolArrAsIterable\")\nfun Assert<BooleanArray>.asIterable(assertionCreator: Assert<Iterable<Boolean>>.() -> Unit): Assert<Iterable<Boolean>>\n    = asIterable().addAssertionsCreatedBy(assertionCreator)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"CharSequenceAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NotSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Creates a [CharSequenceContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <T : CharSequence> Assert<T>.enthaelt: CharSequenceContains.Builder<T, NoOpSearchBehaviour>\n    get() = AssertImpl.charSequence.containsBuilder(this)\n\n/**\n * Creates a [CharSequenceContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains not` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <T : CharSequence> Assert<T>.enthaeltNicht: NotCheckerOption<T, NotSearchBehaviour>\n    get() = NotCheckerOptionImpl(AssertImpl.charSequence.containsNotBuilder(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains [expected]'s [toString] representation\n * and the [toString] representation of the [otherExpected] (if given), using a non disjoint search.\n *\n * It is a shortcut for `enthaelt.zumindest(1).werte(expected, *otherExpected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search. Use the property `enthaelt` to create a more sophisticated `contains`\n * assertion where you can use options such as [zumindest], [hoechstens] and [genau] to control the number of\n * occurrences you expect.\n *\n * Meaning you might want to use:\n *   `enthaelt.genau(2).wert('a')`\n * instead of:\n *   `enthaelt('a', 'a')`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.enthaelt(expected: Any, vararg otherExpected: Any)\n    = enthaelt.zumindest(1).werte(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain [expected]'s [toString] representation\n * and neither one of the [otherExpected]'s [toString] representation (if given).\n *\n * It is a shortcut for `enthaeltNicht.werte(expected, *otherExpected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.enthaeltNicht(expected: Any, vararg otherExpected: Any)\n    = enthaeltNicht.werte(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a sequence which matches the given regular expression\n * [pattern] as well as the [otherPatterns] (if given), using a non disjoint search.\n *\n * It is a shortcut for `enthaelt.zumindest(1).regex(pattern, *otherPatterns)`.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [zumindest], [hoechstens] and [genau]\n * to control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `enthaelt.genau(2).regex('a(b)?')`\n * instead of:\n *   `enthaelt.zumindest(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.enthaeltRegex(\n    pattern: String,\n    vararg otherPatterns: String\n) = enthaelt.zumindest(1).regex(pattern, *otherPatterns)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] starts with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.beginntMit(expected: CharSequence)\n    = addAssertion(AssertImpl.charSequence.startsWith(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not start with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.beginntNichtMit(expected: CharSequence)\n    = addAssertion(AssertImpl.charSequence.startsNotWith(this, expected))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] ends with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.endetMit(expected: CharSequence)\n    = addAssertion(AssertImpl.charSequence.endsWith(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not end with [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.endetNichtMit(expected: CharSequence)\n    = addAssertion(AssertImpl.charSequence.endsNotWith(this, expected))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isEmpty].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.istLeer()\n    = addAssertion(AssertImpl.charSequence.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isNotEmpty].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.istNichtLeer()\n    = addAssertion(AssertImpl.charSequence.isNotEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] [CharSequence].[kotlin.text.isNotBlank].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> Assert<T>.istNichtBlank()\n    = addAssertion(AssertImpl.charSequence.isNotBlank(this))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"CharSequenceContainsCheckersKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.*\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl.*\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains.SearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we are looking\n * for occurs `at least` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.zumindest(times: Int): AtLeastCheckerOption<T, S>\n    = AtLeastCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains at least` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `at most` number of [times] within the search input.\n *\n * The resulting restriction will be a `contains at least but at most` assertion.\n *\n * @param times The number which the check will compare against the number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n * @throws IllegalArgumentException In case [times] of this `at most` restriction equals to the number of the\n *   `at least` restriction; use the [genau] restriction instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence, S : SearchBehaviour> AtLeastCheckerOption<T, S>.aberHoechstens(times: Int): ButAtMostCheckerOption<T, S>\n    = ButAtMostCheckerOptionImpl(times, this, containsBuilder)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `exactly` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.genau(times: Int): ExactlyCheckerOption<T, S>\n    = ExactlyCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `at least` once but `at most` number of [times] within the search input.\n *\n * If you want to use a higher lower bound than one, then use `zumindest(2).aberHoechstens(3)` instead of\n * `hoechstens(3)`. And in case you want to state that it is either not contained at all or at most a certain\n * number of times, then use `nichtOderHoechstens(2)` instead.\n *\n * @param times The number which the check will compare against the number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n * @throws IllegalArgumentException In case [times] equals to one; use [genau] instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.hoechstens(times: Int): AtMostCheckerOption<T, S>\n    = AtMostCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the value which we\n * are looking for occurs `not at all or at most` number of [times] within the search input.\n *\n * @param times The number which the check will compare against the number of times an expected value is\n *   found in the input of the search.\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence, S : SearchBehaviour> CharSequenceContains.Builder<T, S>.nichtOderHoechstens(times: Int): NotOrAtMostCheckerOption<T, S>\n    = NotOrAtMostCheckerOptionImpl(times, this)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"CharSequenceContainsCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.kbox.glue\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value shall be searched,\n * using a non disjoint search.\n *\n * Delegates to `werte(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.wert(expected: Any): AssertionPlant<T>\n    = werte(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value as well as\n * the [otherExpected] values shall be searched, using a non disjoint search.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n * @param otherExpected Additional values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.werte(expected: Any, vararg otherExpected: Any): AssertionPlant<T>\n    = addAssertion(AssertImpl.charSequence.contains.values(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value shall be searched\n * (ignoring case), using a non disjoint search.\n *\n * Delegates to `werte(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"wertGrossKleinschreibungIgnorierend\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.wert(expected: Any): AssertionPlant<T>\n    = werte(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value as well as\n * the [otherExpected] values shall be searched (ignoring case), using a non disjoint search.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n * @param otherExpected Additional values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"werteGrossKleinschreibungIgnorierend\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.werte(expected: Any, vararg otherExpected: Any): AssertionPlant<T>\n    = addAssertion(AssertImpl.charSequence.contains.valuesIgnoringCase(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value shall be searched\n * (ignoring case), using a non disjoint search where it needs to be contained at least once.\n *\n * Delegates to `zumindest(1).wert(expected)`.\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that 'aa' in 'aaaa' is found three times and not only two times.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] is not a [CharSequence], [Number] or [Char].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.wert(expected: Any): AssertionPlant<T>\n    = zumindest(1).wert(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected] value as well as\n * the [otherExpected] values shall be searched (ignoring case), using a non disjoint search\n * where each need to be contained at least once.\n *\n * Delegates to `zumindest(1).werte(expected, otherExpected)`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed (this\n * function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'a'` and [expected]\n * is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match, even though they match the\n * same sequence in the input of the search.\n *\n * @param expected The value which is expected to be contained within the input of the search.\n * @param otherExpected Additional values which are expected to be contained within the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n * @throws IllegalArgumentException in case [expected] or one of the [otherExpected] is not a\n *   [CharSequence], [Number] or [Char].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.werte(expected: Any, vararg otherExpected: Any): AssertionPlant<T>\n    = zumindest(1).werte(expected, *otherExpected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * as well as the [otherPatterns] are expected to have a match, using a non disjoint search.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [zumindest], [hoechstens] and [genau]\n * to control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `enthaelt.genau(2).regex('a(b)?')`\n * instead of:\n *   `enthaelt.zumindest(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, NoOpSearchBehaviour>.regex(pattern: String, vararg otherPatterns: String): AssertionPlant<T>\n    = addAssertion(AssertImpl.charSequence.contains.regex(this, pattern glue otherPatterns))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * as well as the [otherPatterns] are expected to have a match (ignoring case), using a non disjoint search.\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [zumindest], [hoechstens] and [genau]\n * to control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `enthaelt.ignoriereGrossKleinschreibung.genau(2).regex('a(b)?')`\n * instead of:\n *   `enthaelt.ignoriereGrossKleinschreibung.zumindest(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"regexIgnoringCase\")\nfun <T : CharSequence> CharSequenceContains.CheckerOption<T, IgnoringCaseSearchBehaviour>.regex(pattern: String, vararg otherPatterns: String): AssertionPlant<T>\n    = addAssertion(AssertImpl.charSequence.contains.regexIgnoringCase(this, pattern glue otherPatterns))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the given regular expression [pattern]\n * as well as the [otherPatterns] are expected to to have at least one match (ignoring case),\n * using a non disjoint search.\n *\n * Delegates to `zumindest(1).regex(pattern, otherPatterns)`\n *\n * By non disjoint is meant that `'aa'` in `'aaaa'` is found three times and not only two times.\n * Also notice, that it does not search for unique matches. Meaning, if the input of the search is `'ab'` and [pattern]\n * is defined as `'a(b)?'` and one of the [otherPatterns] is defined as `'a(b)?'` as well, then both match, even though\n * they match the same sequence in the input of the search. Use an option such as [zumindest], [hoechstens] and [genau]\n * to control the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `enthaelt.ignoriereGrossKleinschreibung.genau(2).regex('a(b)?')`\n * instead of:\n *   `enthaelt.ignoriereGrossKleinschreibung.zumindest(1).regex('a(b)?', 'a(b)?')`\n *\n * @param pattern The pattern which is expected to have a match against the input of the search.\n * @param otherPatterns Additional patterns which are expected to have a match against the input of the search.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : CharSequence> CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>.regex(pattern: String, vararg otherPatterns: String): AssertionPlant<T>\n    = zumindest(1).regex(pattern, *otherPatterns)\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nprivate fun <T : CharSequence, S : CharSequenceContains.SearchBehaviour> CharSequenceContains.CheckerOption<T, S>.addAssertion(assertion: Assertion): AssertionPlant<T>\n    = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"CharSequenceContainsDecoratorsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.IgnoringCaseSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.searchbehaviours.NotSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Defines that the search behaviour `ignore case` shall be applied to this sophisticated `contains` assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <T : CharSequence> CharSequenceContains.Builder<T, NoOpSearchBehaviour>.ignoriereGrossKleinschreibung\n    get() : CharSequenceContains.Builder<T, IgnoringCaseSearchBehaviour>\n    = AssertImpl.charSequence.contains.searchBehaviours.ignoringCase(this)\n/**\n * Defines that the search behaviour `ignore case` shall be applied to this sophisticated `contains not` assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <T : CharSequence> NotCheckerOption<T, NotSearchBehaviour>.ignoriereGrossKleinschreibung\n    get() : NotCheckerOption<T, IgnoringCaseSearchBehaviour>\n    = NotCheckerOptionImpl(containsBuilder.ignoriereGrossKleinschreibung)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Collection.size] is [size].\n *\n * Shortcut for `size.ist(expectedSize)` depends on the underlying implementation though.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <T : Collection<*>> Assert<T>.hatDieGroesse(size: Int)\n    = addAssertion(AssertImpl.collection.hasSize(this, size))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is an empty [Collection].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Collection<*>> Assert<T>.istLeer()\n    = addAssertion(AssertImpl.collection.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not an empty [Collection].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Collection<*>> Assert<T>.istNichtLeer()\n    = addAssertion(AssertImpl.collection.isNotEmpty(this))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property\n * [size][Collection.size] so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval Assert<Collection<*>>.size get(): Assert<Int> = property(Collection<*>::size)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [size][Collection.size]\n * holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <E, T: Collection<E>> Assert<T>.size (assertionCreator: Assert<Int>.() -> Unit): Assert<T>\n    = addAssertion(AssertImpl.collection.size(this, assertionCreator))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.CollectionAssertions\nimport ch.tutteli.atrium.domain.creating.collectionAssertions\n\n/**\n * Delegates inter alia to the implementation of [CollectionAssertions].\n * In detail, it implements [CollectionAssertions] by delegating to [collectionAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject CollectionAssertionsBuilder : CollectionAssertions {\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isEmpty(subjectProvider)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Collection<*>>) =\n        collectionAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Collection<*>> size(assertionContainer: Expect<T>) =\n        collectionAssertions.size(assertionContainer)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Collection<*>>, size: Int) =\n        collectionAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun size(plant: AssertionPlant<Collection<*>>, noinline assertionCreator: Assert<Int>.() -> Unit) =\n        collectionAssertions.size(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is less than [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Comparable<T>> Assert<T>.istKleinerAls(expected: T)\n    = addAssertion(AssertImpl.comparable.isLessThan(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is less than or equals [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Comparable<T>> Assert<T>.istKleinerOderGleich(expected: T)\n    = addAssertion(AssertImpl.comparable.isLessOrEquals(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is greater than [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Comparable<T>> Assert<T>.istGroesserAls(expected: T)\n    = addAssertion(AssertImpl.comparable.isGreaterThan(this, expected))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is greater than or equals [expected].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Comparable<T>> Assert<T>.istGroesserOderGleich(expected: T)\n    = addAssertion(AssertImpl.comparable.isGreaterOrEquals(this, expected))\n\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.ComparableAssertions\nimport ch.tutteli.atrium.domain.creating.comparableAssertions\n\n/**\n * Delegates inter alia to the implementation of [ComparableAssertions].\n * In detail, it implements [ComparableAssertions] by delegating to [comparableAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ComparableAssertionsBuilder : ComparableAssertions {\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isLessOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isLessOrEquals(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterThan(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterThan(subjectProvider, expected)\n\n    override inline fun <T1 : Comparable<T2>, T2 : Any?> isGreaterOrEquals(\n        subjectProvider: SubjectProvider<T1>,\n        expected: T2\n    ) = comparableAssertions.isGreaterOrEquals(subjectProvider, expected)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.zumindest\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.AtLeastCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains at least`-check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"AtLeastCheckerBuilder\"))\nopen class AtLeastCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : AtLeastCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::zumindest.name}($it)\" }\n), AtLeastCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.AtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.genau\nimport ch.tutteli.atrium.api.cc.de_CH.hoechstens\nimport ch.tutteli.atrium.api.cc.de_CH.zumindest\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.AtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"AtMostCheckerBuilder\"))\nopen class AtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : AtMostCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::hoechstens.name}($it)\" },\n    { \"${containsBuilder::zumindest.name}($it)\" },\n    { \"${containsBuilder::genau.name}($it)\" }\n), AtMostCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.aberHoechstens\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.ButAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.genau\nimport ch.tutteli.atrium.api.cc.de_CH.hoechstens\nimport ch.tutteli.atrium.api.cc.de_CH.zumindest\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.ButAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied to the input of the search.\n *\n * @constructor Represents the builder of the second step of a `contains at least but at most` check within the\n *   fluent API of a sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"ButAtMostCheckerBuilder\"))\nopen class ButAtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    atLeastBuilder: AtLeastCheckerOption<T, S>,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : ButAtMostCheckerOptionBase<T, S>(\n    times,\n    atLeastBuilder,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { l, u -> \"${containsBuilder::zumindest.name}($l).${atLeastBuilder::aberHoechstens.name}($u)\" },\n    { \"${containsBuilder::hoechstens.name}($it)\" },\n    { \"${containsBuilder::zumindest.name}($it)\" },\n    { \"${atLeastBuilder::aberHoechstens.name}($it)\" },\n    { \"${containsBuilder::genau.name}($it)\" }\n), ButAtMostCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.ExactlyCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.genau\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.ExactlyCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"ExactlyCheckerBuilder\"))\nopen class ExactlyCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : ExactlyCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::genau.name}($it)\" }\n), ExactlyCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.NotCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n *  Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n * `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n *   `contains` assertion for [CharSequence].\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"NotCheckerBuilder\"))\nopen class NotCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : NotCheckerOptionBase<T, S>(containsBuilder),\n    NotCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.NotOrAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.nichtOderHoechstens\nimport ch.tutteli.atrium.domain.builders.creating.charsequence.contains.builders.NotOrAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\n\n/**\n * Represents the builder of a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [CharSequence].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not or at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [CharSequence].\n * @param times The number which the check will compare against the actual number of times an expected object is\n *   found in the input of the search.\n * @param containsBuilder The previously used [CharSequenceContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"NotOrAtMostCheckerBuilder\"))\nopen class NotOrAtMostCheckerOptionImpl<out T : CharSequence, out S : CharSequenceContains.SearchBehaviour>(\n    times: Int,\n    containsBuilder: CharSequenceContains.Builder<T, S>\n) : NotOrAtMostCheckerOptionBase<T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::nichtOderHoechstens.name}($it)\" }\n), NotOrAtMostCheckerOption<T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.charsequence.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.enthaeltNicht\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport kotlin.reflect.KFunction3\n\ninternal fun nameContainsNotValuesFun(): String {\n    val f: KFunction3<AssertionPlant<CharSequence>, Any, Array<out Any>, AssertionPlant<CharSequence>> = AssertionPlant<CharSequence>::enthaeltNicht\n    return f.name\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.zumindest\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.AtLeastCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least` check within the fluent API of a sophisticated\n *   `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"AtLeastCheckerBuilder\"))\nopen class AtLeastCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : AtLeastCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::zumindest.name}($it)\" }\n), AtLeastCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.AtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.genau\nimport ch.tutteli.atrium.api.cc.de_CH.hoechstens\nimport ch.tutteli.atrium.api.cc.de_CH.zumindest\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.AtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains at least once but at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"AtMostCheckerBuilder\"))\nopen class AtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : AtMostCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::hoechstens.name}($it)\" },\n    { \"${containsBuilder::zumindest.name}($it)\" },\n    { \"${containsBuilder::genau.name}($it)\" }\n), AtMostCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.aberHoechstens\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.AtLeastCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.ButAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.genau\nimport ch.tutteli.atrium.api.cc.de_CH.hoechstens\nimport ch.tutteli.atrium.api.cc.de_CH.zumindest\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.ButAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of the second step of a `contains at least but at most` check within the\n * fluent API of a sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of the second step of a `contains at least but at most` check within the\n *   fluent API of a sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"ButAtMostCheckerBuilder\"))\nopen class ButAtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    atLeastBuilder: AtLeastCheckerOption<E, T, S>,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : ButAtMostCheckerOptionBase<E, T, S>(\n    times,\n    atLeastBuilder,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { l, u -> \"${containsBuilder::zumindest.name}($l).${atLeastBuilder::aberHoechstens.name}($u)\" },\n    { \"${containsBuilder::hoechstens.name}($it)\" },\n    { \"${containsBuilder::zumindest.name}($it)\" },\n    { \"${atLeastBuilder::aberHoechstens.name}($it)\" },\n    { \"${containsBuilder::genau.name}($it)\" }\n), ButAtMostCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.ExactlyCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.genau\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.ExactlyCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains exactly` check within the fluent API of a sophisticated\n *   `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"ExactlyCheckerBuilder\"))\nopen class ExactlyCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : ExactlyCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::genau.name}($it)\" }\n), ExactlyCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.NotCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n * `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n * @param S The search behaviour which should be applied for the input of the search.\n *\n * @constructor Represents the builder of a `contains not at all` check within the fluent API of a sophisticated\n *   `contains not` assertion for [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"NotCheckerBuilder\"))\nopen class NotCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : NotCheckerOptionBase<E, T, S>(containsBuilder),\n    NotCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.NotOrAtMostCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.nichtOderHoechstens\nimport ch.tutteli.atrium.domain.builders.creating.iterable.contains.builders.NotOrAtMostCheckerOptionBase\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\n\n/**\n * Represents the builder of a `contains not or at most` check within the fluent API of a\n * sophisticated `contains` assertion for [Iterable].\n *\n * @param T The input type of the search.\n *\n * @constructor Represents the builder of a `contains at least once but at most` check within the fluent API of a\n *   sophisticated `contains` assertion for [Iterable].\n * @param times The number which the check will compare against the actual number of times an expected entry is\n *   found in the [Iterable].\n * @param containsBuilder The previously used [IterableContains.Builder].\n */\n@Deprecated(\"Do not rely on this type; will be made internal with 1.0.0\", ReplaceWith(\"NotOrAtMostCheckerBuilder\"))\nopen class NotOrAtMostCheckerOptionImpl<out E, out T : Iterable<E>, out S : InAnyOrderSearchBehaviour>(\n    times: Int,\n    containsBuilder: IterableContains.Builder<E, T, S>\n) : NotOrAtMostCheckerOptionBase<E, T, S>(\n    times,\n    containsBuilder,\n    nameContainsNotValuesFun(),\n    { \"${containsBuilder::nichtOderHoechstens.name}($it)\" }\n), NotOrAtMostCheckerOption<E, T, S>\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.impl\n\nimport ch.tutteli.atrium.api.cc.de_CH.enthaeltNicht\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport kotlin.reflect.KFunction3\n\ninternal fun nameContainsNotValuesFun(): String {\n    val f: KFunction3<AssertionPlant<Iterable<Double>>, Double, Array<out Double>, AssertionPlant<Iterable<Double>>> = AssertionPlant<Iterable<Double>>::enthaeltNicht\n    return f.name\n}\n","\n@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)package ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.assertions.AssertionGroup\nimport ch.tutteli.atrium.assertions.FeatureAssertionGroupType\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.PleaseUseReplacementException\nimport kotlin.jvm.JvmName\nimport kotlin.reflect.*\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlant] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty0<TProperty>): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>): AssertionPlant<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlant] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty1<T, TProperty>): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant --\n * starting with a group consisting of the [Assertion]s created by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the given [property].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty0<TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant --\n * starting with a group consisting of the [Assertion]s created by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the given [property].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, TProperty : Any> Assert<T>.property(property: KProperty1<T, TProperty>, assertionCreator: Assert<TProperty>.() -> Unit): AssertionPlant<TProperty>\n    = AssertImpl.feature.property(this, property, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, TProperty : Any?> Assert<T>.property(property: KProperty0<TProperty>): AssertionPlantNullable<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, TProperty : Any?> CollectingAssertionPlant<T>.property(property: KProperty0<TProperty>): AssertionPlantNullable<TProperty>\n    = throw PleaseUseReplacementException(\"Use the overload with KProperty1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable] for the given [property] which eventually adds [AssertionGroup]s with a\n * [FeatureAssertionGroupType], containing the assertions created for the given [property], to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\nfun <T : Any, TProperty : Any?> Assert<T>.property(property: KProperty1<T, TProperty>): AssertionPlantNullable<TProperty>\n    = AssertImpl.feature.property(this, property)\n\n\n// Arg 0 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds [AssertionGroup]s\n * with a [FeatureAssertionGroupType], containing the assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, R : Any> Assert<T>.rueckgabewertVon(method: KFunction0<R>): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction0<R>): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds [AssertionGroup]s\n * with a [FeatureAssertionGroupType], containing the assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, R : Any> Assert<T>.rueckgabewertVon(method: KFunction1<T, R>): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, R : Any> Assert<T>.rueckgabewertVon(method: KFunction0<R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction0<R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, R : Any> Assert<T>.rueckgabewertVon(method: KFunction1<T, R>, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf0(this, method, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction0<R>): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, R : Any?> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction0<R>): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction1 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction1<T, R>): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf0(this, method)\n\n\n// Arg 1 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, R : Any> Assert<T>.rueckgabewertVon(method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction1<T1, R>, arg1: T1): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, R : Any> Assert<T>.rueckgabewertVon(method: KFunction2<T, T1, R>, arg1: T1): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, R : Any> Assert<T>.rueckgabewertVon(method: KFunction1<T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction1<T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, R : Any> Assert<T>.rueckgabewertVon(method: KFunction2<T, T1, R>, arg1: T1, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, R : Any?> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction1<T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction2 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], which eventually adds\n * [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction2<T, T1, R>, arg1: T1): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf1(this, method, arg1)\n\n\n// Arg 2 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, R : Any> Assert<T>.rueckgabewertVon(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, R : Any> Assert<T>.rueckgabewertVon(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, R : Any> Assert<T>.rueckgabewertVon(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1] and [arg2], which eventually\n * adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for the return value,\n * to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, R : Any> Assert<T>.rueckgabewertVon(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1] and [arg2], which\n * eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, R : Any?> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction2<T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction3 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1] and [arg2], which\n * eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction3<T, T1, T2, R>, arg1: T1, arg2: T2): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf2(this, method, arg1, arg2)\n\n\n// Arg 3 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.rueckgabewertVon(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.rueckgabewertVon(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.rueckgabewertVon(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, T3, R : Any> Assert<T>.rueckgabewertVon(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, T3, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, R : Any?> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction3<T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction4 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2] and [arg3],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created for\n * the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, T3, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction4<T, T1, T2, T3, R>, arg1: T1, arg2: T2, arg3: T3): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf3(this, method, arg1, arg2, arg3)\n\n\n// Arg 4 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.rueckgabewertVon(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.rueckgabewertVon(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.rueckgabewertVon(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3] and [arg4],\n * which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions created\n * for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created by the\n * [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, T3, T4, R : Any> Assert<T>.rueckgabewertVon(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3]\n * and [arg4], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, T3, T4, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, R : Any?> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction4<T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction5 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3]\n * and [arg4], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, T3, T4, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction5<T, T1, T2, T3, T4, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf4(this, method, arg1, arg2, arg3, arg4)\n\n\n// Arg 5 ----------------------------------------------------------------------------\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.rueckgabewertVon(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.rueckgabewertVon(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created\n * by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.rueckgabewertVon(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5, assertionCreator)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlant], for the value returned by calling [method] with [arg1], [arg2], [arg3], [arg4]\n * and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the assertions\n * created for the return value, to the current plant -- starting with a group consisting of the [Assertion]s created\n * by the [assertionCreator] lambda.\n *\n * @return An [AssertionPlant] for the return value of the given [method].\n *\n * @throws AssertionError Might throw an [AssertionError] if an additionally created [Assertion]\n *   (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any> Assert<T>.rueckgabewertVon(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, assertionCreator: Assert<R>.() -> Unit): AssertionPlant<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5, assertionCreator)\n\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3],\n * [arg4] and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the\n * assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\", \"unused\", \"UNUSED_PARAMETER\")\n@Deprecated(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> CollectingAssertionPlant<T>.rueckgabewertVon(method: KFunction5<T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = throw PleaseUseReplacementException(\"Use the overload with KFunction6 instead, this way you do not access `subject` too early. Use `YourClass::property` instead of `subject::property`\")\n\n/**\n * Creates an [AssertionPlantNullable], for the value returned by calling [method] with [arg1], [arg2], [arg3],\n * [arg4] and [arg5], which eventually adds [AssertionGroup]s with a [FeatureAssertionGroupType], containing the\n * assertions created for the return value, to the current plant.\n *\n * @return An [AssertionPlantNullable] for the given [property].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@JvmName(\"sicherRueckgabewertVon\")\nfun <T : Any, T1, T2, T3, T4, T5, R : Any?> Assert<T>.rueckgabewertVon(method: KFunction6<T, T1, T2, T3, T4, T5, R>, arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5): AssertionPlantNullable<R>\n    = AssertImpl.feature.returnValueOf5(this, method, arg1, arg2, arg3, arg4, arg5)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"FloatingPointAssertionsKt\")\n\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is equal to [expected] with an error [tolerance]\n * (range including bounds).\n *\n * It effectively compares the absolute difference between [Assert.subject][SubjectProvider.subject] and [expected] and compares it with\n * the [tolerance]. As long as it is less than or equal the [tolerance] the assertion holds; otherwise it fails.\n * A more mathematical way of expressing the assertion is the following inequality:\n *\n * | [Assert.subject][SubjectProvider.subject] - [expected] | \u2264 [tolerance]\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun Assert<Float>.istMitFehlerToleranz(expected: Float, tolerance: Float)\n    = addAssertion(AssertImpl.floatingPoint.toBeWithErrorTolerance(this, expected, tolerance))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is equal to [expected] with an error [tolerance]\n * (range including bounds).\n *\n * It effectively compares the absolute difference between [Assert.subject][SubjectProvider.subject] and [expected] and compares it with\n * the [tolerance]. As long as it is less than or equal the [tolerance] the assertion holds; otherwise it fails.\n * A more mathematical way of expressing the assertion is the following inequality:\n *\n * | [Assert.subject][SubjectProvider.subject] - [expected] | \u2264 [tolerance]\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun Assert<Double>.istMitFehlerToleranz(expected: Double, tolerance: Double)\n    = addAssertion(AssertImpl.floatingPoint.toBeWithErrorTolerance(this, expected, tolerance))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.creating.FloatingPointAssertions\nimport ch.tutteli.atrium.domain.creating.floatingPointAssertions\n\n/**\n * Delegates inter alia to the implementation of [FloatingPointAssertions].\n * In detail, it implements [FloatingPointAssertions] by delegating to [floatingPointAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nactual object FloatingPointAssertionsBuilder : FloatingPointAssertions {\n\n    override inline fun toBeWithErrorTolerance(\n        subjectProvider: SubjectProvider<Float>,\n        expected: Float,\n        tolerance: Float\n    ) = floatingPointAssertions.toBeWithErrorTolerance(subjectProvider, expected, tolerance)\n\n    override inline fun toBeWithErrorTolerance(\n        subjectProvider: SubjectProvider<Double>,\n        expected: Double,\n        tolerance: Double\n    ) = floatingPointAssertions.toBeWithErrorTolerance(subjectProvider, expected, tolerance)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.NotCheckerOption\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.impl.NotCheckerOptionImpl\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NoOpSearchBehaviour\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.NotSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Creates an [IterableContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <E, T : Iterable<E>> Assert<T>.enthaelt: IterableContains.Builder<E, T, NoOpSearchBehaviour>\n    get() = AssertImpl.iterable.containsBuilder(this)\n\n/**\n * Creates an [IterableContains.Builder] based on this [AssertionPlant] which allows to define\n * more sophisticated `contains not` assertions.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <E, T : Iterable<E>> Assert<T>.enthaeltNicht: NotCheckerOption<E, T, NotSearchBehaviour>\n    get() = NotCheckerOptionImpl(AssertImpl.iterable.containsNotBuilder(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the\n * [expected] value and the [otherExpected] values (if given).\n *\n * It is a shortcut for `enthaelt.inBeliebigerReihenfolge.zumindest(1).werte(expected, *otherExpected)`\n *\n * Notice, that it does not search for unique matches. Meaning, if the iterable is `setOf('a', 'b')` and\n * [expected] is defined as `'a'` and one of the [otherExpected] is defined as `'a'` as well, then both\n * match, even though they match the same entry. Use an option such as [zumindest], [hoechstens] and [genau] to control\n * the number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `enthaelt.inBeliebigerReihenfolge.genau(2).wert('a')`\n * instead of:\n *   `enthaelt.werte('a', 'a')`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T: Iterable<E>> Assert<T>.enthaelt(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = enthaelt.inBeliebigerReihenfolge.zumindest(1).werte(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding the\n * assertions created by [assertionCreatorOrNull] or an entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * It is a shortcut for `enthaelt.inBeliebigerReihenfolge.zumindest(1).eintrag(assertionCreatorOrNull)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E: Any, T: Iterable<E?>> Assert<T>.enthaelt(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = enthaelt.inBeliebigerReihenfolge.zumindest(1).eintrag(assertionCreatorOrNull)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding the\n * assertions created by [assertionCreatorOrNull] or an entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null` -- likewise an entry (can be the same) is searched for each\n * of the [otherAssertionCreatorsOrNulls].\n *\n * It is a shortcut for `enthaelt.inBeliebigerReihenfolge.zumindest(1).eintraege(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E: Any, T: Iterable<E?>> Assert<T>.enthaelt(assertionCreatorOrNull: (Assert<E>.() -> Unit)?, vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = enthaelt.inBeliebigerReihenfolge.zumindest(1).eintraege(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only\n * the [expected] value and the [otherExpected] values\n * (if given) in the defined order.\n *\n * It is a shortcut for `enthaelt.inGegebenerReihenfolge.nur.werte(expected, *otherExpected)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E , T : Iterable<E>> Assert<T>.enthaeltExakt(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = enthaelt.inGegebenerReihenfolge.nur.werte(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only an entry holding\n * the assertions created by [assertionCreatorOrNull] or only one entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * It is a shortcut for `enthaelt.inGegebenerReihenfolge.nur.eintrag(assertionCreatorOrNull)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E : Any, T : Iterable<E?>> Assert<T>.enthaeltExakt(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = enthaelt.inGegebenerReihenfolge.nur.eintrag(assertionCreatorOrNull)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains only an entry holding\n * the assertions created by [assertionCreatorOrNull] or `null` in case [assertionCreatorOrNull] is defined as `null`\n * and likewise an additional entry for each [otherAssertionCreatorsOrNulls] (if given)\n * whereas the entries have to appear in the defined order.\n *\n * It is a shortcut for `enthaelt.inGegebenerReihenfolge.nur.eintraege(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E : Any, T : Iterable<E?>> Assert<T>.enthaeltExakt(assertionCreatorOrNull: (Assert<E>.() -> Unit)?, vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = enthaelt.inGegebenerReihenfolge.nur.eintraege(assertionCreatorOrNull, *otherAssertionCreatorsOrNulls)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the [expected] value\n * and neither one of the [otherExpected] values (if given).\n *\n * It is a shortcut for `enthaeltNicht.werte(expected, *otherExpected)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T : Iterable<E>> Assert<T>.enthaeltNicht(expected: E, vararg otherExpected: E)\n    = enthaeltNicht.werte(expected, *otherExpected)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains an entry holding\n * the assertions created by [assertionCreatorOrNull] or an entry which is `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * It is a shortcut for `enthaelt.inBeliebigerReihenfolge.zumindest(1).eintrag(assertionCreatorOrNull)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E: Any, T: Iterable<E?>> Assert<T>.irgendEiner(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = enthaelt.inBeliebigerReihenfolge.zumindest(1).eintrag(assertionCreatorOrNull)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain a single entry\n * which holds all assertions created by [assertionCreatorOrNull] or does not contain a single entry which is `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n *  It is a shortcut for `enthaeltNicht.eintrag(assertionCreatorOrNull)`\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E : Any, T : Iterable<E?>> Assert<T>.keiner(assertionCreatorOrNull: (Assert<E>.() -> Unit)?)\n    = enthaeltNicht.eintrag(assertionCreatorOrNull)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] has at least one element and\n * that every element holds all assertions created by the [assertionCreatorOrNull] or that all elements are `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E : Any, T : Iterable<E?>> Assert<T>.alle(assertionCreatorOrNull: (Assert<E>.() -> Unit)?)\n    = addAssertion(AssertImpl.iterable.all(this, assertionCreatorOrNull))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsCheckersKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.*\nimport ch.tutteli.atrium.api.cc.de_CH.creating.iterable.contains.builders.impl.*\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we are looking\n * for, occurs `at least` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.zumindest(times: Int): AtLeastCheckerOption<E, T, S>\n    = AtLeastCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains at least` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `at most` number of [times] within the [Iterable].\n *\n * The resulting restriction will be a `contains at least but at most` assertion.\n *\n * @param times The number which the check will compare against the number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n * @throws IllegalArgumentException In case [times] of this `at most` restriction equals to the number of the\n *   `at least` restriction; use the [genau] restriction instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> AtLeastCheckerOption<E, T, S>.aberHoechstens(times: Int): ButAtMostCheckerOption<E, T, S>\n    = ButAtMostCheckerOptionImpl(times, this, containsBuilder)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `genau` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.genau(times: Int): ExactlyCheckerOption<E, T, S>\n    = ExactlyCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `at least` once but `at most` number of [times] within the [Iterable].\n *\n * If you want to use a higher lower bound than one, then use `zumindest(2).aberHoechstens(3)` instead of `hoechstens(3)`.\n * And in case you want to state that it is either not contained at all or at most a certain number of times,\n * then use `notOrAstMost(2)` instead.\n *\n * @param times The number which the check will compare against the number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n * @throws IllegalArgumentException In case [times] equals to one; use [genau] instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.hoechstens(times: Int): AtMostCheckerOption<E, T, S>\n    = AtMostCheckerOptionImpl(times, this)\n\n/**\n * Restricts a `contains` assertion by specifying that the number of occurrences of the entry which we\n * are looking for occurs `not at all or at most` number of [times] within the [Iterable].\n *\n * @param times The number which the check will compare against the number of times an expected entry is\n *   found in the [Iterable].\n *\n * @return The newly created builder.\n * @throws IllegalArgumentException In case [times] is smaller than zero.\n * @throws IllegalArgumentException In case [times] equals to zero; use [enthaeltNicht] instead.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T : Iterable<E>, S: InAnyOrderSearchBehaviour> IterableContains.Builder<E, T, S>.nichtOderHoechstens(times: Int): NotOrAtMostCheckerOption<E, T, S>\n    = NotOrAtMostCheckerOptionImpl(times, this)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsDecoratorsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.*\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Defines that the search behaviour \"find entries `in any order` in the [Iterable]\" shall be applied to this\n * sophisticated `contains` in [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, NoOpSearchBehaviour>.inBeliebigerReihenfolge\n    get() = AssertImpl.iterable.contains.searchBehaviours.inAnyOrder(this)\n\n/**\n * Defines that the constraint \"`only` the specified entries exist in the [Iterable]\" shall be applied to this\n * sophisticated `contains` [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderSearchBehaviour>.nur\n    @JvmName(\"aberNur\")\n    get() = AssertImpl.iterable.contains.searchBehaviours.inAnyOrderOnly(this)\n\n/**\n * Defines that the search behaviour \"find entries `in order` in the [Iterable]\" shall be applied to this\n * sophisticated `contains` in [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, NoOpSearchBehaviour>.inGegebenerReihenfolge\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrder(this)\n\n/**\n * Defines that the constraint \"`only` the specified entries exist in the [Iterable]\" shall be applied to this\n * sophisticated `contains in order` [Iterable] assertion.\n *\n * @return The newly created builder.\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderSearchBehaviour>.nur\n    @JvmName(\"undNur\")\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrderOnly(this)\n\n/**\n * Defines that the [Iterable] contains `in order only` groups of entries\n * whereas the order within the group is specified as next step.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.gruppiert\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrderOnlyGrouped(this)\n\n/**\n * A filler word to emphasis that the next step defines the order within expected groups of values.\n *\n * @return The newly created builder.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlyGroupedSearchBehaviour>.innerhalb\n    get() = AssertImpl.iterable.contains.searchBehaviours.inOrderOnlyGroupedWithin(this)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInAnyOrderCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderSearchBehaviour\nimport ch.tutteli.kbox.glue\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value shall be searched within the [Iterable].\n *\n * Delegates to `werte(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T : Iterable<E>> IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>.wert(expected: E): AssertionPlant<T>\n    = werte(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value as well as the [otherExpected] values (if given)\n * shall be searched within the [Iterable].\n *\n * Notice, that it does not search for unique matches. Meaning, if the iterable is `setOf('a', 'b')` and\n * [expected] is defined as `'a'` and one [otherExpected] is defined as `'a'` as well, then both match,\n * even though they match the same entry. Use an option such as [zumindest], [hoechstens] and [genau] to control the\n * number of occurrences you expect.\n *\n * Meaning you might want to use:\n *   `enthaelt.inBeliebigerReihenfolge.genau(2).werte('a')`\n * instead of:\n *   `enthaelt.inBeliebigerReihenfolge.zumindest(1).werte('a', 'a')`\n *\n * @param expected The object which is expected to be contained within the [Iterable].\n * @param otherExpected Additional objects which are expected to be contained within [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T : Iterable<E>> IterableContains.CheckerOption<E, T, InAnyOrderSearchBehaviour>.werte(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInAnyOrder(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry shall be searched which either\n * holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case [assertionCreatorOrNull]\n * is defined as `null`.\n *\n * Delegates to `eintraege(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking for\n *   has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E : Any, T : Iterable<E?>> IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>.eintrag(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = eintraege(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry shall be searched which either\n * holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case\n * [assertionCreatorOrNull] is defined as `null` -- likewise an entry (can be the same) is searched for each\n * of the [otherAssertionCreatorsOrNulls].\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking for\n *   has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <E : Any, T : Iterable<E?>> IterableContains.CheckerOption<E?, T, InAnyOrderSearchBehaviour>.eintraege(\n    assertionCreatorOrNull: (Assert<E>.() -> Unit)?,\n    vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?\n): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInAnyOrderWithAssert(this, assertionCreatorOrNull glue otherAssertionCreatorsOrNulls))\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nprivate fun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.CheckerOption<E, T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInAnyOrderOnlyCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.creating.basic.contains.addAssertionForAssert\nimport ch.tutteli.atrium.domain.creating.charsequence.contains.CharSequenceContains\nimport ch.tutteli.kbox.glue\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InAnyOrderOnlySearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value.\n *\n * Delegates to `werte(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>.wert(expected: E): AssertionPlant<T>\n    = werte(expected)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [expected]\n * value as well as the [otherExpected] values (if given) need to be\n * contained in [Iterable] where it does not matter in which order but only as\n * many entries should be returned by the [Iterable] as values defined.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n * @param otherExpected Additional values which are expected to be contained within [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InAnyOrderOnlySearchBehaviour>.werte(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInAnyOrderOnly(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only one\n * entry which holds all assertions created by the given [assertionCreatorOrNull] or is `null` in case\n * [assertionCreatorOrNull] is defined as `null`.\n *\n * Delegates to `eintraege(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>.eintrag(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = eintraege(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where an entry needs to be contained in the\n * [Iterable] which holds all assertions [assertionCreatorOrNull] might create or needs to be `null` in case\n * [assertionCreatorOrNull] is defined as `null` -- likewise an entry for each\n * [otherAssertionCreatorsOrNulls] needs to be contained in the [Iterable] where it does not matter in which order the\n * entries appear but only as many entries should be returned by the [Iterable] as assertion creators are defined.\n *\n * Notice, that a first-wins strategy applies which means your assertion creator lambdas -- which kind of serve as\n * identification lambdas -- should be ordered in such a way that the most specific identification lambda appears\n * first, not that a less specific lambda wins. For instance, given a `setOf(1, 2)` you should not search for\n * `eintraege({ isGreaterThan(0) }, { toBe(1) })` but for\n * `eintraege({ toBe(1) }, { isGreaterThan(0) })` otherwise\n * `isGreaterThan(0)` matches `1` before `toBe(1)` would match it. As a consequence `toBe(1)` could only match the\n * entry which is left -- in this case `2` -- and of course this would fail.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking for\n *   has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InAnyOrderOnlySearchBehaviour>.eintraege(\n    assertionCreatorOrNull: (Assert<E>.() -> Unit)?,\n    vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?\n): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInAnyOrderOnlyWithAssert(this, assertionCreatorOrNull glue otherAssertionCreatorsOrNulls))\n\n/**\n * Helper method to simplify adding assertions to the plant which itself is stored in\n * [CharSequenceContains.CheckerOption.containsBuilder].\n *\n * @return The plant to support a fluent API.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\ninternal fun <E, T : Iterable<E>, S : IterableContains.SearchBehaviour> IterableContains.Builder<E, T, S>.addAssertion(\n    assertion: Assertion\n): AssertionPlant<T> = addAssertionForAssert(assertion)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInOrderOnlyCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.kbox.glue\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlySearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value.\n *\n * Delegate to `werte(expected)`.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.wert(expected: E): AssertionPlant<T>\n    = werte(expected)\n\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only the\n * [expected] value as well as the [otherExpected] values\n * (if given) in the specified order.\n *\n * @param expected The value which is expected to be contained within the [Iterable].\n * @param otherExpected Additional values which are expected to be contained within [Iterable].\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E , T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlySearchBehaviour>.werte(expected: E, vararg otherExpected: E): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.valuesInOrderOnly(this, expected glue otherExpected))\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only a\n * single entry which holds all assertions created by the given [assertionCreatorOrNull] or needs to be `null`\n * in case [assertionCreatorOrNull] is defined as `null`.\n *\n * Delegates to `eintraege(assertionCreatorOrNull)`.\n *\n * @param assertionCreatorOrNull The identification lambda.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>.eintrag(assertionCreatorOrNull: (Assert<E>.() -> Unit)?): AssertionPlant<T>\n    = eintraege(assertionCreatorOrNull)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the [Iterable] needs to contain only an\n * entry which holds all assertions [assertionCreatorOrNull] might create or is `null` in case [assertionCreatorOrNull]\n * is defined as `null` and likewise a further entry for each\n * [otherAssertionCreatorsOrNulls] (if given) whereas the entries have to appear in the specified order.\n *\n * @param assertionCreatorOrNull The identification lambda which creates the assertions which the entry we are looking for\n *   has to hold; or in other words, the function which defines whether an entry is the one we are looking for\n *   or not. In case it is defined as `null`, then an entry is identified if it is `null` as well.\n * @param otherAssertionCreatorsOrNulls Additional identification lambdas which each identify (separately) an entry\n *   which we are looking for (see [assertionCreatorOrNull] for more information).\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlySearchBehaviour>.eintraege(\n    assertionCreatorOrNull: (Assert<E>.() -> Unit)?,\n    vararg otherAssertionCreatorsOrNulls: (Assert<E>.() -> Unit)?\n): AssertionPlant<T>\n    = addAssertion(AssertImpl.iterable.contains.entriesInOrderOnlyWithAssert(this, assertionCreatorOrNull glue otherAssertionCreatorsOrNulls))\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"IterableContainsInOrderOnlyGroupedCreatorsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.utils.Group\nimport ch.tutteli.atrium.domain.builders.utils.groupsToList\nimport ch.tutteli.atrium.domain.creating.iterable.contains.IterableContains\nimport ch.tutteli.atrium.domain.creating.iterable.contains.searchbehaviours.InOrderOnlyGroupedWithinSearchBehaviour\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [firstGroup] as well as\n * the [secondGroup] and optionally [otherExpectedGroups] of values need to be contained in [Iterable] as\n * only elements and in the specified order whereas the values within the groups can occur in any order.\n *\n * @param firstGroup A group of values which have to appear at first within the [Iterable].\n * @param secondGroup A group of values which have to appear after the values of the [firstGroup] within the [Iterable].\n * @param otherExpectedGroups Additional groups of values which are expected to appear after the [secondGroup] within\n *   [Iterable] whereas the groups have to appear in the given order.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <E, T : Iterable<E>> IterableContains.Builder<E, T, InOrderOnlyGroupedWithinSearchBehaviour>.inBeliebigerReihenfolge(\n    firstGroup: Group<E>,\n    secondGroup: Group<E>,\n    vararg otherExpectedGroups: Group<E>\n): AssertionPlant<T> = addAssertion(\n    AssertImpl.iterable.contains.valuesInOrderOnlyGrouped(\n        this,\n        groupsToList(firstGroup, secondGroup, otherExpectedGroups)\n    )\n)\n\n/**\n * Finishes the specification of the sophisticated `contains` assertion where the expected [firstGroup] as well as\n * the [secondGroup] and optionally [otherExpectedGroups] of identification lambdas, identifying an entry,\n * need to be contained in [Iterable] as only elements and in the specified order whereas\n * the identification lambdas within the groups can occur in any order.\n *\n * An identification lambda can also be defined with `null` in which case it matches an entry which is `null` as well.\n * Have a look at [eintraege] for more information about identification lambdas.\n *\n * @param firstGroup A group of identification lambdas which have to appear at first within the [Iterable].\n * @param secondGroup A group of identification lambdas which have to appear after the values of the [firstGroup] within the [Iterable].\n * @param otherExpectedGroups Additional groups of values which are expected to appear after the [secondGroup] within\n *   [Iterable] whereas the groups have to appear in the given order.\n *\n * @return The [AssertionPlant] for which the assertion was built to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\n@JvmName(\"inBeliebigerReihenfolgeEintraege\")\nfun <E : Any, T : Iterable<E?>> IterableContains.Builder<E?, T, InOrderOnlyGroupedWithinSearchBehaviour>.inBeliebigerReihenfolge(\n    firstGroup: Group<(Assert<E>.() -> Unit)?>,\n    secondGroup: Group<(Assert<E>.() -> Unit)?>,\n    vararg otherExpectedGroups: Group<(Assert<E>.() -> Unit)?>\n): AssertionPlant<T> = addAssertion(\n    AssertImpl.iterable.contains.entriesInOrderOnlyGroupedWithAssert(\n        this,\n        groupsToList(firstGroup, secondGroup, otherExpectedGroups)\n    )\n)\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject],\n * creates a feature assertion plant for the corresponding element and returns the newly created plant.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the given [index] is out of bound.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <E: Any, T: List<E>> Assert<T>.get(index: Int): Assert<E>\n    = AssertImpl.list.get(this, index)\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject] and that\n * the corresponding element holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <E: Any, T: List<E>> Assert<T>.get(index: Int, assertionCreator: Assert<E>.() -> Unit)\n    = addAssertion(AssertImpl.list.get(this, index, assertionCreator))\n\n/**\n * Makes the assertion that the given [index] is within the bounds of [Assert.subject][SubjectProvider.subject],\n * creates a feature assertion plant for the corresponding nullable element and returns the newly created plant.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the given [index] is out of bound.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <E, T: List<E>> Assert<T>.get(index: Int): AssertionPlantNullable<E>\n    = AssertImpl.list.getNullable(this, index)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.ListAssertions\nimport ch.tutteli.atrium.domain.creating.listAssertions\n\n/**\n * Delegates inter alia to the implementation of [ListAssertions].\n * In detail, it implements [ListAssertions] by delegating to [listAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject ListAssertionsBuilder : ListAssertions {\n\n    override inline fun <E, T : List<E>> get(\n        assertionContainer: Expect<T>,\n        index: Int\n    ) = listAssertions.get(assertionContainer, index)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T : Any> get(plant: AssertionPlant<List<T>>, index: Int): AssertionPlant<T> =\n        listAssertions.get(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T : Any> get(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlant<T>.() -> Unit\n    ) = listAssertions.get(plant, index, assertionCreator)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override fun <T> getNullable(plant: AssertionPlant<List<T>>, index: Int): AssertionPlantNullable<T> =\n        listAssertions.getNullable(plant, index)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <T> getNullable(\n        plant: AssertionPlant<List<T>>,\n        index: Int,\n        noinline assertionCreator: AssertionPlantNullable<T>.() -> Unit\n    ) = listAssertions.getNullable(plant, index, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\nimport ch.tutteli.kbox.glue\nimport kotlin.js.JsName\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a key as defined by\n * [entry]'s [Pair.first] with a corresponding value as defined by [entry]'s [Pair.second]\n * -- optionally the same assertions are created for the [otherEntries].\n *\n * Notice, that it does not search for unique matches. Meaning, if the map is `mapOf('a' to 1)` and [entry] is\n * defined as `'a' to 1` and one of the [otherEntries] is defined as `'a' to 1` as well, then both match,\n * even though they match the same entry.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K, V, T: Map<out K, V>> Assert<T>.enthaelt(entry: Pair<K, V>, vararg otherEntries: Pair<K, V>)\n    = addAssertion(AssertImpl.map.contains(this, entry glue otherEntries))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains a key as defined by [keyValue]'s [KeyValue.key]\n * with a corresponding value which either holds all assertions [keyValue]'s\n * [KeyValue.valueAssertionCreatorOrNull] might create or needs to be `null` in case\n * [KeyValue.valueAssertionCreatorOrNull] is defined as `null`\n * -- optionally the same assertions are created for the [otherKeyValues].\n *\n * Notice, that it does not search for unique matches. Meaning, if the map is `mapOf('a' to 1)` and [keyValue] is\n * defined as `Key('a') { isGreaterThan(0) }` and one of the [otherKeyValues] is defined as `Key('a') { isLessThan(2) }`\n * , then both match, even though they match the same entry.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K, V : Any, T: Map<out K, V?>> Assert<T>.enthaelt(\n    keyValue: KeyValue<K, V>,\n    vararg otherKeyValues: KeyValue<K, V>\n) = addAssertion(AssertImpl.map.containsKeyWithValueAssertions(this, (keyValue glue otherKeyValues).map { it.toPair() }))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <K> Assert<Map<out K, *>>.enthaeltKey(key: K)\n    = addAssertion(AssertImpl.map.containsKey(this, key))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] does not contain the given [key].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <K> Assert<Map<out K, *>>.enthaeltNichtKey(key: K)\n    = addAssertion(AssertImpl.map.containsNotKey(this, key))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key], creates a feature\n * assertion plant for corresponding value and returns the newly created plant.\n *\n * @return The newly created plant for the feature\n * @throws AssertionError Might throw an [AssertionError] if the given [key] does not exist.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\n@JsName(\"getExistierend\")\nfun <K, V: Any, T: Map<out K, V>> Assert<T>.getExistierend(key: K): Assert<V>\n    = AssertImpl.map.getExisting(this, key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key] and that the corresponding value\n * holds all assertions the given [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K, V: Any, T: Map<out K, V>> Assert<T>.getExistierend(key: K, assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.map.getExisting(this, key, assertionCreator))\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] contains the given [key], creates a feature\n * assertion plant for corresponding nullable value and returns the newly created plant.\n *\n * @return The newly created plant for the feature\n * @throws AssertionError Might throw an [AssertionError] if the given [key] does not exist.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K, V, T: Map<out K, V>> Assert<T>.getExistierend(key: K): AssertionPlantNullable<V>\n    = AssertImpl.map.getExistingNullable(this, key)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Map.size] is [size].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <T : Map<*, *>> Assert<T>.hatDieGroesse(size: Int)\n    = addAssertion(AssertImpl.map.hasSize(this, size))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is an empty [Map].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Map<*, *>> Assert<T>.istLeer()\n    = addAssertion(AssertImpl.map.isEmpty(this))\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] is not an empty [Map].\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Map<*, *>> Assert<T>.istNichtLeer()\n    = addAssertion(AssertImpl.map.isNotEmpty(this))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [keys][Map.keys] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <K, V> Assert<Map<out K, V>>.keys get() : Assert<Set<K>> = property(Map<out K, V>::keys)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [keys][Map.keys] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K, V, T: Map<out K, V>> Assert<T>.keys(assertionCreator: Assert<Set<K>>.() -> Unit)\n    = addAssertion(AssertImpl.map.keys(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [values][Map.values] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <K, V> Assert<Map<out K, V>>.values get() : Assert<Collection<V>> = property(Map<out K, V>::values)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [values][Map.values] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K, V, T: Map<out K, V>> Assert<T>.values(assertionCreator: Assert<Collection<V>>.() -> Unit)\n    = addAssertion(AssertImpl.map.values(this, assertionCreator))\n\n/**\n * Turns `Assert<Map<out K, V>>` into `Assert<Set<Map.Entry<K, V>>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `property(subject::entries)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K, V> Assert<Map<out K, V>>.asEntries(): Assert<Set<Map.Entry<K, V>>>\n    = ExpectImpl.changeSubject(this).unreported { it.entries }\n\n/**\n * Turns `Assert<Map<out K, V>>` into `Assert<Set<Map.Entry<K, V>>>` and makes the assertion that the assertions the given\n * [assertionCreator] might create hold.\n *\n * The transformation as such is not reflected in reporting.\n * Use `property(subject::entries)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <K, V> Assert<Map<out K, V>>.asEntries(assertionCreator: Assert<Set<Map.Entry<K, V>>>.() -> Unit): Assert<Set<Map.Entry<K, V>>>\n    = asEntries().addAssertionsCreatedBy(assertionCreator)\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.*\nimport ch.tutteli.atrium.domain.creating.MapAssertions\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.changers.ExtractedFeaturePostStep\nimport ch.tutteli.atrium.domain.creating.mapAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapAssertions].\n * In detail, it implements [MapAssertions] by delegating to [mapAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject MapAssertionsBuilder : MapAssertions {\n\n    /**\n     * Returns [MapEntryAssertionsBuilder]\n     * which inter alia delegates to the implementation of [MapEntryAssertions].\n     */\n    inline val entry get() : MapEntryAssertionsBuilder = MapEntryAssertionsBuilder\n\n    override inline fun <K, V : Any, T : Map<out K, V?>> contains(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValuePairs: List<Pair<K, V?>>\n    ) = mapAssertions.contains(assertionContainer, valueType, keyValuePairs)\n\n    override inline fun <K, V : Any, T : Map<out K, V?>> containsKeyWithValueAssertions(\n        assertionContainer: Expect<T>,\n        valueType: KClass<V>,\n        keyValues: List<Pair<K, (Expect<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(assertionContainer, valueType, keyValues)\n\n\n    override inline fun <K> containsKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsKey(subjectProvider, key)\n\n    override inline fun <K> containsNotKey(subjectProvider: SubjectProvider<Map<out K, *>>, key: K) =\n        mapAssertions.containsNotKey(subjectProvider, key)\n\n\n    override inline fun isEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isEmpty(subjectProvider)\n\n    override inline fun <K, V, T : Map<out K, V>> getExisting(\n        assertionContainer: Expect<T>,\n        key: K\n    ): ExtractedFeaturePostStep<T, V> = mapAssertions.getExisting(assertionContainer, key)\n\n    override inline fun isNotEmpty(subjectProvider: SubjectProvider<Map<*, *>>) =\n        mapAssertions.isNotEmpty(subjectProvider)\n\n    override inline fun <T : Map<*, *>> size(assertionContainer: Expect<T>) = mapAssertions.size(assertionContainer)\n\n    // everything below is deprecated functionality and will be removed with 1.0.0\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> contains(\n        plant: AssertionPlant<Map<out K, V>>,\n        keyValuePairs: List<Pair<K, V>>\n    ) = mapAssertions.contains(plant, keyValuePairs)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> containsKeyWithValueAssertions(\n        plant: AssertionPlant<Map<out K, V?>>,\n        keyValues: List<Pair<K, (Assert<V>.() -> Unit)?>>\n    ) = mapAssertions.containsKeyWithValueAssertions(plant, keyValues)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExisting(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V : Any> getExisting(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ) = mapAssertions.getExisting(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(plant: AssertionPlant<Map<out K, V>>, key: K) =\n        mapAssertions.getExistingNullable(plant, key)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K, V> getExistingNullable(\n        plant: AssertionPlant<Map<out K, V>>,\n        key: K,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ) = mapAssertions.getExistingNullable(plant, key, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun hasSize(plant: AssertionPlant<Map<*, *>>, size: Int) = mapAssertions.hasSize(plant, size)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> keys(\n        plant: AssertionPlant<Map<out K, *>>,\n        noinline assertionCreator: AssertionPlant<Set<K>>.() -> Unit\n    ): Assertion = mapAssertions.keys(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> values(\n        plant: AssertionPlant<Map<*, V>>,\n        noinline assertionCreator: AssertionPlant<Collection<V>>.() -> Unit\n    ): Assertion = mapAssertions.values(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s [Map.Entry.key] is (equal to) the given [key] and\n * [Map.Entry.value] is [value].\n *\n * Kind of a shortcut for `this.key.ist(key).und.value.ist(value)` but should be evaluated in\n * an assertion group block -- which has the effect that the assertion about the value is still evaluated even\n * if the assertion about the key fails. Moreover, it might be that reporting differs compared to using the long form.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K : Any, V : Any> Assert<Map.Entry<K, V>>.istKeyValue(key: K, value: V): Assert<Map.Entry<K, V>>\n    = addAssertion(AssertImpl.map.entry.isKeyValue(this, key, value))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <K : Any> Assert<Map.Entry<K, *>>.key get() : Assert<K> = property(Map.Entry<K, *>::key)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] (which could be `null`)\n * so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <K> Assert<Map.Entry<K, *>>.key get() : AssertionPlantNullable<K> = property(Map.Entry<K, *>::key)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [key][Map.Entry.key] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K : Any, V> Assert<Map.Entry<K, V>>.key(assertionCreator: Assert<K>.() -> Unit)\n    = addAssertion(AssertImpl.map.entry.key(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <V : Any> Assert<Map.Entry<*, V>>.value get() : Assert<V> = property(Map.Entry<*, V>::value)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value]\n * (which could be `null`) so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <V> Assert<Map.Entry<*, V>>.value get() : AssertionPlantNullable<V> = property(Map.Entry<*, V>::value)\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [value][Map.Entry.value] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K, V: Any> Assert<Map.Entry<K, V>>.value(assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.map.entry.value(this, assertionCreator))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.MapEntryAssertions\nimport ch.tutteli.atrium.domain.creating.mapEntryAssertions\nimport kotlin.reflect.KClass\n\n/**\n * Delegates inter alia to the implementation of [MapEntryAssertions].\n * In detail, it implements [MapEntryAssertions] by delegating to [mapEntryAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject MapEntryAssertionsBuilder : MapEntryAssertions {\n    override inline fun <K : Any, V : Any, T : Map.Entry<K, V>> isKeyValue(\n        assertionContainer: Expect<T>,\n        key: K,\n        value: V\n    ) = mapEntryAssertions.isKeyValue(assertionContainer, key, value)\n\n    override inline fun <K : Any, V : Any, T : Map.Entry<K?, V?>> isKeyValue(\n        assertionContainer: Expect<T>,\n        key: K?,\n        value: V?,\n        keyType: KClass<K>,\n        valueType: KClass<V>\n    ) = mapEntryAssertions.isKeyValue(assertionContainer, key, value, keyType, valueType)\n\n    override inline fun <K, T : Map.Entry<K, *>> key(assertionContainer: Expect<T>) =\n        mapEntryAssertions.key(assertionContainer)\n\n    override inline fun <V, T : Map.Entry<*, V>> value(assertionContainer: Expect<T>) =\n        mapEntryAssertions.value(assertionContainer)\n\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any, V : Any> isKeyValue(\n        plant: AssertionPlant<Map.Entry<K, V>>,\n        key: K,\n        value: V\n    ): Assertion = mapEntryAssertions.isKeyValue(plant, key, value)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> key(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.key(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> value(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.value(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableKey(\n        plant: AssertionPlant<Map.Entry<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableKey(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableValue(\n        plant: AssertionPlant<Map.Entry<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = mapEntryAssertions.nullableValue(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <K : Any> Assert<Pair<K, *>>.first get() : Assert<K> = property(Pair<K, *>::first)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] (which could be `null`)\n * so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <K> Assert<Pair<K, *>>.first get() : AssertionPlantNullable<K> = property(Pair<K, *>::first)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [first][Pair.first] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K : Any, V> Assert<Pair<K, V>>.first(assertionCreator: Assert<K>.() -> Unit)\n    = addAssertion(AssertImpl.pair.first(this, assertionCreator))\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second] so that further\n * fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <V : Any> Assert<Pair<*, V>>.second get() : Assert<V> = property(Pair<*, V>::second)\n\n/**\n * Creates an [AssertionPlant] for the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second]\n * (which could be `null`) so that further fluent calls are assertions about it.\n *\n * Wrap it into Kotlin's [apply] if you want to make subsequent assertions on the current subject or use the overload\n * which expects an assertionCreator lambda where sub assertions are evaluated together (form an assertion group block).\n *\n * @return The newly created [AssertionPlant].\n */\n//TODO deprecate as soon as https://youtrack.jetbrains.com/issue/KT-33398 is fixed\n//@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nval <V> Assert<Pair<*, V>>.second get() : AssertionPlantNullable<V> = property(Pair<*, V>::second)\n\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject]'s property [second][Pair.second] holds all assertions the given\n * [assertionCreator] might create for it.\n *\n * @return This plant to support a fluent API.\n * @throws AssertionError Might throw an [AssertionError] if a created [Assertion]s (by calling [assertionCreator])\n *   does not hold.\n * @throws IllegalArgumentException in case the given [assertionCreator] did not create a single assertion.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <K, V: Any> Assert<Pair<K, V>>.second(assertionCreator: Assert<V>.() -> Unit)\n    = addAssertion(AssertImpl.pair.second(this, assertionCreator))\n","@file:Suppress(\"OVERRIDE_BY_INLINE\", \"NOTHING_TO_INLINE\")\n\npackage ch.tutteli.atrium.domain.builders.creating\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.core.polyfills.loadSingleService\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.Expect\nimport ch.tutteli.atrium.domain.creating.PairAssertions\nimport ch.tutteli.atrium.domain.creating.pairAssertions\n\n/**\n * Delegates inter alia to the implementation of [PairAssertions].\n * In detail, it implements [PairAssertions] by delegating to [pairAssertions]\n * which in turn delegates to the implementation via [loadSingleService].\n */\nobject PairAssertionsBuilder : PairAssertions {\n\n    override inline fun <K, T : Pair<K, *>> first(assertionContainer: Expect<T>) =\n        pairAssertions.first(assertionContainer)\n\n    override inline fun <V, T : Pair<*, V>> second(assertionContainer: Expect<T>) =\n        pairAssertions.second(assertionContainer)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K : Any> first(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlant<K>.() -> Unit\n    ): Assertion = pairAssertions.first(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V : Any> second(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlant<V>.() -> Unit\n    ): Assertion = pairAssertions.second(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <K> nullableFirst(\n        plant: AssertionPlant<Pair<K, *>>,\n        noinline assertionCreator: AssertionPlantNullable<K>.() -> Unit\n    ): Assertion = pairAssertions.nullableFirst(plant, assertionCreator)\n\n    @Suppress(\"DEPRECATION\", \"DeprecatedCallableAddReplaceWith\")\n    @Deprecated(\"Switch from Assert to Expect; will be removed with 1.0.0\")\n    override inline fun <V> nullableSecond(\n        plant: AssertionPlant<Pair<*, V>>,\n        noinline assertionCreator: AssertionPlantNullable<V>.() -> Unit\n    ): Assertion = pairAssertions.nullableSecond(plant, assertionCreator)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"ParameterObjectsKt\")\n\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.utils.Group\nimport ch.tutteli.atrium.domain.builders.utils.GroupWithNullableEntries\nimport ch.tutteli.atrium.domain.builders.utils.GroupWithoutNullableEntries\nimport ch.tutteli.atrium.domain.builders.utils.VarArgHelper\nimport ch.tutteli.kbox.glue\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Parameter object to express a [Group] with a single identification lambda.\n *\n * In case `null` is used for the identification lambda then it is expected that the corresponding entry\n * is `null` as well.\n *\n * @param assertionCreator The identification lambda identifying the entry where an entry is considered\n *   to be identified if it holds all [Assertion]s the lambda might create or if it is `null` in case\n *   [assertionCreator] is defined as `null`.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nclass Eintrag<in T : Any>(\n    val assertionCreator: ((Assert<T>) -> Unit)?\n) : GroupWithoutNullableEntries<((Assert<T>) -> Unit)?>, GroupWithNullableEntries<((Assert<T>) -> Unit)?> {\n    override fun toList(): List<((Assert<T>) -> Unit)?> = listOf(assertionCreator)\n}\n\n/**\n * Parameter object to express a [Group] of identification lambdas.\n *\n * In case `null` is used for an identification lambda then it is expected that the corresponding entry\n * is `null` as well.\n *\n * @param assertionCreatorOrNull The identification lambda identifying the entry where an entry is considered\n *   to be identified if it holds all [Assertion]s the lambda might create or if it is `null` in case\n *   [assertionCreatorOrNull] is defined as `null`.\n * @param otherAssertionCreatorsOrNulls A variable amount of additional identification lambdas or `null`s.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nclass Eintraege<in T : Any>(\n    val assertionCreatorOrNull: ((Assert<T>) -> Unit)?,\n    vararg val otherAssertionCreatorsOrNulls: ((Assert<T>) -> Unit)?\n) : GroupWithoutNullableEntries<((Assert<T>) -> Unit)?>, GroupWithNullableEntries<((Assert<T>) -> Unit)?>, VarArgHelper<((Assert<T>) -> Unit)?> {\n    override val expected get() = assertionCreatorOrNull\n    override val otherExpected get() = otherAssertionCreatorsOrNulls\n\n    override fun toList(): List<((Assert<T>) -> Unit)?> = assertionCreatorOrNull glue otherAssertionCreatorsOrNulls\n}\n\n\n/**\n * Parameter object to express a key/value [Pair] whose value type is a lambda with an\n * [Assert][AssertionPlant] receiver, which means one can either pass a lambda or `null`.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\ndata class KeyValue<out K, V : Any>(val key: K, val valueAssertionCreatorOrNull: (Assert<V>.() -> Unit)?) {\n    fun toPair(): Pair<K, (Assert<V>.() -> Unit)?> = key to valueAssertionCreatorOrNull\n    override fun toString(): String\n        = \"KeyValue(key=$key, value=${if (valueAssertionCreatorOrNull == null) \"null\" else \"lambda\"})\"\n}\n\n/**\n * Represents a [GroupWithoutNullableEntries] with a single value.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\ndata class Wert<out T>(val expected: T) : GroupWithNullableEntries<T>, GroupWithoutNullableEntries<T> {\n    override fun toList() = listOf(expected)\n}\n\n/**\n * Represents a [GroupWithoutNullableEntries] of multiple values.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nclass Werte<out T>(\n    override val expected: T,\n    override vararg val otherExpected: T\n) : GroupWithoutNullableEntries<T>, GroupWithNullableEntries<T>, VarArgHelper<T> {\n    override fun toList() = listOf(expected, *otherExpected)\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.domain.builders.ExpectImpl\n\n/**\n * Turns `Assert<Sequence<E>>` into `Assert<Iterable<E>>`.\n *\n * The transformation as such is not reflected in reporting.\n * Use `returnValueOf(Sequence::asIterable)` if you want to show the transformation in reporting.\n *\n * @return The newly created [AssertionPlant] for the transformed subject.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\nfun <E> Assert<Sequence<E>>.asIterable(): Assert<Iterable<E>>\n    = ExpectImpl.changeSubject(this).unreported { it.asIterable() }\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"ThrowableAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.assertions.Assertion\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport ch.tutteli.atrium.domain.creating.throwable.thrown.ThrowableThrown\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that the thrown [Throwable] is of type [TExpected] and holds all assertions the\n * [assertionCreator] might create in addition.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion (a [Throwable] was thrown) holds or not.\n * Define subsequent assertions via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\ninline fun <reified TExpected : Throwable> ThrowableThrown.Builder.wirft(noinline assertionCreator: Assert<TExpected>.() -> Unit) {\n    @Suppress(\"DEPRECATION\")\n    AssertImpl.throwable.thrown.toBe(this, TExpected::class, assertionCreator)\n}\n\n/**\n * Makes the assertion that no [Throwable] is thrown at all.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because we assume nothing happens,\n *   so there is nothing we could make assertions on in addition.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun ThrowableThrown.Builder.wirftNichts() {\n    @Suppress(\"DEPRECATION\")\n    AssertImpl.throwable.thrown.nothingThrown(this)\n}\n\n/**\n * Creates an [AssertionPlantNullable] for the [message][Throwable.message] of the plant's\n * [subject][SubjectProvider.subject] (which is a [Throwable]) and makes the assertion that message [istNichtNull]\n * and uses [assertionCreator] which might create further [Assertion]s which are lazily evaluated at the end.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion [message][Throwable.message] is not null) holds or not.\n * Define subsequent assertions via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] in case [message][Throwable.message] is `null`\n *   or if an additionally created [Assertion]s (by calling [assertionCreator]) does not hold.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Throwable> Assert<T>.message(assertionCreator: Assert<String>.() -> Unit) {\n    property(Throwable::message).istNichtNull(assertionCreator)\n}\n\n/**\n * Creates the assertion that the [Throwable]'s [message][Throwable.message] is not null (see [message]) contains\n * [expected]'s [toString] representation and the [toString] representation of the [otherExpected] (if given),\n * using a non disjoint search.\n *\n * It is a shortcut for `message { enthaelt.zumindest(1).werte(expected, otherExpected) }`\n *\n * Notice that a runtime check applies which assures that only [CharSequence], [Number] and [Char] are passed\n * (this function expects `Any` for your convenience, so that you can mix [String] and [Int] for instance).\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion [message][Throwable.message] is not null) holds or not.\n *\n * @throws AssertionError Might throw an [AssertionError] in case [message][Throwable.message] is `null`\n *   or does not contain [expected] or [otherExpected].\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\nfun <T : Throwable> Assert<T>.messageEnthaelt(expected: Any, vararg otherExpected: Any) {\n    message { enthaelt(expected, *otherExpected) }\n}\n","@file:Suppress(\"DEPRECATION\" /* will be removed with 1.0.0 */)\n@file:JvmMultifileClass\n@file:JvmName(\"TypeTransformationAssertionsKt\")\npackage ch.tutteli.atrium.api.cc.de_CH\n\nimport ch.tutteli.atrium.creating.Assert\nimport ch.tutteli.atrium.creating.AssertionPlant\nimport ch.tutteli.atrium.creating.AssertionPlantNullable\nimport ch.tutteli.atrium.creating.SubjectProvider\nimport ch.tutteli.atrium.domain.builders.AssertImpl\nimport kotlin.jvm.JvmMultifileClass\nimport kotlin.jvm.JvmName\n\n/**\n * Makes the assertion that [AssertionPlantNullable.subject][SubjectProvider.subject] is not null and if so, uses [assertionCreator]\n * which could create further assertions which are added as a group.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion ([Assert.subject][SubjectProvider.subject] is not null) holds or not. Define subsequent assertions via\n *   the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\ninline fun <reified T : Any> AssertionPlantNullable<T?>.istNichtNull(noinline assertionCreator: Assert<T>.() -> Unit) {\n    addAssertion(AssertImpl.any.isNotNull(this, T::class, assertionCreator))\n}\n\n/**\n * Makes the assertion that the [Assert.subject][SubjectProvider.subject] *is a* [TSub] (the same type or a sub-type) and if so,\n * uses [assertionCreator] which could create further assertions which are added as a group.\n *\n * Notice, that asserting a function type is [flawed](https://youtrack.jetbrains.com/issue/KT-27846).\n * The actual types are ignored as function types erase to Function0,\n * Function1 etc. on byte code level, which means the assertion holds as long as the [Assert.subject][SubjectProvider.subject] is a\n * function and has the same amount of arguments regardless if the types differ. For instance\n * `esGilt({x: Int -> \"hello\"}).istEin<String -> Unit>{}` holds, even though `(Int) -> String` is clearly not\n * a `(String) -> Unit`.\n *\n * More generally speaking, the [flaw](https://youtrack.jetbrains.com/issue/KT-27826) applies to all generic types.\n * For instance `isA<List<String>>` would only check if the [Assert.subject][SubjectProvider.subject] is a `List` without checking if\n * the element type is actually `String`. Or in other words\n * `esGilt(listOf(1, 2)).isA<List<String>>{}` holds, even though `List<Int>` is clearly not a `List<String>`.\n *\n * @return Notice, that this assertion function cannot provide a fluent API because it depends on whether the first\n *   assertion ([Assert.subject][SubjectProvider.subject] *is a* [TSub]) holds or not. Define subsequent assertions\n *   via the [assertionCreator] lambda.\n *\n * @throws AssertionError Might throw an [AssertionError] if the assertion made is not correct.\n */\n@Deprecated(\"api-cc-de_CH is discontinued, switch to api-fluent-en_GB; will be removed with 1.0.0\")\n@Suppress(\"DEPRECATION\")\ninline fun <reified TSub : Any> Assert<Any>.istEin(noinline assertionCreator: AssertionPlant<TSub>.() -> Unit) {\n    AssertImpl.any.typeTransformation.isA(this, TSub::class, assertionCreator)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;iBAmC4B,4E;mBCXxB,gH;;;;;;;;;;8BCgBA,2G;;qBCvBJ,oD;iBCwDI,+I;gCCgtCJ,yD;uBAAA,gD;mBC/wCA,qC;yBFiHI,uJ;;;;;;;;;;;;;;;;;;;;;;4BG/FA,mI;2BCiIA,mJ;mBAtFA,2I;;;;;;;;;;;;mBCTA,0I;;;;;;;;;;;;;;;;;;;;;;;;;EC/CJ,kC;IVoBoC,6B;IUT9B,sCTDE,wBAAc,cSCiB,STDjB,ESCuB,QTDvB,CSChB,C;G;EAEN,uC;IVOoC,6B;IUI9B,sCTXE,wBAAc,iBSWoB,STXpB,ESW0B,QTX1B,CSWhB,C;G;EAEN,iD;IVNoC,6B;IUiB9B,sCTrBE,wBAAc,gBSqBmB,STrBnB,ESqByB,QTrBzB,CSqBhB,C;G;EAEN,sD;IVnBoC,6B;IU8B9B,sCT/BE,wBAAc,mBS+BsB,ST/BtB,ES+B4B,QT/B5B,CS+BhB,C;G;wGAEN,yB;IAAA,gC;IVhC4B,6G;ICsBxB,mJ;ISUJ,gD;MVhCoC,6B;MU0CJ,yB;MAA5B,+BTjBI,wBAAc,oBSiBqB,STjBrB,EAAkB,IAAlB,ESiBqC,QTjBrC,CSiBlB,C;IACJ,C;GAXA,C;sJAaA,yB;IAAA,gC;IV7C4B,6G;ICyCxB,mJ;ISIJ,8D;MV7CoC,6B;MU6DJ,yB;MAA5B,+BTdI,wBAAc,+BScgC,STdhC,EAA6B,IAA7B,EScgD,sBTdhD,CSclB,C;IACJ,C;GAjBA,C;EA8BuC,4B;IAAQ,gB;G;EAE/C,0C;IAYM,gDAAuB,gBAAvB,C;G;ECzG0C,+B;IAAE,OAAG,WAAH,EAAG,C;EAAa,C;EAXlE,iC;IAWM,OTwBE,+BAAsB,gBSxBC,STwBD,CSxBO,oBAAW,iBAAX,C;G;EAErC,oD;IAWM,OAAA,uBAAa,gCAAuB,gBAAvB,C;G;EAe6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAZlE,kC;IAYM,OTJE,+BAAsB,gBSIC,STJD,CSIO,oBAAW,mBAAX,C;G;EAErC,oD;IAWM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAc6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OT/BE,+BAAsB,gBS+BC,ST/BD,CS+BO,oBAAW,mBAAX,C;G;EAErC,oD;IAYM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAe6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAZlE,kC;IAYM,OT5DE,+BAAsB,gBS4DC,ST5DD,CS4DO,oBAAW,mBAAX,C;G;EAErC,oD;IAYM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAe6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAZlE,kC;IAYM,OTzFE,+BAAsB,gBSyFC,STzFD,CSyFO,oBAAW,mBAAX,C;G;EAErC,oD;IAYM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAe6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAZlE,kC;IAYM,OTtHE,+BAAsB,gBSsHC,STtHD,CSsHO,oBAAW,mBAAX,C;G;EAErC,oD;IAYM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAe6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAZlE,kC;IAYM,OTnJE,+BAAsB,gBSmJC,STnJD,CSmJO,oBAAW,mBAAX,C;G;EAErC,oD;IAYM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAe6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAZlE,kC;IAYM,OThLE,+BAAsB,gBSgLC,SThLD,CSgLO,oBAAW,mBAAX,C;G;EAErC,oD;IAYM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EAe6B,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAZlE,kC;IAYM,OT7ME,+BAAsB,gBS6MC,ST7MD,CS6MO,oBAAW,mBAAX,C;G;EAErC,oD;IAYM,OAAA,wBAAa,gCAAuB,gBAAvB,C;G;EC7Of,iC;IZYyC,sC;IYZjC,OREJ,iCAAuB,yBQFqB,SRErB,C;G;EQQ3B,sC;IZEyC,sC;IYFjC,gCRLJ,iCAAuB,4BQK6C,SRL7C,CQKnB,C;G;EAEZ,sD;IA4BM,OAAsB,MAAb,UAAT,uBAAS,EAAU,CAAV,CAAa,EAAM,QAAN,EAAiB,aAAjB,S;G;EAE5B,2D;IAcM,OAAc,MAAd,4BAAc,EAAM,QAAN,EAAiB,aAAjB,S;G;EAEpB,0D;IA2BI,OAAsB,MAAb,UAAT,uBAAS,EAAU,CAAV,CAAa,EAAM,OAAN,EAAgB,aAAhB,S;G;EAE1B,yC;IZ3E6C,sC;IYmFvC,sCRvFE,iCAAuB,oBQuFuB,SRvFvB,EQuF6B,QRvF7B,CQuFzB,C;G;EAEN,8C;IZrF6C,sC;IY6FvC,sCR9FE,iCAAuB,uBQ8F0B,SR9F1B,EQ8FgC,QR9FhC,CQ8FzB,C;G;EAGN,uC;IZhG6C,sC;IYwGvC,sCRtGE,iCAAuB,kBQsGqB,SRtGrB,EQsG2B,QRtG3B,CQsGzB,C;G;EAEN,4C;IZ1G6C,sC;IYkHvC,sCR7GE,iCAAuB,qBQ6GwB,SR7GxB,EQ6G8B,QR7G9B,CQ6GzB,C;G;EAGN,4B;IZrH6C,sC;IY6HvC,sCRrHE,iCAAuB,iBQqHoB,SRrHpB,CQqHzB,C;G;EAEN,iC;IZ/H6C,sC;IYuIvC,sCR5HE,iCAAuB,oBQ4HuB,SR5HvB,CQ4HzB,C;G;EAEN,kC;IZzI6C,sC;IYiJvC,sCRnIE,iCAAuB,oBQmIuB,SRnIvB,CQmIzB,C;G;EC1KN,qC;IAaM,oCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,0C;IAiBM,sCAA2B,KAA3B,EAAkC,SAAlC,EAAwC,yBAAxC,C;G;EAEN,iC;IAaM,oCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,sC;IAkBM,mCAAwB,KAAxB,EAA+B,SAA/B,C;G;EAEN,+C;IAaM,wCAA6B,KAA7B,EAAoC,SAApC,C;G;ETDF,yDAIsC,yB;IEvF1C,sD;WFuF0C,c;MAAE,OEnFA,WFmFA,EEnFA,C;K;GFmFF,C;EUjF1C,mC;IAmBM,wBAAM,QAAN,K;G;EAEN,mD;IdA6C,sC;II0Bb,8C;IUJoB,iBXtCY,aWsCC,QXtCD,EWsCe,aXtCf,C;IWsC1D,+BViBE,uCAA+B,gBUjBoB,SViBpB,EAAsB,UAAtB,CUjBjC,C;G;EAEN,qC;IAoBM,0BAAM,QAAN,K;G;EAEN,qD;Id9C6C,sC;II0Bb,8C;IU2CoB,iBXrFY,aWqFa,QXrFb,EWqF2B,aXrF3B,C;IWqF1D,+BVzBE,uCAA+B,4BUyBgC,SVzBhC,EAAkC,UAAlC,CUyBjC,C;G;EAEN,qC;IAmBM,OAAa,OAAb,qBAAU,CAAV,CAAa,EAAK,QAAL,C;G;EAEnB,qD;IAyBM,OAAa,QAAb,qBAAU,CAAV,CAAa,EAAM,QAAN,EAAiB,aAAjB,S;G;EAEnB,kD;IdvH6C,sC;II0Bb,8C;IUoHoB,eX9JY,aW8JA,OX9JA,EW8Ja,aX9Jb,C;IE2wCrD,kBAAM,eAAa,wBD/rCD,QC+rCC,EAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,ODpwCY,QCowCZ,W;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WCx1CwB,WDw1CV,ICx1CU,CDw1CxB,C;;ISnrCd,+BV7EE,uCAA+B,eU6EmB,SV7EnB,ECiwC5B,WDjwC4B,CU6EjC,C;G;EAEN,oD;IdhJ6C,sC;II0Bb,8C;IU8IoB,eXxLY,aWwLY,OXxLZ,EWwLyB,aXxLzB,C;IWwL1D,+BVlGE,uCAA+B,2BUkG+B,SVlG/B,EAAiC,QAAjC,CUkGjC,C;G;EAEN,oD;IA0BM,OAAa,QAAb,qBAAU,CAAV,CAAa,EAAM,OAAN,EAAgB,aAAhB,S;G;EAEnB,4C;IAQM,wCAAsB,SAAtB,C;G;EC7NF,sD;IfeyC,sC;II0Bb,8C;IAkDQ,0D;IW1FlC,OXuGE,uCAAuB,sBWvGsC,SXuGtC,C;G;EW/F3B,wD;IACE,gCAAqC,kCAAhB,yBAAgB,CAArC,C;G;ECvBN,wC;IhB8B2C,oC;IgBnBrC,sCCaE,+BAAqB,iBDboB,SCapB,EDb0B,ICa1B,CDbvB,C;G;EAEN,8B;IhBiB2C,oC;IgBTrC,sCCVE,+BAAqB,iBDUoB,SCVpB,CDUvB,C;G;EAEN,mC;IhBO2C,oC;IgBCrC,sCCjBE,+BAAqB,oBDiBuB,SCjBvB,CDiBvB,C;G;EAYyB,6B;IAAqB,+DAAS,qB;aAAe,c;KAAxB,E;G;EAEpD,2C;IhBf2C,oC;IgB2BrC,sCC5BE,+BAAqB,cD4BiB,SC5BjB,ED4BuB,gBC5BvB,CD4BvB,C;G;EE3DN,4C;IlBkC2C,oC;IkB1BrC,sCCIE,+BAAqB,mBDJuB,SCIvB,EDJ6B,QCI7B,CDJvB,C;G;EAEN,mD;IlBwB2C,oC;IkBhBrC,sCCDE,+BAAqB,uBDC2B,SCD3B,EDCiC,QCDjC,CDCvB,C;G;EAEN,6C;IlBc2C,oC;IkBNrC,sCCNE,+BAAqB,sBDM0B,SCN1B,EDMgC,QCNhC,CDMvB,C;G;EAEN,oD;IlBI2C,oC;IkBIrC,sCCXE,+BAAqB,0BDW8B,SCX9B,EDWoC,QCXpC,CDWvB,C;G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EEvBiG,0D;IAGnG,oCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,qDAJA,C;G;EAIA,uE;IAAA,qB;MAAE,OAA8B,4BAA3B,4B;;OAA2B,YAA3B,uBAA2B,eAA9B,SAAqC,EAArC,M;IAA0C,C;G;;;;;;ECLsD,yD;IAGlG,mCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,oDAJA,EAKA,sDALA,EAMA,sDANA,C;G;EAIA,sE;IAAA,qB;MAAE,OAA+B,6BAA5B,4B;;OAA4B,YAA5B,uBAA4B,eAA/B,SAAsC,EAAtC,M;IAA2C,C;G;EAC7C,wE;IAAA,qB;MAAE,OAA8B,4BAA3B,4B;;OAA2B,YAA3B,uBAA2B,eAA9B,SAAqC,EAArC,M;IAA0C,C;G;EAC5C,wE;IAAA,qB;MAAE,OAA0B,wBAAvB,4B;;OAAuB,YAAvB,uBAAuB,eAA1B,SAAiC,EAAjC,M;IAAsC,C;G;;;;;;ECP6D,4E;IAIrG,sCACA,KADA,EAEA,cAFA,EAGA,eAHA,EAIA,0BAJA,EAKA,uEALA,EAMA,yDANA,EAOA,yDAPA,EAQA,wDARA,EASA,yDATA,C;G;EAKA,iG;IAAA,uB;MAAU,OAA8B,4BAA3B,4B;;OAA2B,YAA3B,uBAA2B,eAA9B,SAAqC,CAArC,UAAyE,iCAA/B,4B;;OAA+B,YAA/B,sBAA+B,eAAzE,SAAgF,CAAhF,M;IAAoF,C;G;EAC9F,2E;IAAA,qB;MAAE,OAA+B,6BAA5B,4B;;OAA4B,YAA5B,uBAA4B,eAA/B,SAAsC,EAAtC,M;IAA2C,C;G;EAC7C,2E;IAAA,qB;MAAE,OAA8B,4BAA3B,4B;;OAA2B,YAA3B,uBAA2B,eAA9B,SAAqC,EAArC,M;IAA0C,C;G;EAC5C,0E;IAAA,qB;MAAE,OAAkC,iCAA/B,4B;;OAA+B,YAA/B,sBAA+B,eAAlC,SAAyC,EAAzC,M;IAA8C,C;G;EAChD,2E;IAAA,qB;MAAE,OAA0B,wBAAvB,4B;;OAAuB,YAAvB,uBAAuB,eAA1B,SAAiC,EAAjC,M;IAAsC,C;G;;;;;;ECjB2D,0D;IAGnG,oCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,qDAJA,C;G;EAIA,uE;IAAA,qB;MAAE,OAA0B,wBAAvB,4B;;OAAuB,YAAvB,uBAAuB,eAA1B,SAAiC,EAAjC,M;IAAsC,C;G;;;;;;ECVuD,+C;IAE/F,gCAA2B,eAA3B,C;G;;;;;;ECCuG,8D;IAGvG,wCACA,KADA,EAEA,eAFA,EAGA,0BAHA,EAIA,yDAJA,C;G;EAIA,2E;IAAA,qB;MAAE,OAAwC,sCAArC,4B;;OAAqC,YAArC,uBAAqC,eAAxC,SAA+C,EAA/C,M;IAAoD,C;G;;;;;;ECtB1D,oC;IACI,wCAAqG,8C;;KAArG,C;IACA,OAAO,CAAE,a;EACb,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECYkG,4D;IAG9F,sCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,uDAJA,C;G;EAIA,yE;IAAA,qB;MAAE,OAA8B,4BAA3B,4B;;OAA2B,YAA3B,uBAA2B,eAA9B,SAAqC,EAArC,M;IAA0C,C;G;;;;;;ECLiD,2D;IAG7F,qCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,sDAJA,EAKA,sDALA,EAMA,sDANA,C;G;EAIA,wE;IAAA,qB;MAAE,OAA+B,6BAA5B,4B;;OAA4B,YAA5B,uBAA4B,eAA/B,SAAsC,EAAtC,M;IAA2C,C;G;EAC7C,wE;IAAA,qB;MAAE,OAA8B,4BAA3B,4B;;OAA2B,YAA3B,uBAA2B,eAA9B,SAAqC,EAArC,M;IAA0C,C;G;EAC5C,wE;IAAA,qB;MAAE,OAA0B,wBAAvB,4B;;OAAuB,YAAvB,uBAAuB,eAA1B,SAAiC,EAAjC,M;IAAsC,C;G;;;;;;ECPwD,8E;IAIhG,wCACA,KADA,EAEA,cAFA,EAGA,eAHA,EAIA,4BAJA,EAKA,yEALA,EAMA,yDANA,EAOA,yDAPA,EAQA,wDARA,EASA,yDATA,C;G;EAKA,mG;IAAA,uB;MAAU,OAA8B,4BAA3B,4B;;OAA2B,YAA3B,uBAA2B,eAA9B,SAAqC,CAArC,UAAyE,iCAA/B,4B;;OAA+B,YAA/B,sBAA+B,eAAzE,SAAgF,CAAhF,M;IAAoF,C;G;EAC9F,2E;IAAA,qB;MAAE,OAA+B,6BAA5B,4B;;OAA4B,YAA5B,uBAA4B,eAA/B,SAAsC,EAAtC,M;IAA2C,C;G;EAC7C,2E;IAAA,qB;MAAE,OAA8B,4BAA3B,4B;;OAA2B,YAA3B,uBAA2B,eAA9B,SAAqC,EAArC,M;IAA0C,C;G;EAC5C,0E;IAAA,qB;MAAE,OAAkC,iCAA/B,4B;;OAA+B,YAA/B,sBAA+B,eAAlC,SAAyC,EAAzC,M;IAA8C,C;G;EAChD,2E;IAAA,qB;MAAE,OAA0B,wBAAvB,4B;;OAAuB,YAAvB,uBAAuB,eAA1B,SAAiC,EAAjC,M;IAAsC,C;G;;;;;;ECjBsD,4D;IAG9F,sCACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,uDAJA,C;G;EAIA,yE;IAAA,qB;MAAE,OAA0B,wBAAvB,4B;;OAAuB,YAAvB,uBAAuB,eAA1B,SAAiC,EAAjC,M;IAAsC,C;G;;;;;;ECTkD,iD;IAE1F,kCAA8B,eAA9B,C;G;;;;;;ECAkG,gE;IAGlG,0CACA,KADA,EAEA,eAFA,EAGA,4BAHA,EAIA,2DAJA,C;G;EAIA,6E;IAAA,qB;MAAE,OAAwC,sCAArC,4B;;OAAqC,YAArC,uBAAqC,eAAxC,SAA+C,EAA/C,M;IAAoD,C;G;;;;;;ECtB1D,sC;IACI,wCAAmH,8C;;KAAnH,C;IACA,OAAO,CAAE,a;EACb,C;E1BgB0B,mF;IAAA,mB;MAAE,OAAyB,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAapC,qF;IAAA,mB;MAAE,OAAyB,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAc9C,qF;IAAA,mB;MAAE,OAA0B,gBAAS,CAAO,aAAM,QAAb,C;K;G;EAiBrB,uF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAc3B,yF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAe3C,yF;IAAA,mB;MAAE,OAAyB,eAAO,aAAM,QAAb,C;K;G;EAiBX,uF;IAAA,qB;MAAO,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAchC,yF;IAAA,qB;MAAO,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAerC,yF;IAAA,qB;MAAO,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,C;K;G;EAiB3B,uF;IAAA,yB;MAAW,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAcpC,yF;IAAA,yB;MAAW,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAepC,yF;IAAA,yB;MAAW,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,C;K;G;EAiBpC,uF;IAAA,6B;MAAe,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAcxC,yF;IAAA,6B;MAAe,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAepC,yF;IAAA,6B;MAAe,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,C;K;G;EAiB5C,uF;IAAA,iC;MAAmB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAc5C,yF;IAAA,iC;MAAmB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAepC,yF;IAAA,iC;MAAmB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,C;K;G;EAiBpD,uF;IAAA,qC;MAAuB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;EAchD,yF;IAAA,qC;MAAuB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;EAerC,yF;IAAA,qC;MAAuB,OAAyB,eAAO,aAAM,QAAb,EAAsB,EAAtB,EAA0B,EAA1B,EAA8B,EAA9B,EAAkC,EAAlC,EAAsC,EAAtC,C;K;G;E2B7T3F,uC;IlCgCwC,iC;IkCxBlC,O3BYI,4BAAkB,kB2BZM,S3BYN,E2BZY,Q3BYZ,EAHQ,wB2BTI,Q3BSoB,aAAxB,CAGR,C;G;E2BV5B,yC;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yC;IlCiBwC,iC;IkCTlC,O3BHI,4BAAkB,kB2BGM,S3BHN,EANF,yC2BSc,Q3BTd,E2BSQ,S3BTR,CAME,EAN2D,wB2BS/C,Q3BTuE,aAAxB,CAM3D,C;G;E2BM5B,2D;IlCMwC,iC;IkCMlC,O3BlBI,4BAAkB,kB2BkBM,S3BlBN,E2BkBY,Q3BlBZ,EAUS,wB2BQG,Q3BRqB,aAAxB,CAVT,CAaqB,gC2BKC,gB3BLD,C;G;E2BOjD,2D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,2D;IlCbwC,iC;IkCyBlC,O3BrCI,4BAAkB,kB2BqCM,S3BrCN,EAOF,2C2B8Bc,Q3B9Bd,E2B8BQ,S3B9BR,CAPE,EAO4D,wB2B8BhD,Q3B9BwE,aAAxB,CAP5D,CAaqB,gC2BwBC,gB3BxBD,C;G;E2B2BjD,yC;IlC5BwC,iC;IkCoClC,O3BnBI,4BAAkB,kB2BmBM,S3BnBN,E2BmBY,Q3BnBZ,EAHQ,wB2BsBI,Q3BtBoB,aAAxB,CAGR,C;G;E2BqB5B,yC;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,yC;IlC3CwC,iC;IOShC,QAAQ,2C2ByCwB,Q3BzCxB,E2ByCkB,S3BzClB,C;I2ByCV,O3BjCI,4BAAkB,kB2BiCM,S3BjCN,EAPG,CAOH,EAPM,wB2BwCM,Q3BxCkB,aAAxB,CAON,C;G;E2BsC5B,6C;IlCvDwC,iC;IkC+DlC,O3B/BI,4BAAkB,wB2B+BY,S3B/BZ,E2B+BkB,M3B/BlB,E2B+BkB,M3BlCC,aAGnB,C;G;E2BiC5B,+C;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,+C;IlCtEwC,iC;IkC+ElC,O3B/CI,4BAAkB,wB2B+CY,S3B/CZ,EANI,+C2BqDc,M3BrDd,E2BqDQ,S3BrDR,CAMJ,E2B+CkB,M3BrD6C,aAM/D,C;G;E2BkD5B,iE;IlClFwC,iC;IkC+FlC,O3B/DI,4BAAkB,wB2B+DY,S3B/DZ,E2B+DkB,M3B/DlB,E2B+DkB,M3BpDC,aAXnB,CAckB,gC2BiDQ,gB3BjDR,C;G;E2BmD9C,iE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,iE;IlCtGwC,iC;IkCoHlC,O3BpFI,4BAAkB,wB2BoFY,S3BpFZ,EAQI,iD2B4Ec,M3B5Ed,E2B4EQ,S3B5ER,CARJ,E2BoFkB,M3B5E6C,aAR/D,CAckB,gC2BsEQ,gB3BtER,C;G;E2ByE9C,+C;IlCvHwC,iC;IkCgIlC,O3BjEI,4BAAkB,wB2BiEY,S3BjEZ,E2BiEkB,M3BjElB,E2BiEkB,M3BpEC,aAGnB,C;G;E2BmE5B,+C;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,+C;IlCvIwC,iC;IOuDhC,QAAQ,iD2B0F8B,M3B1F9B,E2B0FwB,S3B1FxB,C;I2B0FV,O3B/EI,4BAAkB,wB2B+EY,S3B/EZ,EAVS,CAUT,EAVY,CAUZ,E2B+EkB,M3BzFI,aAUtB,C;G;E2BoF5B,qD;IlCtJwC,iC;IkC+JlC,O3BjFI,4BAAkB,wB2BiFY,S3BjFZ,E2BiFkB,M3BjFlB,E2BiF0B,I3BjF1B,E2BiFkB,M3BpFO,aAGzB,C;G;E2BmF5B,qD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,sD;IlCtKwC,iC;IkCgLlC,O3BlGI,4BAAkB,wB2BkGY,S3BlGZ,EANI,+C2BwGc,M3BxGd,E2BwGQ,S3BxGR,CAMJ,E2BkG0B,I3BlG1B,E2BkGkB,M3BxG4D,aAM9E,C;G;E2BqG5B,wE;IlCnLwC,iC;IkCgMlC,O3BlHI,4BAAkB,wB2BkHY,S3BlHZ,E2BkHkB,M3BlHlB,E2BkH0B,I3BlH1B,E2BkHkB,M3BvGO,aAXzB,CAcwB,gC2BoGQ,gB3BpGR,C;G;E2BsGpD,wE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,wE;IlCvMwC,iC;IkCqNlC,O3BvII,4BAAkB,wB2BuIY,S3BvIZ,EAQI,iD2B+Hc,M3B/Hd,E2B+HQ,S3B/HR,CARJ,E2BuI0B,I3BvI1B,E2BuIkB,M3B/H4D,aAR9E,CAcwB,gC2ByHQ,gB3BzHR,C;G;E2B4HpD,sD;IlCxNwC,iC;IkCiOlC,O3BpHI,4BAAkB,wB2BoHY,S3BpHZ,E2BoHkB,M3BpHlB,E2BoH0B,I3BpH1B,E2BoHkB,M3BvHO,aAGzB,C;G;E2BsH5B,sD;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,sD;IlCxOwC,iC;IOqGhC,QAAmB,iD2B6ImB,M3B7InB,E2B6Ia,S3B7Ib,C;I2B6IrB,O3BrII,4BAAkB,wB2BqIY,S3BrIZ,EAPS,CAOT,E2BqI0B,I3BrI1B,E2BqIkB,M3B5IO,aAOzB,C;G;E2B0I5B,4D;IlCvPwC,iC;IkCgQlC,O3BpII,4BAAkB,wB2BoIY,S3BpIZ,E2BoIkB,M3BpIlB,E2BoI0B,I3BpI1B,E2BoIgC,I3BpIhC,E2BoIkB,M3BvIa,aAG/B,C;G;E2BsI5B,4D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,4D;IlCvQwC,iC;IkCiRlC,O3BrJI,4BAAkB,wB2BqJY,S3BrJZ,EANI,+C2B2Jc,M3B3Jd,E2B2JQ,S3B3JR,CAMJ,E2BqJ0B,I3BrJ1B,E2BqJgC,I3BrJhC,E2BqJkB,M3B3J0E,aAM5F,C;G;E2BwJ5B,8E;IlCpRwC,iC;IkCiSlC,O3BrKI,4BAAkB,wB2BqKY,S3BrKZ,E2BqKkB,M3BrKlB,E2BqK0B,I3BrK1B,E2BqKgC,I3BrKhC,E2BqKkB,M3B1Ja,aAX/B,CAc8B,gC2BuJQ,gB3BvJR,C;G;E2ByJ1D,8E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,8E;IlCxSwC,iC;IkCsTlC,O3B1LI,4BAAkB,wB2B0LY,S3B1LZ,EAQI,iD2BkLc,M3BlLd,E2BkLQ,S3BlLR,CARJ,E2B0L0B,I3B1L1B,E2B0LgC,I3B1LhC,E2B0LkB,M3BlL0E,aAR5F,CAc8B,gC2B4KQ,gB3B5KR,C;G;E2B+K1D,4D;IlCzTwC,iC;IkCkUlC,O3BvKI,4BAAkB,wB2BuKY,S3BvKZ,E2BuKkB,M3BvKlB,E2BuK0B,I3BvK1B,E2BuKgC,I3BvKhC,E2BuKkB,M3B1Ka,aAG/B,C;G;E2ByK5B,4D;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,4D;IlCzUwC,iC;IOmJhC,QAAwB,iD2BgMc,M3BhMd,E2BgMQ,S3BhMR,C;I2BgM1B,O3BxLI,4BAAkB,wB2BwLY,S3BxLZ,EAPS,CAOT,E2BwL0B,I3BxL1B,E2BwLgC,I3BxLhC,E2BwLkB,M3B/La,aAO/B,C;G;E2B6L5B,kE;IlCxVwC,iC;IkCiWlC,O3BvLI,4BAAkB,wB2BuLY,S3BvLZ,E2BuLkB,M3BvLlB,E2BuL0B,I3BvL1B,E2BuLgC,I3BvLhC,E2BuLsC,I3BvLtC,E2BuLkB,M3B1LmB,aAGrC,C;G;E2ByL5B,kE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,kE;IlCxWwC,iC;IkCkXlC,O3BxMI,4BAAkB,wB2BwMY,S3BxMZ,EANI,+C2B8Mc,M3B9Md,E2B8MQ,S3B9MR,CAMJ,E2BwM0B,I3BxM1B,E2BwMgC,I3BxMhC,E2BwMsC,I3BxMtC,E2BwMkB,M3B9MwF,aAM1G,C;G;E2B2M5B,oF;IlCrXwC,iC;IkCkYlC,O3BxNI,4BAAkB,wB2BwNY,S3BxNZ,E2BwNkB,M3BxNlB,E2BwN0B,I3BxN1B,E2BwNgC,I3BxNhC,E2BwNsC,I3BxNtC,E2BwNkB,M3B7MmB,aAXrC,CAcoC,gC2B0MQ,gB3B1MR,C;G;E2B4MhE,oF;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,oF;IlCzYwC,iC;IkCuZlC,O3B7OI,4BAAkB,wB2B6OY,S3B7OZ,EAQI,iD2BqOc,M3BrOd,E2BqOQ,S3BrOR,CARJ,E2B6O0B,I3B7O1B,E2B6OgC,I3B7OhC,E2B6OsC,I3B7OtC,E2B6OkB,M3BrOwF,aAR1G,CAcoC,gC2B+NQ,gB3B/NR,C;G;E2BkOhE,kE;IlC1ZwC,iC;IkCmalC,O3B1NI,4BAAkB,wB2B0NY,S3B1NZ,E2B0NkB,M3B1NlB,E2B0N0B,I3B1N1B,E2B0NgC,I3B1NhC,E2B0NsC,I3B1NtC,E2B0NkB,M3B7NmB,aAGrC,C;G;E2B4N5B,kE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,kE;IlC1awC,iC;IOiMhC,QAA4B,iD2BmPU,M3BnPV,E2BmPI,S3BnPJ,C;I2BmP9B,O3B3OI,4BAAkB,wB2B2OY,S3B3OZ,EAPS,CAOT,E2B2O0B,I3B3O1B,E2B2OgC,I3B3OhC,E2B2OsC,I3B3OtC,E2B2OkB,M3BlPmB,aAOrC,C;G;E2BgP5B,wE;IlCzbwC,iC;IkCkclC,O3B1OI,4BAAkB,wB2B0OY,S3B1OZ,E2B0OkB,M3B1OlB,E2B0O0B,I3B1O1B,E2B0OgC,I3B1OhC,E2B0OsC,I3B1OtC,E2B0O4C,I3B1O5C,E2B0OkB,M3B7OyB,aAG3C,C;G;E2B4O5B,wE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,wE;IlCzcwC,iC;IkCmdlC,O3B3PI,4BAAkB,wB2B2PY,S3B3PZ,EANI,+C2BiQc,M3BjQd,E2BiQQ,S3BjQR,CAMJ,E2B2P0B,I3B3P1B,E2B2PgC,I3B3PhC,E2B2PsC,I3B3PtC,E2B2P4C,I3B3P5C,E2B2PkB,M3BjQsG,aAMxH,C;G;E2B8P5B,0F;IlCtdwC,iC;IkCmelC,O3B3QI,4BAAkB,wB2B2QY,S3B3QZ,E2B2QkB,M3B3QlB,E2B2Q0B,I3B3Q1B,E2B2QgC,I3B3QhC,E2B2QsC,I3B3QtC,E2B2Q4C,I3B3Q5C,E2B2QkB,M3BhQyB,aAX3C,CAc0C,gC2B6PQ,gB3B7PR,C;G;E2B+PtE,0F;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,0F;IlC1ewC,iC;IkCwflC,O3BhSI,4BAAkB,wB2BgSY,S3BhSZ,EAQI,iD2BwRc,M3BxRd,E2BwRQ,S3BxRR,CARJ,E2BgS0B,I3BhS1B,E2BgSgC,I3BhShC,E2BgSsC,I3BhStC,E2BgS4C,I3BhS5C,E2BgSkB,M3BxRsG,aARxH,CAc0C,gC2BkRQ,gB3BlRR,C;G;E2BqRtE,wE;IlC3fwC,iC;IkCogBlC,O3B7QI,4BAAkB,wB2B6QY,S3B7QZ,E2B6QkB,M3B7QlB,E2B6Q0B,I3B7Q1B,E2B6QgC,I3B7QhC,E2B6QsC,I3B7QtC,E2B6Q4C,I3B7Q5C,E2B6QkB,M3BhRyB,aAG3C,C;G;E2B+Q5B,wE;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,wE;IlC3gBwC,iC;IO+OhC,QAAgC,iD2BsSM,M3BtSN,E2BsSA,S3BtSA,C;I2BsSlC,O3B9RI,4BAAkB,wB2B8RY,S3B9RZ,EAPS,CAOT,E2B8R0B,I3B9R1B,E2B8RgC,I3B9RhC,E2B8RsC,I3B9RtC,E2B8R4C,I3B9R5C,E2B8RkB,M3BrSyB,aAO3C,C;G;E2BmS5B,8E;IlC1hBwC,iC;IkCmiBlC,O3B7RI,4BAAkB,wB2B6RY,S3B7RZ,E2B6RkB,M3B7RlB,E2B6R0B,I3B7R1B,E2B6RgC,I3B7RhC,E2B6RsC,I3B7RtC,E2B6R4C,I3B7R5C,E2B6RkD,I3B7RlD,E2B6RkB,M3BhS+B,aAGjD,C;G;E2B+R5B,8E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,8E;IlC1iBwC,iC;IkCojBlC,O3B9SI,4BAAkB,wB2B8SY,S3B9SZ,EANI,+C2BoTc,M3BpTd,E2BoTQ,S3BpTR,CAMJ,E2B8S0B,I3B9S1B,E2B8SgC,I3B9ShC,E2B8SsC,I3B9StC,E2B8S4C,I3B9S5C,E2B8SkD,I3B9SlD,E2B8SkB,M3BpToH,aAMtI,C;G;E2BiT5B,gG;IlCvjBwC,iC;IkCokBlC,O3B9TI,4BAAkB,wB2B8TY,S3B9TZ,E2B8TkB,M3B9TlB,E2B8T0B,I3B9T1B,E2B8TgC,I3B9ThC,E2B8TsC,I3B9TtC,E2B8T4C,I3B9T5C,E2B8TkD,I3B9TlD,E2B8TkB,M3BnT+B,aAXjD,CAcgD,gC2BgTQ,gB3BhTR,C;G;E2BkT5E,gG;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,gG;IlC3kBwC,iC;IkCylBlC,O3BnVI,4BAAkB,wB2BmVY,S3BnVZ,EAQI,iD2B2Uc,M3B3Ud,E2B2UQ,S3B3UR,CARJ,E2BmV0B,I3BnV1B,E2BmVgC,I3BnVhC,E2BmVsC,I3BnVtC,E2BmV4C,I3BnV5C,E2BmVkD,I3BnVlD,E2BmVkB,M3B3UoH,aARtI,CAcgD,gC2BqUQ,gB3BrUR,C;G;E2BwU5E,8E;IlC5lBwC,iC;IkCqmBlC,O3BhUI,4BAAkB,wB2BgUY,S3BhUZ,E2BgUkB,M3BhUlB,E2BgU0B,I3BhU1B,E2BgUgC,I3BhUhC,E2BgUsC,I3BhUtC,E2BgU4C,I3BhU5C,E2BgUkD,I3BhUlD,E2BgUkB,M3BnU+B,aAGjD,C;G;E2BkU5B,8E;IAGM,MAAM,kCAA8B,oJAA9B,C;G;EAEZ,8E;IlC5mBwC,iC;IO6RhC,QAAmC,iD2ByVG,M3BzVH,E2ByVH,S3BzVG,C;I2ByVrC,O3BjVI,4BAAkB,wB2BiVY,S3BjVZ,EAPS,CAOT,E2BiV0B,I3BjV1B,E2BiVgC,I3BjVhC,E2BiVsC,I3BjVtC,E2BiV4C,I3BjV5C,E2BiVkD,I3BjVlD,E2BiVkB,M3BxV+B,aAOjD,C;G;E4BrU5B,8D;InCkC8C,uC;ImCnBxC,sCCPE,kCAAwB,gCDOmC,SCPnC,EDOyC,QCPzC,EDOmD,SCPnD,CDO1B,C;G;EAEN,gE;InCiB8C,uC;ImCFxC,sCClBE,kCAAwB,gCDkBmC,SClBnC,EDkByC,QClBzC,EDkBmD,SClBnD,CDkB1B,C;G;EEnBF,mC;IrCuBqC,kC;IqCvB7B,O7BAJ,6BAAmB,yB6BAqB,S7BArB,C;G;E6BUvB,wC;IrCaqC,kC;IqCb7B,kC7BPJ,6BAAmB,4B6BO6C,S7BP7C,C6BOf,C;G;EAEZ,wD;IAqBM,OAA8C,QAAb,YAAxB,4BAAT,yBAAS,CAAwB,EAAU,CAAV,CAAa,EAAM,QAAN,EAAiB,aAAjB,S;G;EAEpD,uD;IAYM,OAA8C,QAAb,YAAxB,4BAAT,yBAAS,CAAwB,EAAU,CAAV,CAAa,EAAQ,sBAAR,C;G;EAEpD,sF;IAaM,OAA8C,UAAb,YAAxB,4BAAT,yBAAS,CAAwB,EAAU,CAAV,CAAa,EAAU,sBAAV,EAAmC,6BAAnC,S;G;EAEpD,2D;IAYM,OAAoC,QAAJ,UAAvB,2BAAT,yBAAS,CAAuB,CAAI,EAAM,QAAN,EAAiB,aAAjB,S;G;EAE1C,4D;IAYM,OAAoC,UAAJ,UAAvB,2BAAT,yBAAS,CAAuB,CAAI,EAAQ,sBAAR,C;G;EAE1C,2F;IAaM,OAAoC,YAAJ,UAAvB,2BAAT,yBAAS,CAAuB,CAAI,EAAU,sBAAV,EAAmC,6BAAnC,S;G;EAG1C,6D;IAWM,OAAc,QAAd,8BAAc,EAAM,QAAN,EAAiB,aAAjB,S;G;EAEpB,wD;IAYM,OAA8C,QAAb,YAAxB,4BAAT,yBAAS,CAAwB,EAAU,CAAV,CAAa,EAAQ,sBAAR,C;G;EAEpD,mD;IAYM,OAAc,QAAd,8BAAc,EAAQ,sBAAR,C;G;EAEpB,iD;IrC9HyC,kC;IqCwInC,sC7B3Ha,6BAAmB,a6B2HK,S7B3HL,E6B2HW,sB7B3HX,C6B2HhC,C;G;EC5KN,uC;IAaM,sCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,4C;IAiBM,wCAA2B,KAA3B,EAAkC,SAAlC,EAAwC,yBAAxC,C;G;EAEN,mC;IAaM,sCAAyB,KAAzB,EAAgC,SAAhC,C;G;EAEN,wC;IAkBM,qCAAwB,KAAxB,EAA+B,SAA/B,C;G;EAEN,iD;IAaM,0CAA6B,KAA7B,EAAoC,SAApC,C;G;EC3EF,gD;IvC6BqC,kC;IQIT,0C;IAgEQ,sD;I+BjG5B,O/B2IJ,yCAAuB,oB+B3IsC,S/B2ItC,C;G;E+BjI3B,4B;IvCmBqC,kC;IQIT,0C;IAgEQ,sD;I+BtF5B,O/BmIJ,yCAAuB,wB+BnI0C,S/BmI1C,C;G;E+BzH3B,+C;IvCQqC,kC;IQIT,0C;IAgEQ,sD;I+B5E5B,O/B4HJ,yCAAuB,iB+B5HmC,S/B4HnC,C;G;E+BjH3B,8B;IvCHqC,kC;IQIT,0C;IAgEQ,sD;I+BhE5B,O/BmHJ,yCAAuB,qB+BnHuC,S/BmHvC,C;G;E+BzG3B,kC;IvCdqC,kC;IQIT,0C;IAgEQ,sD;I+BtD5B,O/B4GJ,yCAAuB,4B+B5G8C,S/B4G9C,C;G;E+BnG3B,kC;IvCvBqC,kC;IQIT,0C;IAgEQ,sD;I+B7C5B,O/BsGJ,yCAAuB,kC+BtGoD,S/BsGpD,C;G;EgC5J/B,qC;IAaM,0BAAM,QAAN,K;G;EAEN,qD;IxCgByC,kC;IQIT,0C;IgCGgB,iBrClCgB,aqCkCO,QrClCP,EqCkCqB,arClCrB,C;IqCkC1D,iChCmBE,qCAA2B,0BgCnB8B,ShCmB9B,EAAgC,UAAhC,CgCnB7B,C;G;EAEN,oD;IAgBM,4BAAU,sBAAV,K;G;EAEN,qF;IxC3ByC,kC;IQIT,0C;IgC4CgB,wBrC3EgB,aqC2EkB,sBrC3ElB,EqC2E8C,6BrC3E9C,C;IqC2E1D,iChC6BE,qCAA2B,qCgC7ByC,ShC6BzC,EAA2C,iBAA3C,CgC7B7B,C;G;EAEN,8C;IASuB,wCAAsB,SAAtB,C;G;EC1FvB,qC;IAaM,0BAAM,QAAN,K;G;EAEN,qD;IzCgByC,kC;IQIT,0C;IiCNgB,iBtCzBgB,asCyBW,QtCzBX,EsCyByB,atCzBzB,C;IsCyB1D,iCjCsCE,qCAA2B,8BiCtCkC,SjCsClC,EAA8B,UAA9B,CiCtC7B,C;G;EAEN,sD;IAcM,8BAAU,sBAAV,K;G;EAEN,uF;IzChByC,kC;IQIT,0C;IiC0CgB,wBtCzEgB,asCyEsB,sBtCzEtB,EsCyEkD,6BtCzElD,C;IsCyE1D,iCjCuCE,qCAA2B,yCiCvC6C,SjCuC7C,EAAyC,iBAAzC,CiCvC7B,C;G;EAEN,8C;IASuB,0CAAsB,SAAtB,C;G;EC3FvB,qC;IAaM,0BAAM,QAAN,K;G;EAGN,qD;I1CkByC,kC;IQIT,0C;IkCTgB,iBvCtBgB,auCsBQ,QvCtBR,EuCsBsB,avCtBtB,C;IuCsB1D,iClCmDE,qCAA2B,2BkCnD+B,SlCmD/B,EAA2B,UAA3B,CkCnD7B,C;G;EAEN,sD;IAcM,8BAAU,sBAAV,K;G;EAEN,uF;I1CbyC,kC;IQIT,0C;IkC8BgB,wBvC7DgB,auC6DmB,sBvC7DnB,EuC6D+C,6BvC7D/C,C;IuC6D1D,iClC0DE,qCAA2B,sCkC1D0C,SlC0D1C,EAAsC,iBAAtC,CkC1D7B,C;G;ECnEN,0F;I3CiCyC,kC;IQIT,0C;ImClBC,aAEzB,aAAa,UAAb,EAAyB,WAAzB,EAAsC,mBAAtC,C;IAHe,iCnCuEJ,qCAA2B,kCmCrEtC,SnCqEsC,EAAkC,MAAlC,CmCvEvB,C;G;EAOvB,4F;I3CQyC,kC;IQIT,0C;ImCaC,aAEzB,aAAa,UAAb,EAAyB,WAAzB,EAAsC,mBAAtC,C;IAHe,iCnCmFJ,qCAA2B,6CmCjFtC,SnCiFsC,EAA6C,MAA7C,CmCnFvB,C;G;ECtDvB,+B;IAUM,O5C8B+B,8B4C9Bf,aAAI,SAAJ,EAAU,KAAV,C;G;EAEtB,mD;I5C4BqC,8B;I4ChB/B,sCCEE,yBAAe,aDFgB,SCEhB,EDFsB,KCEtB,EDF6B,gBCE7B,CDFjB,C;G;EAEN,iC;IAUM,O5CI+B,8B4CJf,qBAAY,SAAZ,EAAkB,KAAlB,C;G;EEjCtB,oD;I9CuCoC,6B;I8CxBF,oB3CP8B,a2COf,K3CPe,E2COJ,Y3CPI,C;I2CO1D,sCCsCE,wBAAc,kBDtCqB,SCsCrB,EAAgB,aAAhB,CDtChB,C;G;EAEN,yD;I9CsBoC,6B;I8CHgE,kB3C5BpC,a2C4BM,Q3C5BN,E2C4BoB,c3C5BpB,C;IE2wCrD,kBAAM,eAAa,qCAAwB,EAAxB,CAAb,C;IAqEA,Q;IAAA,6B;IAAb,OAAa,cAAb,C;MAAa,sB;MACT,WAAY,WAAc,IyCrzC2E,SzCqzCzF,C;;IyCrzChB,sCCwBI,wBAAc,wCDxByC,SCwBzC,E1C8xCX,W0C9xCW,CDxBlB,C;G;EAGJ,qC;I9CAoC,6B;I8CQ9B,sCCpBE,wBAAc,qBDoBwB,SCpBxB,EDoB8B,GCpB9B,CDoBhB,C;G;EAEN,0C;I9CVoC,6B;I8CkB9B,sCC3BE,wBAAc,wBD2B2B,SC3B3B,ED2BiC,GC3BjC,CD2BhB,C;G;EAGN,wC;I9CrBoC,6B;I8CgC9B,OCNE,wBAAc,qBDMW,SCNX,EDMiB,GCNjB,C;G;EDQtB,4D;I9ClCoC,6B;I8C8C9B,sCCZE,wBAAc,qBDYwB,SCZxB,EDY8B,GCZ9B,EDYmC,gBCZnC,CDYhB,C;G;EAGN,0C;I9CjDoC,6B;I8C2D9B,OCpBE,wBAAc,6BDoBmB,SCpBnB,EDoByB,GCpBzB,C;G;EDuBtB,0C;I9C9DoC,6B;I8CuE9B,sCCpByE,wBAAc,iBDoBnD,SCpBmD,EDoB7C,ICpB6C,CDoBvF,C;G;EAEN,8B;I9CzEoC,6B;I8CiF9B,sCCtFE,wBAAc,iBDsFoB,SCtFpB,CDsFhB,C;G;EAEN,mC;I9CnFoC,6B;I8C2F9B,sCCxFE,wBAAc,oBDwFuB,SCxFvB,CDwFhB,C;G;EAYgC,6B;IAAyB,+DAAS,qB;aAAe,c;KAAxB,E;G;EAE/D,2C;I9CzGoC,6B;I8CoH9B,sCC1Da,wBAAc,cD0DM,SC1DN,ED0DY,gBC1DZ,CD0D3B,C;G;EAYkC,+B;IAAgC,iEAAS,qB;aAAe,gB;KAAxB,E;G;EAExE,6C;I9ClIoC,6B;I8C6I9B,sCC5Ea,wBAAc,gBD4EQ,SC5ER,ED4Ec,gBC5Ed,CD4E3B,C;G;EAa0C,8B;IAAE,OAAA,EAAG,Q;EAAQ,C;EAX7D,8B;IAWM,O5CnKE,+BAAsB,gB4CmKC,S5CnKD,C4CmKO,oBAAW,gBAAX,C;G;EAErC,kD;IAWM,OAAA,oBAAY,gCAAuB,gBAAvB,C;G;EEjNlB,4C;IhD0CoC,6B;I+C5BqB,kC;ICAnD,sCCsBa,6BAAmB,oBDtBa,SCsBb,EDtBmB,GCsBnB,EDtBwB,KCsBxB,CDtBhC,C;G;EAYoC,4B;IAAoB,8DAAS,qB;aAAiB,a;KAA1B,E;G;EAa1B,8B;IAAoC,8DAAS,qB;aAAiB,a;KAA1B,E;G;EAExE,0C;IhDCoC,6B;I+C5BqB,kC;ICuCnD,sCCVa,6BAAmB,aDUM,SCVN,EDUY,gBCVZ,CDUhC,C;G;EAasC,8B;IAAoB,gEAAS,qB;aAAiB,e;KAA1B,E;G;EAa1B,gC;IAAoC,gEAAS,qB;aAAiB,e;KAA1B,E;G;EAE1E,4C;IhDvCoC,6B;I+C5BqB,kC;IC+EnD,sCC3Ca,6BAAmB,eD2CQ,SC3CR,ED2Cc,gBC3Cd,CD2ChC,C;G;EEnFiC,8B;IAAoB,gEAAS,qB;aAAY,e;KAArB,E;G;EAa1B,gC;IAAoC,gEAAS,qB;aAAY,e;KAArB,E;G;EAGrE,4C;IlDkBqC,8B;IkDN/B,sCClBa,yBAAe,eDkBO,SClBP,EDkBa,gBClBb,CDkB5B,C;G;EAYkC,+B;IAAoB,iEAAS,qB;aAAY,gB;KAArB,E;G;EAa1B,iC;IAAoC,iEAAS,qB;aAAY,gB;KAArB,E;G;EAGtE,6C;IlDtBqC,8B;IkDkC/B,sCCnDa,yBAAe,gBDmDQ,SCnDR,EDmDc,gBCnDd,CDmD5B,C;G;EE5DmB,mC;IACrB,wC;G;6BAEA,Y;IAAsD,cAAO,qBAAP,C;G;;;;;;EAe/B,0E;IACvB,oD;IACA,kE;G;;SAEsB,Y;MAAQ,kC;K;;;SACH,Y;MAAQ,yC;K;;+BAEnC,Y;IAAsD,OjDhCM,aiDgCN,2BjDhCM,EiDgCsB,kCjDhCtB,C;G;;;;;;EiDyC7B,oD;IAAC,c;IAAY,8D;G;8BAC5C,Y;IAAiD,oBAAO,gCAAP,C;G;gCACjD,Y;IACM,yBAAe,QAAf,iBAAgC,wCAAJ,GAAyC,MAAzC,GAAqD,QAAjF,O;G;;;;;;kCARV,Y;IAKoC,e;G;kCALpC,Y;IAKgD,uC;G;oCALhD,4C;IAAA,oBAKoC,+BALpC,EAKgD,uGALhD,C;G;gCAAA,Y;IAAA,c;IAKoC,oD;IAAY,4E;IALhD,a;G;8BAAA,iB;IAAA,4IAKoC,kCALpC,IAKgD,kFALhD,I;G;EAesB,wB;IAAC,wB;G;0BACnB,Y;IAAwB,cAAO,aAAP,C;G;;;;;;8BAL5B,Y;IAIuB,oB;G;8BAJvB,oB;IAAA,gBAIuB,8CAJvB,C;G;4BAAA,Y;IAAA,OAIuB,iDAJvB,M;G;4BAAA,Y;IAAA,c;IAIuB,yD;IAJvB,a;G;0BAAA,iB;IAAA,2IAIuB,4CAJvB,G;G;EAYkB,wC;IACd,kC;IACA,4C;G;;SADA,Y;MAAA,8B;K;;;SACA,Y;MAAA,mC;K;;2BAEA,Y;IAAwB,iBAAO,aAAP,SAAkB,kBAAlB,E;G;;;;;;EClEoB,iC;IAAE,OAAG,aAAH,EAAG,C;EAAa,C;EAXlE,kC;IAWM,OnDyBE,+BAAsB,gBmDzBC,SnDyBD,CmDzBO,oBAAW,mBAAX,C;G;0GCHrC,yB;IAAA,gC;ItDyCkC,6G;ISF9B,2K;I6CvCJ,wE;MtDyC0C,mC;MStBZ,yC;M6CNE,yC;M7CgCxB,kCAA0B,c6ChCG,S7CgCH,EAA6B,YAA7B,E6ChC2B,gB7CgC3B,C;I6C/BlC,C;GAdA,C;EAgBA,gC;ItDyB0C,mC;IStBZ,yC;IA+BtB,oCAA0B,uB6CvBY,S7CuBZ,C;E6CtBlC,C;EAEA,8C;IAciC,kBAA7B,2DAAS,qB;aAAW,iB;KAApB,E;ItDxBgC,6B;IuDTJ,uC;IAA5B,iCtD2CI,wBAAc,mBsD3CoB,WtD2CpB,EAAiB,IAAjB,EqDVwB,gBrDUxB,CsD3ClB,C;EDkCJ,C;EAoBY,yE;IAAA,4B;MAAE,oBAAS,gBAAT,EAAoB,qBAApB,S;MAAmC,W;IAAA,C;G;EAlBjD,6D;IAkBI,mBAAQ,+CAAR,C;EACJ,C;wHCpEA,yB;IAAA,gC;IvDsB4B,6G;IC4BxB,mJ;IsDlDJ,wD;MvDsBoC,6B;MuDTJ,yB;MAA5B,+BtD2CI,wBAAc,mBsD3CoB,StD2CpB,EAAiB,IAAjB,EsD3CoC,gBtD2CpC,CsD3ClB,C;IACJ,C;GAdA,C;4GAgBA,yB;IAAA,gC;IvDM4B,6G;ICkFxB,iL;IsDxFJ,8D;MvDMoC,6B;MCyDpB,+C;MsDtCsB,+B;MtDmE9B,wCAAgC,asDnEE,StDmEF,EAAW,OAAX,EsDnEqB,gBtDmErB,C;IsDlExC,C;GA1BA,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}